{
    "docs": [
        {
            "location": "/", 
            "text": "Cozy Documentation\n\n\nThe go-to website about Cozy configuration and setup.\n\n\n\n\n\n    \n\n      \n\n      \nLearn how to use your server\n\n    \n\n  \n\n\n\n    \n\n      \n\n      \nKeep your devices in sync\n\n    \n\n  \n\n\n\n    \n\n      \n\n      \nInstall your own server\n\n    \n\n  \n\n\n\n    \n\n      \n\n      \nDevelop applications\n\n      Learn how to develop applications and connectors.\n    \n\n  \n\n\n\n\nGet in touch\n\n\nIf you have any questions, you can contact us via these 3 medias:\n\n\n\n\nWrite an email to our Support team: contact at cozy.io\n\n\nPost on the forum\n\n\nChat with us on IRC", 
            "title": "Home"
        }, 
        {
            "location": "/#cozy-documentation", 
            "text": "The go-to website about Cozy configuration and setup.   \n     \n       \n       Learn how to use your server \n     \n    \n     \n       \n       Keep your devices in sync \n     \n    \n     \n       \n       Install your own server \n     \n    \n     \n       \n       Develop applications \n      Learn how to develop applications and connectors.", 
            "title": "Cozy Documentation"
        }, 
        {
            "location": "/#get-in-touch", 
            "text": "If you have any questions, you can contact us via these 3 medias:   Write an email to our Support team: contact at cozy.io  Post on the forum  Chat with us on IRC", 
            "title": "Get in touch"
        }, 
        {
            "location": "/use/", 
            "text": "Welcome to your new home\n\n\nHello, I\u2019m Claude, Cozy support team member. Let me introduce you to your new home in the cloud.\n\n\nOur charter\n\n\nBefore starting the visit, I\u2019d like to tell you a few words about our values. Our priority is to help you take back the control on your data, by importing them into a safe place, a place that you\u2019re the only one to have access.\n\n\nIn your personal cloud, you\u2019re at home\n\n\nBy default, you are the only one that can access your data. (\u2026)\n\n\nYour data belongs to you\n\n\nYour are the one and only owner of the data stored on your cloud.\n\n\nOpenness brings confidence\n\n\nCozy is and will stay a service built on free software: you can use, copy, improve the source code.\n\n\nYou decide how your data can be used\n\n\nYour Cozy server allows to control the data that you share with third party.\n\n\nCreate your home in the cloud\n\n\nYour home has an address. Your home in the cloud also has an address. Let\u2019s choose it!\n\n\n\n\nClaude\u2019s tip\n\n\nCreating a good password may be hard.\n\n\n\n\nYour toolbox\n\n\nSave all your files and documents in just a click\n\n\nAccess your files wherever your are, whenever you want\n\n\nConnect to deconnect\n\n\nChecklist\n\n\nHave you installed the Cozy application on your phone?\n\n\nHave you installed the Cozy application on your computers?\n\n\nAny question?\n\n\nOne last surprise", 
            "title": "User guide"
        }, 
        {
            "location": "/use/#welcome-to-your-new-home", 
            "text": "Hello, I\u2019m Claude, Cozy support team member. Let me introduce you to your new home in the cloud.", 
            "title": "Welcome to your new home"
        }, 
        {
            "location": "/use/#our-charter", 
            "text": "Before starting the visit, I\u2019d like to tell you a few words about our values. Our priority is to help you take back the control on your data, by importing them into a safe place, a place that you\u2019re the only one to have access.", 
            "title": "Our charter"
        }, 
        {
            "location": "/use/#in-your-personal-cloud-youre-at-home", 
            "text": "By default, you are the only one that can access your data. (\u2026)", 
            "title": "In your personal cloud, you\u2019re at home"
        }, 
        {
            "location": "/use/#your-data-belongs-to-you", 
            "text": "Your are the one and only owner of the data stored on your cloud.", 
            "title": "Your data belongs to you"
        }, 
        {
            "location": "/use/#openness-brings-confidence", 
            "text": "Cozy is and will stay a service built on free software: you can use, copy, improve the source code.", 
            "title": "Openness brings confidence"
        }, 
        {
            "location": "/use/#you-decide-how-your-data-can-be-used", 
            "text": "Your Cozy server allows to control the data that you share with third party.", 
            "title": "You decide how your data can be used"
        }, 
        {
            "location": "/use/#create-your-home-in-the-cloud", 
            "text": "Your home has an address. Your home in the cloud also has an address. Let\u2019s choose it!   Claude\u2019s tip  Creating a good password may be hard.", 
            "title": "Create your home in the cloud"
        }, 
        {
            "location": "/use/#your-toolbox", 
            "text": "", 
            "title": "Your toolbox"
        }, 
        {
            "location": "/use/#save-all-your-files-and-documents-in-just-a-click", 
            "text": "", 
            "title": "Save all your files and documents in just a click"
        }, 
        {
            "location": "/use/#access-your-files-wherever-your-are-whenever-you-want", 
            "text": "", 
            "title": "Access your files wherever your are, whenever you want"
        }, 
        {
            "location": "/use/#connect-to-deconnect", 
            "text": "", 
            "title": "Connect to deconnect"
        }, 
        {
            "location": "/use/#checklist", 
            "text": "", 
            "title": "Checklist"
        }, 
        {
            "location": "/use/#have-you-installed-the-cozy-application-on-your-phone", 
            "text": "", 
            "title": "Have you installed the Cozy application on your phone?"
        }, 
        {
            "location": "/use/#have-you-installed-the-cozy-application-on-your-computers", 
            "text": "", 
            "title": "Have you installed the Cozy application on your computers?"
        }, 
        {
            "location": "/use/#any-question", 
            "text": "", 
            "title": "Any question?"
        }, 
        {
            "location": "/use/#one-last-surprise", 
            "text": "", 
            "title": "One last surprise"
        }, 
        {
            "location": "/sync/", 
            "text": "Sync all your devices with your server\n\n\n\n\nsynchronize your phone\n\n\nsynchronize your desktop computer", 
            "title": "Stay in sync"
        }, 
        {
            "location": "/sync/#sync-all-your-devices-with-your-server", 
            "text": "synchronize your phone  synchronize your desktop computer", 
            "title": "Sync all your devices with your server"
        }, 
        {
            "location": "/sync/phone/", 
            "text": "Sync your phone with your server\n\n\nComing soon!", 
            "title": "Synchronize your phone"
        }, 
        {
            "location": "/sync/phone/#sync-your-phone-with-your-server", 
            "text": "Coming soon!", 
            "title": "Sync your phone with your server"
        }, 
        {
            "location": "/sync/desktop/", 
            "text": "Sync your desktop computer with your server\n\n\nCozy Drive for desktop allows you to synchronize your files and folders between your Cozy and your desktop. Thus, you can work on your files offline. Your modifications will be synchronized as soon as network will be available.\n\n\nInstallation\n\n\nBefore installing Cozy Drive, make sure your Cozy should be up-to-date.\n\n\nWindows\n\n\nYou can download Cozy Drive for Windows on \nthis page\n.\n\n\nList of known to work versions\n\n\nMacOS\n\n\nYou can download Cozy Drive for macOS on \nthis page\n.\n\n\nList of known to work versions\n\n\nLinux\n\n\nLearn how to download and use the GNU/linux client on \nthis page\n.\n\n\nConfiguration\n\n\nAt the end of the installation, application will start and ask you for a few informations:\n\n\n\n\nYour Cozy URL. In other words, the address used to access to your Cozy.\n\n\nYour Cozy password. We don\u2019t save your password, we only use it to create a new device login which it uses to synchronize your files.\n\n\nThe folder where you want to synchronize your files.\n\n\n\n\n\n\nOnce done, you will be redirected to the dashboard. First synchronization can now start.\n\n\nThe dashboard is composed of :\n\n\n\n\nAn information panel about synchronizations and available disk space on your Cozy.\n\n\nA settings panel to configure autostart.\n\n\nAn account panel with information on your Cozy and possibility to unlink your Cozy.\n\n\nA help panel in case of problem\n\n\n\n\n\n\nTroubleshooting\n\n\nWhen you hit a problem with the application, you can send us a message with the application logs, so we can try to understand and fix the problem.\n\n\nOpen help panel, then click on \nSend us a message\n in \nOfficial support\n.\n\n\n\n\nDon\u2019t forget to describe your problem by adding as many details as you can.", 
            "title": "Synchronize your computer"
        }, 
        {
            "location": "/sync/desktop/#sync-your-desktop-computer-with-your-server", 
            "text": "Cozy Drive for desktop allows you to synchronize your files and folders between your Cozy and your desktop. Thus, you can work on your files offline. Your modifications will be synchronized as soon as network will be available.", 
            "title": "Sync your desktop computer with your server"
        }, 
        {
            "location": "/sync/desktop/#installation", 
            "text": "Before installing Cozy Drive, make sure your Cozy should be up-to-date.", 
            "title": "Installation"
        }, 
        {
            "location": "/sync/desktop/#windows", 
            "text": "You can download Cozy Drive for Windows on  this page .  List of known to work versions", 
            "title": "Windows"
        }, 
        {
            "location": "/sync/desktop/#macos", 
            "text": "You can download Cozy Drive for macOS on  this page .  List of known to work versions", 
            "title": "MacOS"
        }, 
        {
            "location": "/sync/desktop/#linux", 
            "text": "Learn how to download and use the GNU/linux client on  this page .", 
            "title": "Linux"
        }, 
        {
            "location": "/sync/desktop/#configuration", 
            "text": "At the end of the installation, application will start and ask you for a few informations:   Your Cozy URL. In other words, the address used to access to your Cozy.  Your Cozy password. We don\u2019t save your password, we only use it to create a new device login which it uses to synchronize your files.  The folder where you want to synchronize your files.    Once done, you will be redirected to the dashboard. First synchronization can now start.  The dashboard is composed of :   An information panel about synchronizations and available disk space on your Cozy.  A settings panel to configure autostart.  An account panel with information on your Cozy and possibility to unlink your Cozy.  A help panel in case of problem", 
            "title": "Configuration"
        }, 
        {
            "location": "/sync/desktop/#troubleshooting", 
            "text": "When you hit a problem with the application, you can send us a message with the application logs, so we can try to understand and fix the problem.  Open help panel, then click on  Send us a message  in  Official support .   Don\u2019t forget to describe your problem by adding as many details as you can.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/sync/linux/", 
            "text": "Install the desktop client on your GNU/Linux system\n\n\nTo ease the use of Cozy Drive on any distribution, we distribute the application using the \nAppImage\n format. This way, you have nothing to install, just download the application and run it.\n\n\nWe provide packages for both \n32 bits\n and \n64 bits\n systems. All you have to do is download the file, move it to some dedicated folder, make it executable and run it.\n\n\nList of known to work distributions\n\n\nDetailed instructions on Gnome\n\n\nClick on one of these links to download Cozy Drive for your OS:\n\n\n\n\nCozy Drive for GNU/Linux 32 bits\n;\n\n\nCozy Drive for GNU/Linux 64 bits\n;\n\n\n\n\nOnce the binary file downloaded, go to the folder where your browser has stored it. For example, if you use Firefox, click on the folder icon in the download list.\n\n\n\n\nTo be able to run the application, you have to edit its properties to make it executable. Just right click on the application and select \nProperties\n inside the context menu:\n\n\n\nThen go to the \nPermissions\n tab and check the box to make the application executable:\n\n\n\nThere\u2019s no need to install the application, you can just run it from the folder you have downloaded it, but we recommend to move it to a dedicated folder to be able to find it easily. You can create an \nApplications\n folder inside your home directory and move the application there:\n\n\n\n\n\n\n\n\nTip: you can add this folder to your bookmarks to find it easily:\n\n\n\n\nFrom 3.26 onwards, GNOME removed the systray (that little bar with some icons) which is the interface for \nCozy Drive\n. You will need to install an extension such as \nTopIcons\n in order to see the cozy-desktop application and launch it.\n\n\nThat\u2019s all. You can now double-click on the application to launch it and connect it to your server. Have fun!\n\n\nMore\n\n\nMore in deep insights on the GNU/Linux client\n.\n\n\nIf your distribution is not supported, you can try the \nmanual build guide\n.", 
            "title": "Install on GNU/Linux"
        }, 
        {
            "location": "/sync/linux/#install-the-desktop-client-on-your-gnulinux-system", 
            "text": "To ease the use of Cozy Drive on any distribution, we distribute the application using the  AppImage  format. This way, you have nothing to install, just download the application and run it.  We provide packages for both  32 bits  and  64 bits  systems. All you have to do is download the file, move it to some dedicated folder, make it executable and run it.  List of known to work distributions", 
            "title": "Install the desktop client on your GNU/Linux system"
        }, 
        {
            "location": "/sync/linux/#detailed-instructions-on-gnome", 
            "text": "Click on one of these links to download Cozy Drive for your OS:   Cozy Drive for GNU/Linux 32 bits ;  Cozy Drive for GNU/Linux 64 bits ;   Once the binary file downloaded, go to the folder where your browser has stored it. For example, if you use Firefox, click on the folder icon in the download list.   To be able to run the application, you have to edit its properties to make it executable. Just right click on the application and select  Properties  inside the context menu:  Then go to the  Permissions  tab and check the box to make the application executable:  There\u2019s no need to install the application, you can just run it from the folder you have downloaded it, but we recommend to move it to a dedicated folder to be able to find it easily. You can create an  Applications  folder inside your home directory and move the application there:     Tip: you can add this folder to your bookmarks to find it easily:   From 3.26 onwards, GNOME removed the systray (that little bar with some icons) which is the interface for  Cozy Drive . You will need to install an extension such as  TopIcons  in order to see the cozy-desktop application and launch it.  That\u2019s all. You can now double-click on the application to launch it and connect it to your server. Have fun!", 
            "title": "Detailed instructions on Gnome"
        }, 
        {
            "location": "/sync/linux/#more", 
            "text": "More in deep insights on the GNU/Linux client .  If your distribution is not supported, you can try the  manual build guide .", 
            "title": "More"
        }, 
        {
            "location": "/download/", 
            "text": "Download Cozy Drive for all your devices\n\n\nCozy Drive on your phone\n\n\n\n\n Cozy Drive for iOS\n\n\nRequires iOS 10\n\n\n\n\n\n\n\n\n Cozy Drive for Android\n\n\nRequires Android 5.0.0\n\n\n\n\n(Advanced users that don\u2019t want to connect to Google Play can \nuse the APK\n)\n\n\n\n\nCozy Drive on your computer\n\n\n\n\n Cozy Drive for Mac OS\n\n\n\n\nDownload for MacOS\n\n\n\n\nActively tested on MacOS 10.12.x Sierra and higher, \nshould work on older versions\n\n\n\n\n\n\n Cozy Drive for Windows\n\n\n\n\nDownload for Microsoft Windows\n\n\n\n\nActively tested on Windows 10, \nshould work on older versions\n\n\n\n\n\n\nCozy Drive for GNU/Linux\n\n\nFull documentation\n on how to install Cozy Drive for GNU/Linux.\n\n\nList of known to work distributions", 
            "title": "Download"
        }, 
        {
            "location": "/download/#download-cozy-drive-for-all-your-devices", 
            "text": "", 
            "title": "Download Cozy Drive for all your devices"
        }, 
        {
            "location": "/download/#cozy-drive-on-your-phone", 
            "text": "", 
            "title": "Cozy Drive on your phone"
        }, 
        {
            "location": "/download/#cozy-drive-for-ios", 
            "text": "Requires iOS 10", 
            "title": "Cozy Drive for iOS"
        }, 
        {
            "location": "/download/#cozy-drive-for-android", 
            "text": "Requires Android 5.0.0   (Advanced users that don\u2019t want to connect to Google Play can  use the APK )", 
            "title": "Cozy Drive for Android"
        }, 
        {
            "location": "/download/#cozy-drive-on-your-computer", 
            "text": "", 
            "title": "Cozy Drive on your computer"
        }, 
        {
            "location": "/download/#cozy-drive-for-mac-os", 
            "text": "Download for MacOS   Actively tested on MacOS 10.12.x Sierra and higher,  should work on older versions", 
            "title": "Cozy Drive for Mac OS"
        }, 
        {
            "location": "/download/#cozy-drive-for-windows", 
            "text": "Download for Microsoft Windows   Actively tested on Windows 10,  should work on older versions", 
            "title": "Cozy Drive for Windows"
        }, 
        {
            "location": "/download/#cozy-drive-for-gnulinux", 
            "text": "Full documentation  on how to install Cozy Drive for GNU/Linux.  List of known to work distributions", 
            "title": "Cozy Drive for GNU/Linux"
        }, 
        {
            "location": "/install/", 
            "text": "Install Cozy on your own server\n\n\nLearn how to install Cozy \non Debian Stretch, Ubuntu Xenial or Raspbian Stretch\n;", 
            "title": "Install Cozy on your own server"
        }, 
        {
            "location": "/install/#install-cozy-on-your-own-server", 
            "text": "Learn how to install Cozy  on Debian Stretch, Ubuntu Xenial or Raspbian Stretch ;", 
            "title": "Install Cozy on your own server"
        }, 
        {
            "location": "/install/debian/", 
            "text": "Install Cozy on a Debian server\n\n\nA Debian repository serves packages to setup a Cozy self-hosted environment.\n\n\nIt provides:\n\n\n\n\ncozy-couchdb\n: \nCouchDB\n database engine used by cozy\n\n\ncozy-nsjail\n: \nNSJail\n isolation tool used by konnectors\n\n\ncozy-stack\n: \nCozy core\n\n\ncozy-coclyco\n: \nCLI\n to manage vhosts and certificates\n\n\ncozy\n: metapackage installing everything to setup a self-hosted environment\n\n\n\n\nThis repository currently supports:\n\n\n\n\nDebian Stretch\n (9.x): amd64\n\n\nUbuntu Xenial\n (16.04 LTS): amd64\n\n\nRaspbian Stretch\n (9.x): armhf\n\n\n\n\nAvailable channels are:\n\n\n\n\nstable\n: official and supported releases\n\n\ntesting\n: future official releases, for testing purposes. Updated \u00b1 twice a month.\n\n\nunstable\n: nightly builds, to be use with caution\n\n\n\n\ncozy-couchdb\n and \ncozy-nsjail\n are temporary packages. They will be removed when official \ncouchdb\n and \nnsjail\n will be available\n\n\nYou can choose to install \ncozy-couchdb\n on the same host as \ncozy-stack\n, or use a remote CouchDB server. Cozy only needs a 2.x CouchDB (1.x not supported).\n\n\nLike CouchDB, you can choose to install your reverse proxy on the same host, or use a remote one. At this \ncozy-coclyco\n supports only local \nnginx\n. If you want to use \napache2\n or remote reverse proxy, you need to manually configure it for vhost or TLS certificate issuances.\n\n\nPrerequisites\n\n\nFirst, you need to fetch the GPG Cozy signing key:\n\n\ncurl https://apt.cozy.io/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -\ncurl https://apt.cozy.io/nightly/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -\n\n\n\n\nThen, setup your repository. Select the channel that best fit your needs:\n\n\n\n\n\u26a0\ufe0f For now, packages are only available in \ntesting\n and \nunstable\n channels. Adapt your \nsources.list\n accordingly.\n\n\n\n\nSupported repositories are:\n\n\n\n\nDebian Stretch (9.x)\n\n\ndeb https://apt.cozy.io/debian/ stretch stable\n\n\ndeb https://apt.cozy.io/debian/ stretch testing\n\n\ndeb https://apt.cozy.io/nightly/debian/ stretch unstable\n\n\n\n\n\n\nUbuntu Xenial (16.04 LTS)\n\n\ndeb https://apt.cozy.io/ubuntu/ xenial stable\n\n\ndeb https://apt.cozy.io/ubuntu/ xenial testing\n\n\ndeb https://apt.cozy.io/nightly/ubuntu/ xenial unstable\n\n\n\n\n\n\nRaspbian Stretch (9.x)\n\n\ndeb https://apt.cozy.io/raspbian/ stretch stable\n\n\ndeb https://apt.cozy.io/raspbian/ stretch testing\n\n\ndeb https://apt.cozy.io/nightly/raspbian/ stretch unstable\n\n\n\n\n\n\n\n\necho \ndeb https://apt.cozy.io/debian/ stretch stable\n \n /etc/apt/sources.list.d/cozy.list\napt update\n\n\n\n\nIf you want to use unstable/nightly builds, you have to accept another key (weaker and passwordless on our side because of unattended automated builds)\n\n\ncurl https://apt.cozy.io/nightly/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -\n\n\n\n\nSetup\n\n\nFor the rest of this document, we assume you install components one by one to allow intermediate verification\n\n\nFor a full local environment (\ncouchdb\n + \nnginx\n + \ncozy\n), just install the \ncozy\n package which can install all needed packages in one shot.\n\n\nCouchDB\n\n\napt install cozy-couchdb\n\n\n\n\nInstall CouchDB in \nstandalone\n mode\n\n\nConfigure CouchDB to listen on \n127.0.0.1\n\n\nPick an administrator password\n\n(This password is used by shell scripts, so currently avoid to use one with simple or double quotes or others shell meaningfull symbols. We advice you to choose one with only alphanumeric digits to avoid troubles.)\n\n\nAt this point, you must have a working CouchDB instance\n\n\ncurl http://localhost:5984/       \n{\ncouchdb\n:\nWelcome\n,\nversion\n:\n2.1.0\n,\nfeatures\n:[\nscheduler\n],\nvendor\n:{\nname\n:\nThe Apache Software Foundation\n}}\n\n\n\n\nCozy stack\n\n\napt install cozy-stack\n\n\n\n\nCozy need to create a CouchDB administrator and so to connect as admin to the CouchDB. Fill those mandatory parameters to allow this creation:\n\n\n\n\nAddress: by default, it\ns \nlocalhost:5984\n\n\nNode name: by default, it\ns \ncouchdb@localhost\n\n\nAdmin user: by default, it\ns \nadmin\n\n\nAdmin password: put the one you choose during CouchDB setup\n\n\nCozy user: by default, it\ns \ncozy\n\n\nCozy password: pick a password\n\n\n\n\n(Those passwords are used by shell scripts, so currently avoid to use ones with simple or double quotes or others shell meaningfull symbols. We advice you to choose ones with only alphanumeric digits to avoid troubles.)\n\n\nFor stack management (create instances, install applications\n), \nCozy need an administrator password\n. So pick a new one.\n\nWhen invoking \ncozy-stack\n (or \ncozy-coclyco\n which use it under the hood), you need to set the \nCOZY_ADMIN_PASSWORD\n environment variable with this password. You can put it on your \n.bashrc\n for simplier life if you want.\n\n\nAt this point, you must have a working Cozy stack\n\n\ncurl http://localhost:8080/version\n{\nbuild_mode\n:\nproduction\n,\nbuild_time\n:\n2017-09-28T10:26:03Z\n,\nruntime_version\n:\ngo1.8.1\n,\nversion\n:\n0.1.0\n}#\n\n\n\n\nIf you want to use konnectors, you need to initialize the NodeJS chroot\n\n\n(Currently this script only works for Debian and will be adapted for Ubuntu and Raspbian soon)\n\n\n/usr/share/cozy/konnector-create-chroot.sh\n\n\n\n\nIf you use a self-signed certificate or a not official certificate authority, you need to deploy the corresponding root certificate in \n/usr/share/cozy/chroot/etc/ssl/certs/custom.crt\n.\n\nFor example, if you use \nLet\ns Encrypt staging environment\n for testing purpose\u00a0:\n\n\nwget -q https://letsencrypt.org/certs/fakelerootx1.pem \\\n    -O /usr/share/cozy/chroot/etc/ssl/certs/custom.crt\n\n\n\n\nFinally\n\n\napt install cozy\n\n\n\n\nCozy instance setup\n\n\nDNS\n\n\nCozy relies on sub-domains for each applications you installed on your instance.\nFor an instance \ncozy.example.org\n, \napp\n.cozy.example.org\n must be available too. Currently, you need at least:\n\n\n\n\nonboarding.cozy.example.org\n\n\nsettings.cozy.example.org\n\n\ndrive.cozy.example.org\n\n\nphotos.cozy.example.org\n\n\ncollect.cozy.example.org\n\n\nstore.cozy.example.org\n\n\napp\n.cozy.example.org\n for each application you use\n\n\n\n\nFollow your usual way to create those entries on your domain zone.\nThe simpliest way to handle this is to use a wildcard entry if supported by your domain hosting.\n\n\ncozy 1h IN A x.x.x.x\n*.cozy 1h IN CNAME cozy\n\n\n\n\nACME (Let\ns Encrypt)\n\n\nLike DNS, each application will use a different sub-domain and so request a certificate which include all needed domains.\n\n\ncozy-coclyco\n use Let\ns Encrypt and it ACME protocol to prove your ownership over the domain you try to issue a certificate.\nThis protocol requires your reverse proxy to be able to serve \nhttp://\napp\n.cozy.example.org/.well-known/acme-challenge/\n requests correctly.\n\n\nThe simplest way to achieve this is to configure your reverse proxy with a generic rule to forward any \n/.well-known/acme-challenge/\n request to the corresponding \n/etc\n/ssl/private/acme-challenge/\n folder.\nFor \nnginx\n, this can be done with\n\n\n/etc/nginx/sites-available/default\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n    server_name _;\n\n    location /.well-known/acme-challenge/ {\n        alias /etc/ssl/private/acme-challenge/;\n    }\n\n    location / {\n        return 301 https://$host$request_uri;\n    }\n}\n\napt install ssl-cert\nadduser www-data ssl-cert\nsystemctl restart nginx\n\n\n\n\nCreate instances\n\n\nOnce you\nve got a stack, your DNS\u00a0and your reverse proxy correctly configured, you can create instances on your Cozy stack.\nRemember to set the \nCOZY_ADMIN_PASSWORD\n environment variable.\n\n\nexport COZY_ADMIN_PASSWORD=\nyour-admin-password\n\ncozy-coclyco create cozy.example.org me@example.org\n\n\n\n\nFor complete reference of Coclyco, refer to the documentation of \ncozy-coclyco\n.", 
            "title": "Debian"
        }, 
        {
            "location": "/install/debian/#install-cozy-on-a-debian-server", 
            "text": "A Debian repository serves packages to setup a Cozy self-hosted environment.  It provides:   cozy-couchdb :  CouchDB  database engine used by cozy  cozy-nsjail :  NSJail  isolation tool used by konnectors  cozy-stack :  Cozy core  cozy-coclyco :  CLI  to manage vhosts and certificates  cozy : metapackage installing everything to setup a self-hosted environment   This repository currently supports:   Debian Stretch  (9.x): amd64  Ubuntu Xenial  (16.04 LTS): amd64  Raspbian Stretch  (9.x): armhf   Available channels are:   stable : official and supported releases  testing : future official releases, for testing purposes. Updated \u00b1 twice a month.  unstable : nightly builds, to be use with caution   cozy-couchdb  and  cozy-nsjail  are temporary packages. They will be removed when official  couchdb  and  nsjail  will be available  You can choose to install  cozy-couchdb  on the same host as  cozy-stack , or use a remote CouchDB server. Cozy only needs a 2.x CouchDB (1.x not supported).  Like CouchDB, you can choose to install your reverse proxy on the same host, or use a remote one. At this  cozy-coclyco  supports only local  nginx . If you want to use  apache2  or remote reverse proxy, you need to manually configure it for vhost or TLS certificate issuances.", 
            "title": "Install Cozy on a Debian server"
        }, 
        {
            "location": "/install/debian/#prerequisites", 
            "text": "First, you need to fetch the GPG Cozy signing key:  curl https://apt.cozy.io/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -\ncurl https://apt.cozy.io/nightly/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -  Then, setup your repository. Select the channel that best fit your needs:   \u26a0\ufe0f For now, packages are only available in  testing  and  unstable  channels. Adapt your  sources.list  accordingly.   Supported repositories are:   Debian Stretch (9.x)  deb https://apt.cozy.io/debian/ stretch stable  deb https://apt.cozy.io/debian/ stretch testing  deb https://apt.cozy.io/nightly/debian/ stretch unstable    Ubuntu Xenial (16.04 LTS)  deb https://apt.cozy.io/ubuntu/ xenial stable  deb https://apt.cozy.io/ubuntu/ xenial testing  deb https://apt.cozy.io/nightly/ubuntu/ xenial unstable    Raspbian Stretch (9.x)  deb https://apt.cozy.io/raspbian/ stretch stable  deb https://apt.cozy.io/raspbian/ stretch testing  deb https://apt.cozy.io/nightly/raspbian/ stretch unstable     echo  deb https://apt.cozy.io/debian/ stretch stable    /etc/apt/sources.list.d/cozy.list\napt update  If you want to use unstable/nightly builds, you have to accept another key (weaker and passwordless on our side because of unattended automated builds)  curl https://apt.cozy.io/nightly/cozy.gpg | \\\n    apt-key --keyring /etc/apt/trusted.gpg.d/cozy.gpg add -", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/install/debian/#setup", 
            "text": "For the rest of this document, we assume you install components one by one to allow intermediate verification  For a full local environment ( couchdb  +  nginx  +  cozy ), just install the  cozy  package which can install all needed packages in one shot.", 
            "title": "Setup"
        }, 
        {
            "location": "/install/debian/#couchdb", 
            "text": "apt install cozy-couchdb  Install CouchDB in  standalone  mode  Configure CouchDB to listen on  127.0.0.1  Pick an administrator password \n(This password is used by shell scripts, so currently avoid to use one with simple or double quotes or others shell meaningfull symbols. We advice you to choose one with only alphanumeric digits to avoid troubles.)  At this point, you must have a working CouchDB instance  curl http://localhost:5984/       \n{ couchdb : Welcome , version : 2.1.0 , features :[ scheduler ], vendor :{ name : The Apache Software Foundation }}", 
            "title": "CouchDB"
        }, 
        {
            "location": "/install/debian/#cozy-stack", 
            "text": "apt install cozy-stack  Cozy need to create a CouchDB administrator and so to connect as admin to the CouchDB. Fill those mandatory parameters to allow this creation:   Address: by default, it s  localhost:5984  Node name: by default, it s  couchdb@localhost  Admin user: by default, it s  admin  Admin password: put the one you choose during CouchDB setup  Cozy user: by default, it s  cozy  Cozy password: pick a password   (Those passwords are used by shell scripts, so currently avoid to use ones with simple or double quotes or others shell meaningfull symbols. We advice you to choose ones with only alphanumeric digits to avoid troubles.)  For stack management (create instances, install applications ),  Cozy need an administrator password . So pick a new one. \nWhen invoking  cozy-stack  (or  cozy-coclyco  which use it under the hood), you need to set the  COZY_ADMIN_PASSWORD  environment variable with this password. You can put it on your  .bashrc  for simplier life if you want.  At this point, you must have a working Cozy stack  curl http://localhost:8080/version\n{ build_mode : production , build_time : 2017-09-28T10:26:03Z , runtime_version : go1.8.1 , version : 0.1.0 }#  If you want to use konnectors, you need to initialize the NodeJS chroot  (Currently this script only works for Debian and will be adapted for Ubuntu and Raspbian soon)  /usr/share/cozy/konnector-create-chroot.sh  If you use a self-signed certificate or a not official certificate authority, you need to deploy the corresponding root certificate in  /usr/share/cozy/chroot/etc/ssl/certs/custom.crt . \nFor example, if you use  Let s Encrypt staging environment  for testing purpose\u00a0:  wget -q https://letsencrypt.org/certs/fakelerootx1.pem \\\n    -O /usr/share/cozy/chroot/etc/ssl/certs/custom.crt", 
            "title": "Cozy stack"
        }, 
        {
            "location": "/install/debian/#finally", 
            "text": "apt install cozy", 
            "title": "Finally"
        }, 
        {
            "location": "/install/debian/#cozy-instance-setup", 
            "text": "", 
            "title": "Cozy instance setup"
        }, 
        {
            "location": "/install/debian/#dns", 
            "text": "Cozy relies on sub-domains for each applications you installed on your instance.\nFor an instance  cozy.example.org ,  app .cozy.example.org  must be available too. Currently, you need at least:   onboarding.cozy.example.org  settings.cozy.example.org  drive.cozy.example.org  photos.cozy.example.org  collect.cozy.example.org  store.cozy.example.org  app .cozy.example.org  for each application you use   Follow your usual way to create those entries on your domain zone.\nThe simpliest way to handle this is to use a wildcard entry if supported by your domain hosting.  cozy 1h IN A x.x.x.x\n*.cozy 1h IN CNAME cozy", 
            "title": "DNS"
        }, 
        {
            "location": "/install/debian/#acme-lets-encrypt", 
            "text": "Like DNS, each application will use a different sub-domain and so request a certificate which include all needed domains.  cozy-coclyco  use Let s Encrypt and it ACME protocol to prove your ownership over the domain you try to issue a certificate.\nThis protocol requires your reverse proxy to be able to serve  http:// app .cozy.example.org/.well-known/acme-challenge/  requests correctly.  The simplest way to achieve this is to configure your reverse proxy with a generic rule to forward any  /.well-known/acme-challenge/  request to the corresponding  /etc\n/ssl/private/acme-challenge/  folder.\nFor  nginx , this can be done with  /etc/nginx/sites-available/default\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n    server_name _;\n\n    location /.well-known/acme-challenge/ {\n        alias /etc/ssl/private/acme-challenge/;\n    }\n\n    location / {\n        return 301 https://$host$request_uri;\n    }\n}\n\napt install ssl-cert\nadduser www-data ssl-cert\nsystemctl restart nginx", 
            "title": "ACME (Let's Encrypt)"
        }, 
        {
            "location": "/install/debian/#create-instances", 
            "text": "Once you ve got a stack, your DNS\u00a0and your reverse proxy correctly configured, you can create instances on your Cozy stack.\nRemember to set the  COZY_ADMIN_PASSWORD  environment variable.  export COZY_ADMIN_PASSWORD= your-admin-password \ncozy-coclyco create cozy.example.org me@example.org  For complete reference of Coclyco, refer to the documentation of  cozy-coclyco .", 
            "title": "Create instances"
        }, 
        {
            "location": "/install/manual/", 
            "text": "How to install Cozy on Debian Stable\n\n\n\n\n\u26a0\ufe0f This is a work in progress. For now, there\u2019s no easy and officially supported way to install Cozy. You have to install it and all this dependencies by hand. This tutorial is intended for tech savvy people wanting to give Cozy a first try without waiting for the official documentation and images.\n\n\n\n\n\n\nFor now, this documentation don\u2019t explain how to install the technology stack required for connector, as the technology we use may evolve. So you won\u2019t be able to run the connectors.\n\n\n\n\n\n\nMost of the following commands require root privileges. You can either open a root shell or use \nsudo\n when needed;\n\n\n\n\nPre-requisites\n\n\nCozy requires a CouchDB 2 database server, a reverse proxy and an SMTP server. We\u2019ll use Nginx in this tutorial but feel free to use your reverse proxy of choice.\n\n\nYou\nll also need a domain name and know how to associate all of its subdomains to the IP address of your server.\n\n\nInstall dependencies\n\n\nOn a fresh new Debian Stretch, here are the packages that may be useful to install and manage your server:\n\n\napt-get update \n apt-get --no-install-recommends -y install \\\n            ca-certificates \\\n            curl \\\n            net-tools \\\n            nginx \\\n            sudo \\\n            vim-tiny \\\n            build-essential \\\n            pkg-config \\\n            erlang \\\n            libicu-dev \\\n            libmozjs185-dev \\\n            libcurl4-openssl-dev\n\n\n\n\nInstall CouchDB\n\n\nDownload \nthe source code on CouchDB 2\n and \ninstall it\n.\n\n\ncd /tmp\ncurl -LO https://dist.apache.org/repos/dist/release/couchdb/source/2.1.1/apache-couchdb-2.1.1.tar.gz\ntar xf apache-couchdb-2.1.1.tar.gz\ncd apache-couchdb-2.1.1\n./configure\nmake release\nadduser --system \\\n        --no-create-home \\\n        --shell /bin/bash \\\n        --group --gecos \\\n        \nCouchDB Administrator\n couchdb\n\n\n\n\nWe\u2019ll install CouchDB inside \n/home/couchdb\n:\n\n\ncp -R rel/couchdb /home/couchdb\nchown -R couchdb:couchdb /home/couchdb\nfind /home/couchdb -type d -exec chmod 0770 {} \\;\nchmod -R 0644 /home/couchdb/etc/*\nmkdir /var/log/couchdb \n chown couchdb: /var/log/couchdb\n\n\n\n\nFor now, we\u2019ll just run the database as a background job, but it is highly recommended to use some supervisor software.\n\n\nsudo -b -i -u couchdb sh -c '/home/couchdb/bin/couchdb \n /var/log/couchdb/couch.log 2\n /var/log/couchdb/couch-err.log'\n\n\n\n\nAlternatively, you can setup a service script, and use systemd to run couchdb as a service :\n\n\ncat \nEOT \n /etc/systemd/system/couchdb.service\n[Unit]\nDescription=Couchdb service\nAfter=network.target\n\n[Service]\nType=simple\nUser=couchdb\nExecStart=/home/couchdb/bin/couchdb -o /dev/stdout -e /dev/stderr\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\nEOT\n\n\n\n\nThen to start and enable (start at boot) the service :\n\n\nsystemctl  daemon-reload\nsystemctl  start couchdb.service\nsystemctl  enable couchdb.service\n\n\n\n\nLast but not least, let\u2019s create the default databases:\n\n\ncurl -X PUT http://127.0.0.1:5984/_users\ncurl -X PUT http://127.0.0.1:5984/_replicator\ncurl -X PUT http://127.0.0.1:5984/_global_changes\n\n\n\n\n\n\n\u26a0\ufe0f The default CouchDB installation has no admin user. Everybody can query the server. So, in production environment, make sure to create en admin user and update the CouchDB connexion URL inside the configuration file of Cozy.\n\n\n\n\nInstall the Cozy Stack\n\n\nThe Cozy server is just a single binary. You can fetch one of its releases from Github:\n\n\ncurl -o /usr/local/bin/cozy-stack \\\n     -L https://github.com/cozy/cozy-stack/releases/download/2017M2-alpha/cozy-stack-linux-amd64-2017M2-alpha\nchmod +x /usr/local/bin/cozy-stack\nadduser --system \\\n        --no-create-home \\\n        --shell /bin/bash \\\n        --group --gecos \\\n          \nCozy\n cozy\nmkdir /var/log/cozy\nchown cozy: /var/log/cozy\nmkdir /var/lib/cozy\nchown -R cozy: /var/lib/cozy\n\n\n\n\nYou can configure your server using a JSON or YAML file. Let\u2019s fetch the sample configuration file:\n\n\nmkdir /etc/cozy\ncurl -o /etc/cozy/cozy.yaml \\\n     https://raw.githubusercontent.com/cozy/cozy-stack/master/cozy.example.yaml\nchown -R cozy: /etc/cozy\n\n\n\n\nEdit this file to adapt it to your configuration. You should setup a directory to store the files. For example:\n\n\n  fs:\n    url: file://localhost/var/lib/cozy\n\n\n\n\nDon\u2019t forget to allow Cozy user to write inside this folder.\n\n\nCompile a recent stack\n\n\nThe released build may not contain the latest fixes. If you want an up to date version of the stack, you can compile it from the sources. This requires to install the Go compiler, fetch the sources and compile them:\n\n\napt-get --no-install-recommends -y install \\\n        ca-certificates \\\n        curl \\\n        net-tools \\\n        nginx \\\n        sudo \\\n        vim-tiny \\\n        build-essential \\\n        pkg-config \\\n        erlang \\\n        libicu-dev \\\n        libmozjs185-dev \\\n        libcurl4-openssl-dev \\\n        git\ncd /tmp\ncurl -LO https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz\ntar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz\nPATH=$PATH:/usr/local/go/bin go get -u github.com/cozy/cozy-stack\ncp /root/go/bin/cozy-stack /usr/local/bin/cozy-stack\nchmod +x /usr/local/bin/cozy-stack\n\n\n\n\nConfiguration\n\n\nNGinx\n\n\nLet\u2019s assume you want to host a server on \nmycozy.tld\n with a self-signed certificate.\n\n\nGenerate the certificate. We need a wild-card certificate, as every application inside Cozy will have it\u2019s own sub-domain:\n\n\nsudo openssl req -x509 -nodes -newkey rsa:4096 \\\n    -keyout /etc/cozy/mycozy.tld.key \\\n    -out /etc/cozy/mycozy.tld.crt \\\n    -days 365 -subj \n/CN={*.mycozy.tld}\n\n\n\n\nThen create a virtual host for your server by creating a file at \n/etc/cozy/sites-available/mycozy.tld.conf\n with \nthe following configuration template\n.\nAnd enable it by creating a symbolic link:\n\n\nsudo ln -s \n/etc/nginx/sites-available/mycozy.tld.conf\n \\\n       /etc/nginx/sites-enabled/\n\n\n\n\nYou can check that your configuration is valid by running\n\n\nsudo nginx -t -c /etc/nginx/nginx.conf\n\n\n\n\nAnd start NGinx:\n\n\nsudo service nginx start\n\n\n\n\nOr, if you use systemd:\n\n\nsudo systemctl start nginx\nsudo systemctl enable nginx # enable the nginx service at startup, if need to\n\n\n\n\nCozy\n\n\nThe Cozy server requires a main password:\n\n\nsudo /usr/local/bin/cozy-stack config passwd /etc/cozy/\n\n\n\n\nThis password will be asked every time you use the \ncozy-stack\n command line. To prevent this, you can set the \nCOZY_ADMIN_PASSWORD\n environment variable.\n\n\nDNS\n\n\nMake sure to associate \n*.mycozy.tld\n with the IP address of your server.\n\n\nFor example, add the following records to your DNS (replacing \nmycozy.tld\n with your domain of choice):\n\n\nmycozy.tld   A     your IP\n*.mycozy.tld CNAME mycozy.tld\n\n\n\n\nRunning\n\n\nFor now, we\u2019ll just run the server as a background job, but it is highly recommended to use some supervisor software.\n\n\nFirst, start the server:\n\n\nsudo -b -u cozy sh -c '/usr/local/bin/cozy-stack serve \\\n     --log-level info \\\n     --host 0.0.0.0 \n /var/log/cozy/cozy.log 2\n /var/log/cozy/cozy-err.log'\n\n\n\n\nThen, create your instance and install the applications:\n\n\ncozy-stack instances add \\\n           --host 0.0.0.0 \\\n           --apps drive,photos,collect,settings \\\n           --passphrase \nXXX\n \\\n           mycozy.tld\n\n\n\n\n--passphrase \"XXX\"\n allows to set the initial password of the instance.\n\n\nYou can add other instances by just running this commands again.\n\n\n\n\nThe url of your cozy determines the name of your instance.\nIf you choose another public port than the default public port for SSL (443), say \n1443\n, then you should reflect this when creating your cozy instance with the ${instance_domain} as \nmycozy.tld:1443\n.\n\n\n\n\nSample configuration files\n\n\nNginx\n\n\nPut this file into \n/etc/nginx/sites-available\n and enable it by creating a symlink in \n/etc/nginx/sites-enabled\n.\n\n\nIn this template, you need to replace the following placeholders:\n\n\n\n\n%PORT% with the public port nginx will listen to (default should be 443)\n\n\n%SERVER_PORT% with the private port cozy will listen to (default should be 8080)\n\n\n%DOMAIN% with your domain of choice: \nmycozy.tld\n in this example\n\n\n\n\nserver {\n    listen %PORT%;\n\n    server_name *.%DOMAIN%;\n\n    ssl_certificate /etc/cozy/%DOMAIN%.crt;\n    ssl_certificate_key /etc/cozy/%DOMAIN%.key;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers EECDH+AES;\n    ssl_prefer_server_ciphers on;\n    ssl on;\n\n    gzip_vary on;\n    client_max_body_size 1024M;\n\n    add_header Strict-Transport-Security max-age=31536000;\n\n    location / {\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_redirect http:// https://;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n    }\n\n    access_log /var/log/nginx/cozy.log;\n}\n\n\n\n\nTODO\n\n\nCozy also requires a SMTP server (or relay).", 
            "title": "Manual installation"
        }, 
        {
            "location": "/install/manual/#how-to-install-cozy-on-debian-stable", 
            "text": "\u26a0\ufe0f This is a work in progress. For now, there\u2019s no easy and officially supported way to install Cozy. You have to install it and all this dependencies by hand. This tutorial is intended for tech savvy people wanting to give Cozy a first try without waiting for the official documentation and images.    For now, this documentation don\u2019t explain how to install the technology stack required for connector, as the technology we use may evolve. So you won\u2019t be able to run the connectors.    Most of the following commands require root privileges. You can either open a root shell or use  sudo  when needed;", 
            "title": "How to install Cozy on Debian Stable"
        }, 
        {
            "location": "/install/manual/#pre-requisites", 
            "text": "Cozy requires a CouchDB 2 database server, a reverse proxy and an SMTP server. We\u2019ll use Nginx in this tutorial but feel free to use your reverse proxy of choice.  You ll also need a domain name and know how to associate all of its subdomains to the IP address of your server.", 
            "title": "Pre-requisites"
        }, 
        {
            "location": "/install/manual/#install-dependencies", 
            "text": "On a fresh new Debian Stretch, here are the packages that may be useful to install and manage your server:  apt-get update   apt-get --no-install-recommends -y install \\\n            ca-certificates \\\n            curl \\\n            net-tools \\\n            nginx \\\n            sudo \\\n            vim-tiny \\\n            build-essential \\\n            pkg-config \\\n            erlang \\\n            libicu-dev \\\n            libmozjs185-dev \\\n            libcurl4-openssl-dev", 
            "title": "Install dependencies"
        }, 
        {
            "location": "/install/manual/#install-couchdb", 
            "text": "Download  the source code on CouchDB 2  and  install it .  cd /tmp\ncurl -LO https://dist.apache.org/repos/dist/release/couchdb/source/2.1.1/apache-couchdb-2.1.1.tar.gz\ntar xf apache-couchdb-2.1.1.tar.gz\ncd apache-couchdb-2.1.1\n./configure\nmake release\nadduser --system \\\n        --no-create-home \\\n        --shell /bin/bash \\\n        --group --gecos \\\n         CouchDB Administrator  couchdb  We\u2019ll install CouchDB inside  /home/couchdb :  cp -R rel/couchdb /home/couchdb\nchown -R couchdb:couchdb /home/couchdb\nfind /home/couchdb -type d -exec chmod 0770 {} \\;\nchmod -R 0644 /home/couchdb/etc/*\nmkdir /var/log/couchdb   chown couchdb: /var/log/couchdb  For now, we\u2019ll just run the database as a background job, but it is highly recommended to use some supervisor software.  sudo -b -i -u couchdb sh -c '/home/couchdb/bin/couchdb   /var/log/couchdb/couch.log 2  /var/log/couchdb/couch-err.log'  Alternatively, you can setup a service script, and use systemd to run couchdb as a service :  cat  EOT   /etc/systemd/system/couchdb.service\n[Unit]\nDescription=Couchdb service\nAfter=network.target\n\n[Service]\nType=simple\nUser=couchdb\nExecStart=/home/couchdb/bin/couchdb -o /dev/stdout -e /dev/stderr\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\nEOT  Then to start and enable (start at boot) the service :  systemctl  daemon-reload\nsystemctl  start couchdb.service\nsystemctl  enable couchdb.service  Last but not least, let\u2019s create the default databases:  curl -X PUT http://127.0.0.1:5984/_users\ncurl -X PUT http://127.0.0.1:5984/_replicator\ncurl -X PUT http://127.0.0.1:5984/_global_changes   \u26a0\ufe0f The default CouchDB installation has no admin user. Everybody can query the server. So, in production environment, make sure to create en admin user and update the CouchDB connexion URL inside the configuration file of Cozy.", 
            "title": "Install CouchDB"
        }, 
        {
            "location": "/install/manual/#install-the-cozy-stack", 
            "text": "The Cozy server is just a single binary. You can fetch one of its releases from Github:  curl -o /usr/local/bin/cozy-stack \\\n     -L https://github.com/cozy/cozy-stack/releases/download/2017M2-alpha/cozy-stack-linux-amd64-2017M2-alpha\nchmod +x /usr/local/bin/cozy-stack\nadduser --system \\\n        --no-create-home \\\n        --shell /bin/bash \\\n        --group --gecos \\\n           Cozy  cozy\nmkdir /var/log/cozy\nchown cozy: /var/log/cozy\nmkdir /var/lib/cozy\nchown -R cozy: /var/lib/cozy  You can configure your server using a JSON or YAML file. Let\u2019s fetch the sample configuration file:  mkdir /etc/cozy\ncurl -o /etc/cozy/cozy.yaml \\\n     https://raw.githubusercontent.com/cozy/cozy-stack/master/cozy.example.yaml\nchown -R cozy: /etc/cozy  Edit this file to adapt it to your configuration. You should setup a directory to store the files. For example:    fs:\n    url: file://localhost/var/lib/cozy  Don\u2019t forget to allow Cozy user to write inside this folder.", 
            "title": "Install the Cozy Stack"
        }, 
        {
            "location": "/install/manual/#compile-a-recent-stack", 
            "text": "The released build may not contain the latest fixes. If you want an up to date version of the stack, you can compile it from the sources. This requires to install the Go compiler, fetch the sources and compile them:  apt-get --no-install-recommends -y install \\\n        ca-certificates \\\n        curl \\\n        net-tools \\\n        nginx \\\n        sudo \\\n        vim-tiny \\\n        build-essential \\\n        pkg-config \\\n        erlang \\\n        libicu-dev \\\n        libmozjs185-dev \\\n        libcurl4-openssl-dev \\\n        git\ncd /tmp\ncurl -LO https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz\ntar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz\nPATH=$PATH:/usr/local/go/bin go get -u github.com/cozy/cozy-stack\ncp /root/go/bin/cozy-stack /usr/local/bin/cozy-stack\nchmod +x /usr/local/bin/cozy-stack", 
            "title": "Compile a recent stack"
        }, 
        {
            "location": "/install/manual/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/install/manual/#nginx", 
            "text": "Let\u2019s assume you want to host a server on  mycozy.tld  with a self-signed certificate.  Generate the certificate. We need a wild-card certificate, as every application inside Cozy will have it\u2019s own sub-domain:  sudo openssl req -x509 -nodes -newkey rsa:4096 \\\n    -keyout /etc/cozy/mycozy.tld.key \\\n    -out /etc/cozy/mycozy.tld.crt \\\n    -days 365 -subj  /CN={*.mycozy.tld}  Then create a virtual host for your server by creating a file at  /etc/cozy/sites-available/mycozy.tld.conf  with  the following configuration template .\nAnd enable it by creating a symbolic link:  sudo ln -s  /etc/nginx/sites-available/mycozy.tld.conf  \\\n       /etc/nginx/sites-enabled/  You can check that your configuration is valid by running  sudo nginx -t -c /etc/nginx/nginx.conf  And start NGinx:  sudo service nginx start  Or, if you use systemd:  sudo systemctl start nginx\nsudo systemctl enable nginx # enable the nginx service at startup, if need to", 
            "title": "NGinx"
        }, 
        {
            "location": "/install/manual/#cozy", 
            "text": "The Cozy server requires a main password:  sudo /usr/local/bin/cozy-stack config passwd /etc/cozy/  This password will be asked every time you use the  cozy-stack  command line. To prevent this, you can set the  COZY_ADMIN_PASSWORD  environment variable.", 
            "title": "Cozy"
        }, 
        {
            "location": "/install/manual/#dns", 
            "text": "Make sure to associate  *.mycozy.tld  with the IP address of your server.  For example, add the following records to your DNS (replacing  mycozy.tld  with your domain of choice):  mycozy.tld   A     your IP\n*.mycozy.tld CNAME mycozy.tld", 
            "title": "DNS"
        }, 
        {
            "location": "/install/manual/#running", 
            "text": "For now, we\u2019ll just run the server as a background job, but it is highly recommended to use some supervisor software.  First, start the server:  sudo -b -u cozy sh -c '/usr/local/bin/cozy-stack serve \\\n     --log-level info \\\n     --host 0.0.0.0   /var/log/cozy/cozy.log 2  /var/log/cozy/cozy-err.log'  Then, create your instance and install the applications:  cozy-stack instances add \\\n           --host 0.0.0.0 \\\n           --apps drive,photos,collect,settings \\\n           --passphrase  XXX  \\\n           mycozy.tld  --passphrase \"XXX\"  allows to set the initial password of the instance.  You can add other instances by just running this commands again.   The url of your cozy determines the name of your instance.\nIf you choose another public port than the default public port for SSL (443), say  1443 , then you should reflect this when creating your cozy instance with the ${instance_domain} as  mycozy.tld:1443 .", 
            "title": "Running"
        }, 
        {
            "location": "/install/manual/#sample-configuration-files", 
            "text": "", 
            "title": "Sample configuration files"
        }, 
        {
            "location": "/install/manual/#nginx_1", 
            "text": "Put this file into  /etc/nginx/sites-available  and enable it by creating a symlink in  /etc/nginx/sites-enabled .  In this template, you need to replace the following placeholders:   %PORT% with the public port nginx will listen to (default should be 443)  %SERVER_PORT% with the private port cozy will listen to (default should be 8080)  %DOMAIN% with your domain of choice:  mycozy.tld  in this example   server {\n    listen %PORT%;\n\n    server_name *.%DOMAIN%;\n\n    ssl_certificate /etc/cozy/%DOMAIN%.crt;\n    ssl_certificate_key /etc/cozy/%DOMAIN%.key;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers EECDH+AES;\n    ssl_prefer_server_ciphers on;\n    ssl on;\n\n    gzip_vary on;\n    client_max_body_size 1024M;\n\n    add_header Strict-Transport-Security max-age=31536000;\n\n    location / {\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_redirect http:// https://;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n    }\n\n    access_log /var/log/nginx/cozy.log;\n}", 
            "title": "Nginx"
        }, 
        {
            "location": "/install/manual/#todo", 
            "text": "Cozy also requires a SMTP server (or relay).", 
            "title": "TODO"
        }, 
        {
            "location": "/dev/", 
            "text": "Let\ns hack some code\n\n\nTutorials\n\n\n\n\nintroduction to Cozy architecture\n\n\nhow to develop your first application\n\n\nhow to develop a connector\n\n\nhow to create a mobile application with cordova\n\n\nhow to send mail in development\n\n\n\n\nHow to\n\n\nComing soon!\n\n\nAPI References\n\n\nBrowse the full API reference inside our repositories:\n\n\nCozy Client JS Reference\n\n\n\n\ndocuments\n\n\nfiles\n\n\nauthentification\n\n\nauthentication with OAuth2\n\n\nsettings\n\n\ninter-app communication\n\n\njobs and triggers\n\n\nsharing\n\n\noffline\n\n\nCozy Bar\n\n\n\n\nCozy UI\n\n\n\n\nintroduction\n\n\nstyleguide\n\n\nreact components in storybook\n\n\n\n\nRaw Server API\n\n\n\n\n\n\nintroduction:\n\n\n\n\nAPI architecture\n\n\nconventions\n\n\nJSON-API\n\n\n\n\n\n\n\n\napplications\n: install, update, list applications\n\n\n\n\nmarketplace\n\n\npermissions\n\n\nnotifications\n\n\nsettings\n\n\nauth\n\n\ndocuments\n\n\nquery the database\n\n\nfiles\n\n\nlink files to documents\n\n\njobs\n\n\nworkers\n architecture\n and \nAPI\n\n\ninter-application communication\n\n\nsharing\n\n\nconnectors\n\n\nrealtime\n\n\n\n\nAvailable doctypes\n\n\nWe maintain an index of \nall the currently available doctypes\n. To make your own doctypes available to other applications, please send a pull request to this repository.", 
            "title": "Let's hack some code"
        }, 
        {
            "location": "/dev/#lets-hack-some-code", 
            "text": "", 
            "title": "Let's hack some code"
        }, 
        {
            "location": "/dev/#tutorials", 
            "text": "introduction to Cozy architecture  how to develop your first application  how to develop a connector  how to create a mobile application with cordova  how to send mail in development", 
            "title": "Tutorials"
        }, 
        {
            "location": "/dev/#how-to", 
            "text": "Coming soon!", 
            "title": "How to"
        }, 
        {
            "location": "/dev/#api-references", 
            "text": "Browse the full API reference inside our repositories:", 
            "title": "API References"
        }, 
        {
            "location": "/dev/#cozy-client-js-reference", 
            "text": "documents  files  authentification  authentication with OAuth2  settings  inter-app communication  jobs and triggers  sharing  offline  Cozy Bar", 
            "title": "Cozy Client JS Reference"
        }, 
        {
            "location": "/dev/#cozy-ui", 
            "text": "introduction  styleguide  react components in storybook", 
            "title": "Cozy UI"
        }, 
        {
            "location": "/dev/#raw-server-api", 
            "text": "introduction:   API architecture  conventions  JSON-API     applications : install, update, list applications   marketplace  permissions  notifications  settings  auth  documents  query the database  files  link files to documents  jobs  workers  architecture  and  API  inter-application communication  sharing  connectors  realtime", 
            "title": "Raw Server API"
        }, 
        {
            "location": "/dev/#available-doctypes", 
            "text": "We maintain an index of  all the currently available doctypes . To make your own doctypes available to other applications, please send a pull request to this repository.", 
            "title": "Available doctypes"
        }, 
        {
            "location": "/dev/intro/", 
            "text": "Introduction\n\n\nCozy is a personal server hosting applications that allow collect and manipulate all your personal data.\n\n\nThere are two kind of applications:\n\n\n\n\nweb applications\n: that\ns Single Page Applications (SPA) written in HTML and JavaScript that run inside the user\ns browser. They interact with the server through its API. This API allows to manipulate data and files and to perform miscellaneous tasks, like send emails\n\n\nconnectors\n: that\ns small application written in JavaScript, running on the server side, that import your data from remote sources.\n\n\n\n\nIn this tutorial, you\nll learn how to \nwrite a client application\n and \na connector\n.\n\n\nArchitecture\n\n\nSeveral layers can be distinguished. From inside to outside:\n\n\n\n\nthe core is a database that store all user data;\n\n\nthe database is accessible through a layer that control accesses and expose a REST API;\n\n\nWeb applications and other clients offer nice user interfaces to interact with the data.\n\n\n\n\nOne of our motto is \u00ab\u00a0Cozy is Simple, Versatile, Yours\u00a0\u00bb. This applies to our architecture:\n\n\n\n\nsimple\n and easy to understand and deploy. Cozy doesn\u2019t require to setup and manage a lot of micro-services;\n\n\nversatile\n: our server is comfortable anywhere. You can host a single instance on a small Raspberry \u03c0 at home, or a cluster of thousands instances on dedicated servers inside a datacenter;\n\n\nyours\n: the users are the owners of their data, they keep the control. They can migrate their data from one server to another, and are not dependant from a single hosting provider. As we say: \u201cyou will stay because you can leave\u201d;\n\n\n\n\n\n\nThe server\n\n\nThe server consist of a single process. We call it \nthe Cozy stack\n. It provides services through a REST API that allow to:\n\n\n\n\ncreate, update, delete documents inside the database;\n\n\nsend emails;\n\n\nlaunch jobs on the server. Connectors that import data from remote websites are some sort of jobs. Jobs can be one time tasks (sending a message) or periodic tasks. Some jobs, like the connectors, that require executing third party code on the server side, are sandboxed (we user \nnsjail\n for now).\n\n\n\u2026\n\n\n\n\nThe server also allow to access the database replication API, allowing to sync documents between the server and local databases, for example in mobile clients.\n\n\nTwo authentication methods are available:\n\n\n\n\nWeb applications running on the server get a session token when the user log in;\n\n\nOAuth2 for other applications.\n\n\n\n\nThe server is in charge of serving the Web applications users have installed from the application store.\n\n\nThe database\n\n\nCouchDB is a document database. Everything, from user data to server settings, is stored inside typed documents, identified by an unique id.\n\n\nTwo request methods are allowed: map-reduce or \nMango\n, a specific query language.\n\n\nEvery document has a \ndoctype\n, and we keep an index of the definition of every doctype.\n\n\nBinary data are stored outside the database. Depending on the server configuration, they may be stored on a file system or a dedicated object storage like \nswift\n.\n\n\nThe \ndatasystem\n layer inside the Cozy stack is in charge of controlling access rights on documents and binaries. It allows fine gained access control, on a whole doctype or on a set of documents.\n\n\nThe applications\n\n\nThe server provide services to applications:\n\n\n\n\nreal time notifications of events;\n\n\nmethods allowing applications to communicate and share data;\n\n\nmethods allowing sharing of documents between servers.\n\n\n\n\nApplication store\n\n\nAn application registry lists every available applications, and their characteristics. Each application can:\n\n\n\n\ncreate its own doctypes;\n\n\nrequest permission to access documents;\n\n\noffer services to other applications;\n\n\nregister publics routes;\n\n\ncreate jobs that will be run on server side.\n\n\n\n\nSecurity\n\n\nEach application uses its own sub-domain name, so it gets sandboxed inside the browser: other application are not able to steal it access token and access its data.\n\n\nWe use \nContent Security Policy\n to control what the application is allowed to do. For example, Web applications running inside Cozy are not allowed to send requests to other websites. This allow a strict control over applications, preventing them to leak your data.", 
            "title": "Architecture"
        }, 
        {
            "location": "/dev/intro/#introduction", 
            "text": "Cozy is a personal server hosting applications that allow collect and manipulate all your personal data.  There are two kind of applications:   web applications : that s Single Page Applications (SPA) written in HTML and JavaScript that run inside the user s browser. They interact with the server through its API. This API allows to manipulate data and files and to perform miscellaneous tasks, like send emails  connectors : that s small application written in JavaScript, running on the server side, that import your data from remote sources.   In this tutorial, you ll learn how to  write a client application  and  a connector .", 
            "title": "Introduction"
        }, 
        {
            "location": "/dev/intro/#architecture", 
            "text": "Several layers can be distinguished. From inside to outside:   the core is a database that store all user data;  the database is accessible through a layer that control accesses and expose a REST API;  Web applications and other clients offer nice user interfaces to interact with the data.   One of our motto is \u00ab\u00a0Cozy is Simple, Versatile, Yours\u00a0\u00bb. This applies to our architecture:   simple  and easy to understand and deploy. Cozy doesn\u2019t require to setup and manage a lot of micro-services;  versatile : our server is comfortable anywhere. You can host a single instance on a small Raspberry \u03c0 at home, or a cluster of thousands instances on dedicated servers inside a datacenter;  yours : the users are the owners of their data, they keep the control. They can migrate their data from one server to another, and are not dependant from a single hosting provider. As we say: \u201cyou will stay because you can leave\u201d;", 
            "title": "Architecture"
        }, 
        {
            "location": "/dev/intro/#the-server", 
            "text": "The server consist of a single process. We call it  the Cozy stack . It provides services through a REST API that allow to:   create, update, delete documents inside the database;  send emails;  launch jobs on the server. Connectors that import data from remote websites are some sort of jobs. Jobs can be one time tasks (sending a message) or periodic tasks. Some jobs, like the connectors, that require executing third party code on the server side, are sandboxed (we user  nsjail  for now).  \u2026   The server also allow to access the database replication API, allowing to sync documents between the server and local databases, for example in mobile clients.  Two authentication methods are available:   Web applications running on the server get a session token when the user log in;  OAuth2 for other applications.   The server is in charge of serving the Web applications users have installed from the application store.", 
            "title": "The server"
        }, 
        {
            "location": "/dev/intro/#the-database", 
            "text": "CouchDB is a document database. Everything, from user data to server settings, is stored inside typed documents, identified by an unique id.  Two request methods are allowed: map-reduce or  Mango , a specific query language.  Every document has a  doctype , and we keep an index of the definition of every doctype.  Binary data are stored outside the database. Depending on the server configuration, they may be stored on a file system or a dedicated object storage like  swift .  The  datasystem  layer inside the Cozy stack is in charge of controlling access rights on documents and binaries. It allows fine gained access control, on a whole doctype or on a set of documents.", 
            "title": "The database"
        }, 
        {
            "location": "/dev/intro/#the-applications", 
            "text": "The server provide services to applications:   real time notifications of events;  methods allowing applications to communicate and share data;  methods allowing sharing of documents between servers.", 
            "title": "The applications"
        }, 
        {
            "location": "/dev/intro/#application-store", 
            "text": "An application registry lists every available applications, and their characteristics. Each application can:   create its own doctypes;  request permission to access documents;  offer services to other applications;  register publics routes;  create jobs that will be run on server side.", 
            "title": "Application store"
        }, 
        {
            "location": "/dev/intro/#security", 
            "text": "Each application uses its own sub-domain name, so it gets sandboxed inside the browser: other application are not able to steal it access token and access its data.  We use  Content Security Policy  to control what the application is allowed to do. For example, Web applications running inside Cozy are not allowed to send requests to other websites. This allow a strict control over applications, preventing them to leak your data.", 
            "title": "Security"
        }, 
        {
            "location": "/dev/app/", 
            "text": "How to create your first Cozy application\n\n\nPrerequisite\n\n\nDeveloping an application for Cozy is quite easy. All you need to know is:\n\n\n\n\nhow to develop a single page application in HTML5. You can use the tools or framework of your choice, or no framework\n\n\nbasic Docker knowledges.\n\n\n\n\nThe only required tool is Docker. We have been told that installing Docker on some familial flavours of Windows may be a bit difficult. If you use Windows, please check if Docker is available on your system.\n\n\nInstall the development environment\n\n\n\n\nOn GNU/Linux, according \nto the documentation\n: \u00ab\u00a0The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. If you don\u2019t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. Be warned that the docker group grants privileges equivalent to the root user. You should have a look at \nDocker\u2019s documentation on security\n.\n\n\n\n\nEvery application running inside Cozy is a client-side HTML5 application interacting with your data through the API of the server. To develop an application, you\u2019ll require a running Cozy server.\n\n\nThe easiest way is to use the Docker image for developers we provide.\n\n\nJust install it:\n\n\ndocker pull cozy/cozy-app-dev\n\n\n\n\n(We update this image on a regular basis with the latest version of the server and our library. Don\u2019t forget to update the image by running \ndocker pull cozy/cozy-app-dev\n from time to time).\n\n\nCreate your first application\n\n\nThe minimal application consist of only two files:\n\n\n\n\nan HTML file, \nindex.html\n, with the markup and the code of your application\n\n\na manifest describing the application. It\u2019s a JSON file named \nmanifest.webapp\n with the name of the application, the permissions it requires\u2026 We\u2019ll have a deeper look to it content later. #TODO add an inner link to the manifest description.\n\n\n\n\nYour application will be able to use some shared libraries provided by the server, so you don\u2019t have to include them into your project.\n\n\nYour application requires some informations to interact with the server API, for example the URL of its entrypoint, and an auth token. This data will be dynamically injected into \nindex.html\n when it serves the page. So the \nindex.html\n file has to contain some string that will be replaced by the server. The general syntax of this variables is \n{{\u2026}}\n, so don\u2019t use this syntax for other purpose in the page, for example inside comments.\n\n\nYou can use the following variables:\n\n\n\n\n{{.Domain}}\n will be substituted by the URL of the API entrypoint\n\n\n{{.Token}}\n will be replaced by a token that authenticate your application when accessing the API\n\n\n{{.Locale}}\n: the lang f the instance\n\n\n{{.AppName}}\n: the name of the application\n\n\n{{.IconPath}}\n will be replaced by HTML code to display the \nfavicon\n\n\n{{.CozyClientJS}}\n will be replaced with HTML code to inject the Cozy client library\n\n\n{{.CozyBar}}\n will be replaced with HTML code to inject the upper menu bar.\n\n\n\n\nUse the API\n\n\nIf you added \n{{.CozyClientJS}}\n to your page, interacting with the server will be as easy as using the Cozy Client JS library. All you have to do is to initiate the library with the server parameters (the URL of the API and the auth token of your application):\n\n\n  window.cozy.client.init({cozyURL: \n\u2026\n, token: \n\u2026\n});\n\n\n\n\nYou can then interact with the server by using methods of the \nwindow.cozy.client\n properties. For example, to get current disk usage:\n\n\n  cozy.client.settings.diskUsage()\n    .then(function (usage) {console.log(\nUsage (promise)\n, usage);});\n    .catch(function(err){ console.log(\nfail\n, err); });\n\n\n\n\nThis library embeds most of the available server APIs: manipulate documents and files, manage applications and server settings\u2026 It also provides some some methods to help application keep working while being offline.\n\n\nSome server APIs may not be available right now through the library. If you want to use one of this method, you\u2019ll have to call it manually. See below. #TODO - add inner link.\n\n\nBehind the magic\n\n\nSome server APIs may not be available right now through the library. If you want to use one of this method, you\u2019ll have to call it manually. We\u2019ll describe here how to access the API without using the Cozy Cliznt JS library.\n\n\nConnecting to the API requires three things:\n\n\n\n\nits URL, injected into the page through the \n{{.Domain}}\n variable\n\n\nthe application auth token, injected into the page through the \n{{.Token}}\n variable. Each request sent to the server must include this token in the \nAuthorization\n header\n\n\nthe session cookie, created when you connect to your server. This is an \nHttpOnly cookie\n, meaning that JavaScript applications can\u2019t read it. This prevent a malicious script to stole the cookie.\n\n\n\n\nHere\u2019s a sample code that get API informations provided by the server and query the API:\n\n\n    \ndiv data-cozy-token=\n{{.Token}}\n data-cozy-domain=\n{{.Domain}}\n /\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', () =\n {\n  \nuse strict\n;\n  const app = document.querySelector('[data-cozy-token]');\n  fetch(`//${app.dataset.cozyDomain}/apps`,\n  {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${app.dataset.cozyToken}` // Here we use the auth token\n    },\n    credentials: 'include' // don\u2019t forget to include the session cookie\n  })\n  .then(function (response) {\n    if (response.ok) {\n      response.json().then((result) =\n {\n        console.log(result);\n      });\n    } else {\n      throw new Error('Network response was not ok.');\n    }\n  })\n  .catch(function (error) {\n    console.log('There has been a problem with your fetch operation: ' + error.message);\n  });\n});\n\n\n\n\nThe manifest\n\n\nEach application must have a \u201cmanifest\u201d. It\u2019s a JSON file named \nmanifest.webapp\n stored at the root of the application directory. It describes the application, the type of documents it uses, the permissions it require\u2026\n\n\nHere\u2019s a sample manifest:\n\n\n{\n  \nname\n: \nMy Awesome application\n,\n  \npermissions\n: {\n    \napps\n: {\n      \ntype\n: \nio.cozy.apps\n\n    },\n    \npermissions\n: {\n      \ntype\n: \nio.cozy.permissions\n\n    },\n    \nsettings\n: {\n      \ntype\n: \nio.cozy.settings\n\n    },\n    \nsample\n: {\n      \ntype\n: \nio.cozy.dev.sample\n,\n      \nverbs\n: [\nGET\n, \nPOST\n, \nPUT\n, \nPATCH\n, \nDELETE\n]\n    },\n    \njobs\n: {\n      \ntype\n: \nio.cozy.jobs\n\n    }\n  },\n  \nroutes\n: {\n    \n/\n: {\n      \nfolder\n: \n/\n,\n      \nindex\n: \nindex.html\n,\n      \npublic\n: false\n    },\n    \n/public\n: {\n      \nfolder\n: \n/public\n,\n      \nindex\n: \nindex.html\n,\n      \npublic\n: true\n    }\n  }\n}\n\n\n\n\nPermissions\n\n\nApplications require permissions to use most of the APIs. Permissions can be described inside the manifest, so the server can ask the user to grant them during installation. Applications can also request permissions at run time.\n\n\nA permission must at type contain a target, the type of objects the application want to interact with. Can be a document type, or an action on the server. By default, all grant on this object are granted, but we can also request fine grained permissions, for example limiting to read access. We can also limit the scope to a subset of the documents.\n\n\nIn the manifest, each permission is an object, with a random name and some properties:\n\n\n\n\ntype\n: \nmandatory\n the document type or action name\n\n\ndescription\n: a text that will be displayed to the user to explain why the application require this permission\n\n\nverbs\n: an array of HTTP verbs. For example, to limit permissions to read access, use \n[\"GET\"]\n\n\nselector\n: a document attribute to limit access to a subset of documents\n\n\nvalues\n: array of allowed values for this attribute.\n\n\n\n\nAn application can request a token that grant access to a subset of its own permissions. For example if the application has full access to the files, it can obtain a token that give only read access on a file. Thus, the application can make some documents publicly available. The public page of the application will use this token as authentication token when accessing the API.\n\n\nSamples\n\n\nApplication require full access to files:\n\n\n{\n  \npermissions\n: {\n    \nfiles\n: {\n      \ndescription\n: \n\u2026\n,\n      \ntype\n: \nio.cozy.files\n\n    },\n  }\n}\n\n\n\n\nApplication want to be able to read the contact informations of \ncozy@cozycloud.cc\n\n\n{\n  \npermissions\n: {\n    \ncontact\n: {\n      \ntype\n: \nio.cozy.contacts\n,\n      \nverbs\n: [\nGET\n],\n      \nselector\n: \nemail\n,\n      \nvalues\n: [\ncozy@cozycloud.cc\n]\n    }\n  }\n}\n\n\n\n\nRouting\n\n\nThe application must declare all of its URLs (routes) inside the manifest. A route is an object associating an URL to an HTML file. Each route has the following properties:\n\n\n\n\nfolder\n: the base folder of the route\n\n\nindex\n: the name of the file inside this folder\n\n\npublic\n: a boolean specifying whether the route is public or private (default).\n\n\n\n\nSample:\n\n\nroutes\n: {\n  \n/admin\n: {\n    \nfolder\n: \n/\n,\n    \nindex\n: \nadmin.html\n,\n    \npublic\n: false\n  },\n  \n/public\n: {\n    \nfolder\n: \n/public\n,\n    \nindex\n: \nindex.html\n,\n    \npublic\n: true\n  },\n  \n/assets\n: {\n    \nfolder\n: \n/assets\n,\n    \npublic\n: true\n  }\n}\n\n\n\n\ncozy-client-js\n\n\nThis library embeds most of the available server APIs: manipulate documents and files, manage applications and server settings\u2026 It also provides some some methods to help application keep working while being offline.\n\n\nThe library expose a client API under the \nwindow.cozy.client\n namespace. Before using it, you have to initiate the library with the server parameters (the URL of the API and the auth token of your application):\n\n\n  window.cozy.client.init({cozyURL: \n\u2026\n, token: \n\u2026\n});\n\n\n\n\nThe library supports two programming paradigms: callback and Promises, so you can use your favorite one. If you prefer using callbacks rather than Promises, just add \ndisablePromises\n to the options when initializing the library:\n\n\n  window.cozy.client.init({cozyURL: \n\u2026\n, token: \n\u2026\n, disablePromises: true});\n  window.client.settings.diskUsage(function (err, res) {\n    (\u2026)\n  });\n\n\n\n\nRaw API documentation\n\n\nIn this tutorial, we\u2019ll only see a few samples of how to use the library. For a complete description of all available methods, please refer to its own documentation:\n\n\n\n\ndocuments\n\n\nfiles\n\n\nauthentification\n\n\nauthentication with OAuth2\n\n\nsettings\n\n\ninter-app communication\n\n\njobs and triggers\n\n\nsharing\n\n\noffline\n\n\nCozy Bar\n\n\n\n\nManipulating documents\n\n\nInside cozy data system, all documents are typed. To prevent applications to create document types with the same name but different description, the naming of the doctypes use \nthe Java specification\n. Every document type name must be prefixed by the reverted domain name of its creator. If you don\u2019t own a domain name, you can also use your email address. For example, doctypes created by Cozy are prefixed by \nio.cozy\n or \nio.cozy.labs\n. If you don\u2019t own a domain name, and your email address is \nfoo@bar.cloud\n, prefix your doctype names with \ncloud.bar.foo\n.\n\n\nWe maintain an index of \nall the currently available doctypes\n. To make your own doctypes available to other applications, please send a pull request to this repository.\n\n\nBefore manipulating documents, you have to request permission to access their doctype, either in the manifest or dynamically.\n\n\nEvery method allowing to handle document are available under the \ncozy.client.data\n namespace. For example:\n\n\n\n\ncozy.client.data.create(doctype, attributes)\n, \ncozy.client.data.update(doctype, doc, newdoc)\n \ncozy.client.data.delete(doctype, doc)\n to create, update and delete documents\n\n\ncozy.client.data.updateAttributes(doctype, id, changes)\n to only update some attributes of a document\n\n\ncozy.client.data.find(doctype, id)\n return a document using its ident\n\n\ncozy.client.data.changesFeed(doctype, options)\n get the latests updates of documents of a doctype\n\n\nyou can attach files to a document using \ncozy.client.data.addReferencedFiles(doc, fileIds)\n and list attachments with \ncozy.client.data.listReferencedFiles(doc)\n\n\n\n\nQuerying\n\n\nTo search documents inside the database, you first need to create an index on some attributes of the documents, then perform a query on this index. The library offers the following methods:\n\n\n\n\ncozy.client.data.defineIndex(doctype, fields)\n to create the index\n\n\ncozy.client.data.query(indexReference, query)\n to query an index. The query parameter uses the syntax of the \nMango API\n from CouchDB 2.\n\n\n\n\nFor example, to search contacts by their email address, you could use:\n\n\ncozy.client.data.defineIndex(\nio.cozy.contacts\n, [\nemail\n])\n.then((index) =\n {\n  return cozy.data.query(index, {\nselector\n: {email: \ncozy@cozycloud.cc\n}})\n})\n.then( (result) =\n {\n  console.log(result[0].name);\n});\n\n\n\n\nManipulating files\n\n\nThe metadata of the files are stored inside the server database, allowing to perform advanced queries, and the files themselves on a virtual file system.\n\n\nThe library offer a lot of methods under \ncozy.client.files\n namespace to manipulate files. Most of the methods allows to manipulate a file or folder either by its id or by its full path. Here are the most commons ones, but a lot of other methods are available in the \nraw API documentation\n:\n\n\n\n\ncreate()\n and \nupdateById()\n to create and update a file\n\n\ncreateDirectory()\n to create a folder\n\n\nupdateAttributesById()\n et \nupdateAttributesByPath()\n allow to update some metadata\n\n\nuse \ndestroyById\n to remove a file\n\n\na virtual trash is available. You can put files into the trash (\ntrashById()\n) and restore them (\nrestoreById()\n). You can also list the content of the trash (\nlistTrash()\n) and purge all trashed files (\nclearTrash()\n)\n\n\nstatById(id)\n et \nstatByPath(path)\n return the metadata and, or folders, their content\n\n\n\n\nFolders\n\n\nWhen using \nstatById()\n or \nstatByPath()\n to get metadata of of folder, you can than call \nrelations()\n on the resulting object to access their content. For example, to list content of the root folder, use:\n\n\ncozy.client.files.statByPath(\n/\n)\n.then((dir) =\n {\n  console.log(dir.relations(\ncontents\n));\n})\n\n\n\n\nSome special folder have a pre-defined id that will never change:\n\n\n\n\nio.cozy.files.root-dir\n is the root of the filesystem\n\n\nio.cozy.files.trash-dir\n is the trash.\n\n\n\n\nThe Cozy Bar\n\n\nThe \nCozy Bar\n is a component that display the Cozy menu on the top of your application and allow inter-apps features like content sharing.\n\n\nYour application interacts with this component through \ncozy-bar.js\n, a library injected into your pages by the server when you add \n{{.CozyBar}}\n in the header. It exposes an API behind the window.cozy.bar namespace.\n\n\nBefore using it, you have to initialize the library: \nwindow.cozy.bar.init({appName: \"Mon application\"})\n.\n\n\nStyling\n\n\nIf you plan to build a webapp to run on Cozy, you\u2019ll probably want to use a simple and elegant solution to build your interfaces without the mess of dealing with complex markup and CSS. Then \nCozy UI\n is here for you!\n\n\nIt relies on Stylus as preprocessor. You can add it as a library in your project to use it out-of-the-box.\n\n\nStart the development server\n\n\nNow it\u2019s time to start the development server, to test our application.\n\n\n(remember what we previously said about the permissions required to run Docker: if your user doesn\u2019t belong to the docker group, you\u2019ll have to use \nsudo\n to run each of this commands.)\n\n\nTo run your application inside the development server, just run the following command from the folder where your \nindex.html\n and \nmanifest.webapp\n files leave:\n\n\ndocker run --rm -it -p 8080:8080 -p 5984:5984 -p 8025:8025 -v $(pwd):/data/cozy-app --name cozydev cozy/cozy-app-dev\n\n\n\n\nLet\u2019s have a quick look at this command, so you can adapt it to your needs:\n\n\n\n\n--rm\n will delete the server when you stop it. This prevent Docker from keeping a lot of unused stopped images\n\n\n-it\n allow to attach an interactive terminal, so you\u2019ll be able to use the command line inside the server\n\n\n-p 8080:8080\n: the server listens on port 8080 on the virtual machine. We forward this port to the same port on your local machine. To use another local port, for example 9090, use \n-p 9090:8080\n\n\n-p 5984:5984\n: this is just a convenient way to access the CouchDB database running inside the server. Point your browser to \nhttp://cozy.tools:5984/_utils/\n to access its administrative interface\n\n\n-p 8025:8025\n\u00a0: Cozy requires a mail server. In the development image, we don\u2019t use a real email server, but a software that can display the sent messages. Just point your browser to \nhttp://cozy.tools:8025/\n to display the messages sent by the server\n\n\n-v $(pwd):/data/cozy-app\n this mount the current folder, where your application leaves, inside the server. This is what make the application available on the server\n\n\n--name cozydev\n name the running virtual machine \ncozydev\n, so you can easily refer to it from other Docker commands. For example, if you want to connect to a shell inside the server, you can use \ndocker exec -ti /bin/bash\n\n\n\n\nWith this syntax, there is no data persistance: all your test data will be lost every time you stop the server. This is a good way to prevent side effects and start on a clean base, with an empty database.\n\n\nHowever, if you want to persist data, you have to mount two folders from the virtual server to local folders: \n/usr/local/couchdb/data\n (database) and \n/data/cozy-storage\n (the virtual filesystem). This can be achieved by adding to the command line \n-v ~/cozy/data/db:/usr/local/couchdb/data -v ~/cozy/data/storage:/data/cozy-storage\n which will store the server\u2019s data into \n~/cozy/data\n.\n\n\nOnce the server started, go to \nhttp://app.cozy.tools:8080/#\n, connect to the server with the default password \ncozy\n and you should be able to start testing your application.\n\n\nYou can also access the following URLs:\n\n\n\n\nhttp://cozy.tools:5984/_utils\n to get the database administrative panel\n\n\nhttp://cozy.tools:8025/\n to display the emails sent by the server.\n\n\n\n\nTest multiple applications\n\n\nYou can install more than one application into the development server, for example to test communication between applications. In order to achieve this, you have to mount the folder where your application leaves into subfolders of \n/data/cozy-apps\n. For example, if the code of Cozy Drive and Cozy Photos is on your local filesystem in \n~/cozy/drive\n and \n~/cozy/photos\n, start the development server with:\n\n\ndocker run --rm -it -p 8080:8080 -p 5984:5984 -p 8025:8025 -v \n~/cozy/drive\n:/data/cozy-app/drive\n -v \n~/cozy/photos:/data-cozy-app/photos\n --name=cozydev cozy/cozy-app-dev\n\n\n\n\nYou\u2019ll access the applications by connecting to \nhttp://drive.cozy.tools:8080/\n and \nhttp://photos.cozy.tools:8080\n.\n\n\nTODO\n\n\nThis development server use the domain names \n*.cozy.tools\n. We have parameterized this domain to always redirect to \n127.0.0.1\n, your local computer address.\n\n\nThe \nsample\n branch of this documentation repository contains a minimalist template with the needed files to create an app. You can get them with the following command:\n\n\ngit clone -b sample https://github.com/cozy/cozy-docdev-v3.git myapp\ncd myapp", 
            "title": "Create your first app"
        }, 
        {
            "location": "/dev/app/#how-to-create-your-first-cozy-application", 
            "text": "", 
            "title": "How to create your first Cozy application"
        }, 
        {
            "location": "/dev/app/#prerequisite", 
            "text": "Developing an application for Cozy is quite easy. All you need to know is:   how to develop a single page application in HTML5. You can use the tools or framework of your choice, or no framework  basic Docker knowledges.   The only required tool is Docker. We have been told that installing Docker on some familial flavours of Windows may be a bit difficult. If you use Windows, please check if Docker is available on your system.", 
            "title": "Prerequisite"
        }, 
        {
            "location": "/dev/app/#install-the-development-environment", 
            "text": "On GNU/Linux, according  to the documentation : \u00ab\u00a0The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. If you don\u2019t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. Be warned that the docker group grants privileges equivalent to the root user. You should have a look at  Docker\u2019s documentation on security .   Every application running inside Cozy is a client-side HTML5 application interacting with your data through the API of the server. To develop an application, you\u2019ll require a running Cozy server.  The easiest way is to use the Docker image for developers we provide.  Just install it:  docker pull cozy/cozy-app-dev  (We update this image on a regular basis with the latest version of the server and our library. Don\u2019t forget to update the image by running  docker pull cozy/cozy-app-dev  from time to time).", 
            "title": "Install the development environment"
        }, 
        {
            "location": "/dev/app/#create-your-first-application", 
            "text": "The minimal application consist of only two files:   an HTML file,  index.html , with the markup and the code of your application  a manifest describing the application. It\u2019s a JSON file named  manifest.webapp  with the name of the application, the permissions it requires\u2026 We\u2019ll have a deeper look to it content later. #TODO add an inner link to the manifest description.   Your application will be able to use some shared libraries provided by the server, so you don\u2019t have to include them into your project.  Your application requires some informations to interact with the server API, for example the URL of its entrypoint, and an auth token. This data will be dynamically injected into  index.html  when it serves the page. So the  index.html  file has to contain some string that will be replaced by the server. The general syntax of this variables is  {{\u2026}} , so don\u2019t use this syntax for other purpose in the page, for example inside comments.  You can use the following variables:   {{.Domain}}  will be substituted by the URL of the API entrypoint  {{.Token}}  will be replaced by a token that authenticate your application when accessing the API  {{.Locale}} : the lang f the instance  {{.AppName}} : the name of the application  {{.IconPath}}  will be replaced by HTML code to display the  favicon  {{.CozyClientJS}}  will be replaced with HTML code to inject the Cozy client library  {{.CozyBar}}  will be replaced with HTML code to inject the upper menu bar.", 
            "title": "Create your first application"
        }, 
        {
            "location": "/dev/app/#use-the-api", 
            "text": "If you added  {{.CozyClientJS}}  to your page, interacting with the server will be as easy as using the Cozy Client JS library. All you have to do is to initiate the library with the server parameters (the URL of the API and the auth token of your application):    window.cozy.client.init({cozyURL:  \u2026 , token:  \u2026 });  You can then interact with the server by using methods of the  window.cozy.client  properties. For example, to get current disk usage:    cozy.client.settings.diskUsage()\n    .then(function (usage) {console.log( Usage (promise) , usage);});\n    .catch(function(err){ console.log( fail , err); });  This library embeds most of the available server APIs: manipulate documents and files, manage applications and server settings\u2026 It also provides some some methods to help application keep working while being offline.  Some server APIs may not be available right now through the library. If you want to use one of this method, you\u2019ll have to call it manually. See below. #TODO - add inner link.", 
            "title": "Use the API"
        }, 
        {
            "location": "/dev/app/#behind-the-magic", 
            "text": "Some server APIs may not be available right now through the library. If you want to use one of this method, you\u2019ll have to call it manually. We\u2019ll describe here how to access the API without using the Cozy Cliznt JS library.  Connecting to the API requires three things:   its URL, injected into the page through the  {{.Domain}}  variable  the application auth token, injected into the page through the  {{.Token}}  variable. Each request sent to the server must include this token in the  Authorization  header  the session cookie, created when you connect to your server. This is an  HttpOnly cookie , meaning that JavaScript applications can\u2019t read it. This prevent a malicious script to stole the cookie.   Here\u2019s a sample code that get API informations provided by the server and query the API:       div data-cozy-token= {{.Token}}  data-cozy-domain= {{.Domain}}  /  document.addEventListener('DOMContentLoaded', () =  {\n   use strict ;\n  const app = document.querySelector('[data-cozy-token]');\n  fetch(`//${app.dataset.cozyDomain}/apps`,\n  {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${app.dataset.cozyToken}` // Here we use the auth token\n    },\n    credentials: 'include' // don\u2019t forget to include the session cookie\n  })\n  .then(function (response) {\n    if (response.ok) {\n      response.json().then((result) =  {\n        console.log(result);\n      });\n    } else {\n      throw new Error('Network response was not ok.');\n    }\n  })\n  .catch(function (error) {\n    console.log('There has been a problem with your fetch operation: ' + error.message);\n  });\n});", 
            "title": "Behind the magic"
        }, 
        {
            "location": "/dev/app/#the-manifest", 
            "text": "Each application must have a \u201cmanifest\u201d. It\u2019s a JSON file named  manifest.webapp  stored at the root of the application directory. It describes the application, the type of documents it uses, the permissions it require\u2026  Here\u2019s a sample manifest:  {\n   name :  My Awesome application ,\n   permissions : {\n     apps : {\n       type :  io.cozy.apps \n    },\n     permissions : {\n       type :  io.cozy.permissions \n    },\n     settings : {\n       type :  io.cozy.settings \n    },\n     sample : {\n       type :  io.cozy.dev.sample ,\n       verbs : [ GET ,  POST ,  PUT ,  PATCH ,  DELETE ]\n    },\n     jobs : {\n       type :  io.cozy.jobs \n    }\n  },\n   routes : {\n     / : {\n       folder :  / ,\n       index :  index.html ,\n       public : false\n    },\n     /public : {\n       folder :  /public ,\n       index :  index.html ,\n       public : true\n    }\n  }\n}", 
            "title": "The manifest"
        }, 
        {
            "location": "/dev/app/#permissions", 
            "text": "Applications require permissions to use most of the APIs. Permissions can be described inside the manifest, so the server can ask the user to grant them during installation. Applications can also request permissions at run time.  A permission must at type contain a target, the type of objects the application want to interact with. Can be a document type, or an action on the server. By default, all grant on this object are granted, but we can also request fine grained permissions, for example limiting to read access. We can also limit the scope to a subset of the documents.  In the manifest, each permission is an object, with a random name and some properties:   type :  mandatory  the document type or action name  description : a text that will be displayed to the user to explain why the application require this permission  verbs : an array of HTTP verbs. For example, to limit permissions to read access, use  [\"GET\"]  selector : a document attribute to limit access to a subset of documents  values : array of allowed values for this attribute.   An application can request a token that grant access to a subset of its own permissions. For example if the application has full access to the files, it can obtain a token that give only read access on a file. Thus, the application can make some documents publicly available. The public page of the application will use this token as authentication token when accessing the API.", 
            "title": "Permissions"
        }, 
        {
            "location": "/dev/app/#samples", 
            "text": "Application require full access to files:  {\n   permissions : {\n     files : {\n       description :  \u2026 ,\n       type :  io.cozy.files \n    },\n  }\n}  Application want to be able to read the contact informations of  cozy@cozycloud.cc  {\n   permissions : {\n     contact : {\n       type :  io.cozy.contacts ,\n       verbs : [ GET ],\n       selector :  email ,\n       values : [ cozy@cozycloud.cc ]\n    }\n  }\n}", 
            "title": "Samples"
        }, 
        {
            "location": "/dev/app/#routing", 
            "text": "The application must declare all of its URLs (routes) inside the manifest. A route is an object associating an URL to an HTML file. Each route has the following properties:   folder : the base folder of the route  index : the name of the file inside this folder  public : a boolean specifying whether the route is public or private (default).   Sample:  routes : {\n   /admin : {\n     folder :  / ,\n     index :  admin.html ,\n     public : false\n  },\n   /public : {\n     folder :  /public ,\n     index :  index.html ,\n     public : true\n  },\n   /assets : {\n     folder :  /assets ,\n     public : true\n  }\n}", 
            "title": "Routing"
        }, 
        {
            "location": "/dev/app/#cozy-client-js", 
            "text": "This library embeds most of the available server APIs: manipulate documents and files, manage applications and server settings\u2026 It also provides some some methods to help application keep working while being offline.  The library expose a client API under the  window.cozy.client  namespace. Before using it, you have to initiate the library with the server parameters (the URL of the API and the auth token of your application):    window.cozy.client.init({cozyURL:  \u2026 , token:  \u2026 });  The library supports two programming paradigms: callback and Promises, so you can use your favorite one. If you prefer using callbacks rather than Promises, just add  disablePromises  to the options when initializing the library:    window.cozy.client.init({cozyURL:  \u2026 , token:  \u2026 , disablePromises: true});\n  window.client.settings.diskUsage(function (err, res) {\n    (\u2026)\n  });", 
            "title": "cozy-client-js"
        }, 
        {
            "location": "/dev/app/#raw-api-documentation", 
            "text": "In this tutorial, we\u2019ll only see a few samples of how to use the library. For a complete description of all available methods, please refer to its own documentation:   documents  files  authentification  authentication with OAuth2  settings  inter-app communication  jobs and triggers  sharing  offline  Cozy Bar", 
            "title": "Raw API documentation"
        }, 
        {
            "location": "/dev/app/#manipulating-documents", 
            "text": "Inside cozy data system, all documents are typed. To prevent applications to create document types with the same name but different description, the naming of the doctypes use  the Java specification . Every document type name must be prefixed by the reverted domain name of its creator. If you don\u2019t own a domain name, you can also use your email address. For example, doctypes created by Cozy are prefixed by  io.cozy  or  io.cozy.labs . If you don\u2019t own a domain name, and your email address is  foo@bar.cloud , prefix your doctype names with  cloud.bar.foo .  We maintain an index of  all the currently available doctypes . To make your own doctypes available to other applications, please send a pull request to this repository.  Before manipulating documents, you have to request permission to access their doctype, either in the manifest or dynamically.  Every method allowing to handle document are available under the  cozy.client.data  namespace. For example:   cozy.client.data.create(doctype, attributes) ,  cozy.client.data.update(doctype, doc, newdoc)   cozy.client.data.delete(doctype, doc)  to create, update and delete documents  cozy.client.data.updateAttributes(doctype, id, changes)  to only update some attributes of a document  cozy.client.data.find(doctype, id)  return a document using its ident  cozy.client.data.changesFeed(doctype, options)  get the latests updates of documents of a doctype  you can attach files to a document using  cozy.client.data.addReferencedFiles(doc, fileIds)  and list attachments with  cozy.client.data.listReferencedFiles(doc)", 
            "title": "Manipulating documents"
        }, 
        {
            "location": "/dev/app/#querying", 
            "text": "To search documents inside the database, you first need to create an index on some attributes of the documents, then perform a query on this index. The library offers the following methods:   cozy.client.data.defineIndex(doctype, fields)  to create the index  cozy.client.data.query(indexReference, query)  to query an index. The query parameter uses the syntax of the  Mango API  from CouchDB 2.   For example, to search contacts by their email address, you could use:  cozy.client.data.defineIndex( io.cozy.contacts , [ email ])\n.then((index) =  {\n  return cozy.data.query(index, { selector : {email:  cozy@cozycloud.cc }})\n})\n.then( (result) =  {\n  console.log(result[0].name);\n});", 
            "title": "Querying"
        }, 
        {
            "location": "/dev/app/#manipulating-files", 
            "text": "The metadata of the files are stored inside the server database, allowing to perform advanced queries, and the files themselves on a virtual file system.  The library offer a lot of methods under  cozy.client.files  namespace to manipulate files. Most of the methods allows to manipulate a file or folder either by its id or by its full path. Here are the most commons ones, but a lot of other methods are available in the  raw API documentation :   create()  and  updateById()  to create and update a file  createDirectory()  to create a folder  updateAttributesById()  et  updateAttributesByPath()  allow to update some metadata  use  destroyById  to remove a file  a virtual trash is available. You can put files into the trash ( trashById() ) and restore them ( restoreById() ). You can also list the content of the trash ( listTrash() ) and purge all trashed files ( clearTrash() )  statById(id)  et  statByPath(path)  return the metadata and, or folders, their content", 
            "title": "Manipulating files"
        }, 
        {
            "location": "/dev/app/#folders", 
            "text": "When using  statById()  or  statByPath()  to get metadata of of folder, you can than call  relations()  on the resulting object to access their content. For example, to list content of the root folder, use:  cozy.client.files.statByPath( / )\n.then((dir) =  {\n  console.log(dir.relations( contents ));\n})  Some special folder have a pre-defined id that will never change:   io.cozy.files.root-dir  is the root of the filesystem  io.cozy.files.trash-dir  is the trash.", 
            "title": "Folders"
        }, 
        {
            "location": "/dev/app/#the-cozy-bar", 
            "text": "The  Cozy Bar  is a component that display the Cozy menu on the top of your application and allow inter-apps features like content sharing.  Your application interacts with this component through  cozy-bar.js , a library injected into your pages by the server when you add  {{.CozyBar}}  in the header. It exposes an API behind the window.cozy.bar namespace.  Before using it, you have to initialize the library:  window.cozy.bar.init({appName: \"Mon application\"}) .", 
            "title": "The Cozy Bar"
        }, 
        {
            "location": "/dev/app/#styling", 
            "text": "If you plan to build a webapp to run on Cozy, you\u2019ll probably want to use a simple and elegant solution to build your interfaces without the mess of dealing with complex markup and CSS. Then  Cozy UI  is here for you!  It relies on Stylus as preprocessor. You can add it as a library in your project to use it out-of-the-box.", 
            "title": "Styling"
        }, 
        {
            "location": "/dev/app/#start-the-development-server", 
            "text": "Now it\u2019s time to start the development server, to test our application.  (remember what we previously said about the permissions required to run Docker: if your user doesn\u2019t belong to the docker group, you\u2019ll have to use  sudo  to run each of this commands.)  To run your application inside the development server, just run the following command from the folder where your  index.html  and  manifest.webapp  files leave:  docker run --rm -it -p 8080:8080 -p 5984:5984 -p 8025:8025 -v $(pwd):/data/cozy-app --name cozydev cozy/cozy-app-dev  Let\u2019s have a quick look at this command, so you can adapt it to your needs:   --rm  will delete the server when you stop it. This prevent Docker from keeping a lot of unused stopped images  -it  allow to attach an interactive terminal, so you\u2019ll be able to use the command line inside the server  -p 8080:8080 : the server listens on port 8080 on the virtual machine. We forward this port to the same port on your local machine. To use another local port, for example 9090, use  -p 9090:8080  -p 5984:5984 : this is just a convenient way to access the CouchDB database running inside the server. Point your browser to  http://cozy.tools:5984/_utils/  to access its administrative interface  -p 8025:8025 \u00a0: Cozy requires a mail server. In the development image, we don\u2019t use a real email server, but a software that can display the sent messages. Just point your browser to  http://cozy.tools:8025/  to display the messages sent by the server  -v $(pwd):/data/cozy-app  this mount the current folder, where your application leaves, inside the server. This is what make the application available on the server  --name cozydev  name the running virtual machine  cozydev , so you can easily refer to it from other Docker commands. For example, if you want to connect to a shell inside the server, you can use  docker exec -ti /bin/bash   With this syntax, there is no data persistance: all your test data will be lost every time you stop the server. This is a good way to prevent side effects and start on a clean base, with an empty database.  However, if you want to persist data, you have to mount two folders from the virtual server to local folders:  /usr/local/couchdb/data  (database) and  /data/cozy-storage  (the virtual filesystem). This can be achieved by adding to the command line  -v ~/cozy/data/db:/usr/local/couchdb/data -v ~/cozy/data/storage:/data/cozy-storage  which will store the server\u2019s data into  ~/cozy/data .  Once the server started, go to  http://app.cozy.tools:8080/# , connect to the server with the default password  cozy  and you should be able to start testing your application.  You can also access the following URLs:   http://cozy.tools:5984/_utils  to get the database administrative panel  http://cozy.tools:8025/  to display the emails sent by the server.", 
            "title": "Start the development server"
        }, 
        {
            "location": "/dev/app/#test-multiple-applications", 
            "text": "You can install more than one application into the development server, for example to test communication between applications. In order to achieve this, you have to mount the folder where your application leaves into subfolders of  /data/cozy-apps . For example, if the code of Cozy Drive and Cozy Photos is on your local filesystem in  ~/cozy/drive  and  ~/cozy/photos , start the development server with:  docker run --rm -it -p 8080:8080 -p 5984:5984 -p 8025:8025 -v  ~/cozy/drive :/data/cozy-app/drive  -v  ~/cozy/photos:/data-cozy-app/photos  --name=cozydev cozy/cozy-app-dev  You\u2019ll access the applications by connecting to  http://drive.cozy.tools:8080/  and  http://photos.cozy.tools:8080 .", 
            "title": "Test multiple applications"
        }, 
        {
            "location": "/dev/app/#todo", 
            "text": "This development server use the domain names  *.cozy.tools . We have parameterized this domain to always redirect to  127.0.0.1 , your local computer address.  The  sample  branch of this documentation repository contains a minimalist template with the needed files to create an app. You can get them with the following command:  git clone -b sample https://github.com/cozy/cozy-docdev-v3.git myapp\ncd myapp", 
            "title": "TODO"
        }, 
        {
            "location": "/dev/konnector/", 
            "text": "How to write a connector\n\n\nIntroduction\n\n\nA connector is a simple script which imports data from other web services and put it in your cozy.\nEach connector is an independant application, managed by the \nCozy Collect\n\napplication.\n\n\nTo protect your data, each connector runs inside a container in order to sandbox all their\ninteractions with your data.\n\n\nHow does it work ?\n\n\nA connector is a NodeJS script. The target node version used to run your connector is the\n\ncurrent LTS version\n (8 at the moment).\n\n\nLike client side apps, connectors communicate with the \nCozy Stack\n\nusing its API, and get an auth token every time they start. They need to register with a manifest,\nand ask permissions to the user.\n\n\nTo ease the development of a connector, a npm package, named \ncozy-konnector-libs\n\nprovides some shared libraries which are adapted to be used for a connector :\n\n\n\n\ncheerio\n to easily request html pages like jQuery\n\n\nrequest-promise\n: \nrequest\n wrapped in promises\n\n\nrequest-debug\n which displays all the requests and\n   responses in the standard output. Check \ndebug\n option in \nrequestFactory\n\n\n\n\nBut you may need some other npm packages not integrated in \ncozy-konnector-libs\n to help you run your connector :\n\n\n\n\nmomentjs\n or \ndate-fns\n to manage dates\n\n\nbluebird\n to get enhanced promises\n\n\n\n\nWhen the connector is started, it also gets some data through environment variables:\n\n\n\n\nCOZY_CREDENTIALS\n\u00a0: the auth token used by \ncozy-client-js\n to communicate with the server\n\n\nCOZY_URL\n\u00a0: the API entry point\n\n\nCOZY_FIELDS\n\u00a0: the settings coming from \nCozy Collect\n and filled by the user of the connector (login, password, directory path).\n\n\n\n\nThose variables are used by the BaseKonnector and the cozy-client to configure the connection to\nthe \nCozy Stack\n with the right permissions as defined in your manifest.konnector. These are\nsimulated in standalone mode so that you don\nt need a real cozy stack to develop your connector.\n\n\nMore information\n\n\nFrom the server point of view, each connector is a \njob\n that is run periodically via a \ntrigger\n. \nMore information\n\n\nLet\u2019s create our first connector\n\n\nThe easiest way to create a new connector is to use \ncozy-konnector-template\n:\n\n\ncozy-konnector-template\n and standalone mode\n\n\ngit clone https://github.com/cozy/cozy-konnector-template cozy-konnector-monservice\ncd cozy-konnector-monservice\nyarn # or npm install\n\n\n\n\nnote: the Cozy Team uses \nyarn\n, but if you prefer \nnpm\n, just keep using it, everything should just work.\n\n\nThe connector template is ready with demo code to show you how to scrape a fictional\nwebsite: \nbooks.toscrape.com\n, for which you do not need to have\ncredentials.\n\n\nAs indicated in the README, just run it:\n\n\nyarn standalone\n\n\n\n\nThe first run will create a \nkonnector-dev-config.json\n file which allows you to configure the input\nof the connector when running it in the CLI.\n\n\n{\n  \nCOZY_URL\n: \nhttp://cozy.tools:8080\n,\n  \nfields\n: {}\n}\n\n\n\n\nCOZY_URL\n is for later, but the \nfields\n attribute will allow you to define credentials to the\ntarget web service, like \nlogin\n and \npassword\n as if they would come from a real \nCozy Stack\n.\n\n\nThis way to run the connector is the \nstandalone\n mode. In this mode, \ncozyClient\n is stubbed and\nall data meant to be saved in a cozy is displayed in the standard output and files are directly\nsaved in the root directory of the connector. This is useful to first develop your connector\nwithout handling the state of a real \nCozy Stack\n.\n\n\nYou have more documentation about this in the \nCLI section of the documentation\n.\n\n\nConnector structure\n\n\nBasically, a connector is just a function passed to the BaseKonnector constructor, and which\neventually returns a promise:\n\n\nTo create the connector, just create a new instance of BaseKonnector with the function as argument\n\n\nconst {BaseKonnector} = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(fields =\n {\n  // use fields to get user credentials and choices\n  console.log(fields, 'fields')\n})\n\n\n\n\nFetch operations\n\n\nEvery time the connector is run, it will call the function and wait for the resolution of the\nreturned promise. This function can then log into the remote site, fetch data and save it in the\nform of an array of objects with specific attributes expected by the different saving functions\n(\nsaveFiles\n, \naddData\n, \nfilterData\n, \nsaveBills\n).\n\n\nA basic connector workflow involves:\n\n\n\n\ngetting data and storing them into a variable. You can get the data by calling an API, scraping the remote website\u2026\n\n\nfiltering data to remove the ones already present inside the database using \nfilterData\n\n\nsave the filtered data into the database (\naddData\n)\n\n\nsave the related files using (\nsaveFiles\n)\n\n\n\n\nError handling\n\n\nIf your connector hits an issue fetching or saving the data, it can return an error code by throwing it as an error. The error codes are defined inside the \nCozy Collect\n application and will display an explicit error to the user:\n\n\n\n\nLOGIN_FAILED\n: the konnector could not login\n\n\nNOT_EXISTING_DIRECTORY\n: the folder specified as folder_to_save does not exist (checked automatically by the BaseKonnector)\n\n\nUNKNOWN_ERROR\n: there was an unexpected error, please take a look at the logs to know what appened\n\n\nVENDOR_DOWN\n: the target web site is down now\n\n\nUSER_ACTION_NEEDED\n: The user needs to login to the service to do manual actions (could be Terms Of Service to validate)\n\n\n\n\nYou can get the list of error codes in \nrequire('cozy-konnector-libs').errors\n\n\nconst {BaseKonnector, errors} = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(fields =\n {\n    // Here, the following message will be displayed in cozy-collect : \nBad credentials. Check the konnector fields and run the connection again.\n\n    throw new Error(errors.LOGIN_FAILED)\n})\n\n\n\n\ncozy-konnector-libs\n\n\nThe Cozy Konnector Libs provide several useful methods for common tasks:\n\n\n\n\nBaseKonnector\n: creates the connector and fetches data\n\n\ncozyClient\n gives an instance of \ncozy-client-js\n already initialized according to \nCOZY_URL\n, and \nCOZY_CREDENTIALS\n\n\nrequestFactory\n a function which returns an instance of request-promise initialized with defaults often used in connector development.\n\n\nlog\n allows to log messages with different levels\n\n\nfilterData\n to filter data\n\n\naddData\n to add Data to the cozy\n\n\nlinkBankOperations\n to link a bill to a bank operation\n\n\nsaveBills\n which uses filterData, addData, saveFiles and linkBankOperations and which is specific to bills\n\n\nupdateOrCreate\n create or update documents inside database\n\n\n\n\nLinking with a cozy and dev mode\n\n\nOnce your connector is able to gather data from the targeted web service in standalone mode. Now is\nthe time to put this data in a real cozy. Here comes the dev mode.\n\n\nBut before doing that, your connector needs more setup : a \nmanifest.konnector\n file and\n\nkonnector-dev-config.json\ns \nCOZY_URL\n section.\n\n\nThe manifest\n\n\nEach connector is described by a manifest. This is a JSON file named \nmanifest.konnector\n at the root of your code folder. It should include the following minimal information:\n\n\n{\n  \nname\n: \nkonnector name\n,\n  \ntype\n: \nnode\n,\n  \nslug\n: \nkonnectorslug\n,\n  \ndescription\n: \ndescription\n,\n  \nsource\n: \ngit://github.com/cozy/cozy-konnector-thename.git\n,\n  \npermissions\n: {\n    \naccounts\n: {\n      \ndescription\n: \nRequired to get the account's data\n,\n      \ntype\n: \nio.cozy.accounts\n,\n      \nverbs\n: [\nGET\n]\n    }\n  }\n}\n\n\n\n\ncozy-konnector-template\n already has a manifest which you can customize.\n\n\nYou may add some permissions for your own doctype. \nHere\n is the detailed list of fields for a\nconnector manifest file.\n\n\nYou can also get more information on permissions in the official \ncozy-stack documentation\n\n\nkonnector-dev-config.json\n\n\nIf you want to put data from your connector to a real cozy, your must define where to find this\ncozy, and this must be a cozy for which you have the credentials.\n\n\nHere comes the \nCOZY_URL\n in konnector-dev-config.json which defines just that.\n\n\nThen you just have to run:\n\n\nyarn dev\n\n\n\n\nAnd for the first run, the CLI will open a tab in your browser asking you to give permissions to the\nconnector and the connector will save data directly in your cozy. This will validate that your\nmanifest has the needed permissions on the data you want to save.\n\n\nthis is the \ndev\n mode\n\n\nIntegration in cozy-collect for all the users\n\n\nTo run a connector, we do not want the cozy to install all dependencies of the connector each time\nit installs it.\n\n\nTo avoid this, the connectors need to be compiled into one file in a dedicated branch of the\nrepository and the repository needs to be a public git repository. The \npackage.json\n file\nfrom \ncozy-konnector-template\n gives you the commands to do this : \nyarn build\n and \nyarn deploy\n \nbut the last one needs to be configured in \npackage.json\n\n\nOnce your public git repository is configured, you only have to declare it.\n\n\nCozy will soon have a store for connectors and you will be able to publish connectors yourself. But\nat the moment, you need to declare your new connector on the \ncozy forum\n.\nThe Cozy team will review your code and add your connector to the \nCozy Collect\n application.\n\n\nFAQ\n\n\nHow do I scrap a website\n\n\nUse the request function from \ncozy-konnector-libs\n with the proper options\n\n\nHere\u2019s a sample code that will fetch the login page to get the value of the anti-CSRF token, submit the login form, browse to the bills page and fetch a bill:\n\n\nconst {BaseKonnector, requestFactory} = require('cozy-konnector-libs')\nconst rq = requestFactory({\n  jar: true, // handle the cookies like a browser\n  json: false, // do not try to parse the result as a json document\n  cheerio: true // automatically parse the result with [cheerio](https://github.com/cheeriojs/cheerio)\n})\nconst moment = require('moment')\n\nmodule.exports = new BaseKonnector(function fetch (fields) {\n  return rq(\nhttps://login.remote.web\n)\n  .then($ =\n { // the result is automatically wrapped with cheerio and you can use it like jQuery\n    const form = {\n      form: {\n        login: fields.login,\n        password: fields.password,\n        csrf_token: $('[name=\ncsrf_token\n]').val(),\n      }\n    }\n    return rq({\n      method: 'POST',\n      form\n    })\n  })\n  .then($ =\n rq(\nhttps://admin.remote.web/bills\n))\n  .then($ =\n {\n    return [{date: moment($(\n#bill_date\n)), value: $(\n#bill_value\n)}]\n  })\n  .then(entries =\n addData(entries, 'io.cozy.bills'))\n})", 
            "title": "Develop a connector"
        }, 
        {
            "location": "/dev/konnector/#how-to-write-a-connector", 
            "text": "", 
            "title": "How to write a connector"
        }, 
        {
            "location": "/dev/konnector/#introduction", 
            "text": "A connector is a simple script which imports data from other web services and put it in your cozy.\nEach connector is an independant application, managed by the  Cozy Collect \napplication.  To protect your data, each connector runs inside a container in order to sandbox all their\ninteractions with your data.", 
            "title": "Introduction"
        }, 
        {
            "location": "/dev/konnector/#how-does-it-work", 
            "text": "A connector is a NodeJS script. The target node version used to run your connector is the current LTS version  (8 at the moment).  Like client side apps, connectors communicate with the  Cozy Stack \nusing its API, and get an auth token every time they start. They need to register with a manifest,\nand ask permissions to the user.  To ease the development of a connector, a npm package, named  cozy-konnector-libs \nprovides some shared libraries which are adapted to be used for a connector :   cheerio  to easily request html pages like jQuery  request-promise :  request  wrapped in promises  request-debug  which displays all the requests and\n   responses in the standard output. Check  debug  option in  requestFactory   But you may need some other npm packages not integrated in  cozy-konnector-libs  to help you run your connector :   momentjs  or  date-fns  to manage dates  bluebird  to get enhanced promises   When the connector is started, it also gets some data through environment variables:   COZY_CREDENTIALS \u00a0: the auth token used by  cozy-client-js  to communicate with the server  COZY_URL \u00a0: the API entry point  COZY_FIELDS \u00a0: the settings coming from  Cozy Collect  and filled by the user of the connector (login, password, directory path).   Those variables are used by the BaseKonnector and the cozy-client to configure the connection to\nthe  Cozy Stack  with the right permissions as defined in your manifest.konnector. These are\nsimulated in standalone mode so that you don t need a real cozy stack to develop your connector.  More information  From the server point of view, each connector is a  job  that is run periodically via a  trigger .  More information", 
            "title": "How does it work ?"
        }, 
        {
            "location": "/dev/konnector/#lets-create-our-first-connector", 
            "text": "The easiest way to create a new connector is to use  cozy-konnector-template :", 
            "title": "Let\u2019s create our first connector"
        }, 
        {
            "location": "/dev/konnector/#cozy-konnector-template-and-standalone-mode", 
            "text": "git clone https://github.com/cozy/cozy-konnector-template cozy-konnector-monservice\ncd cozy-konnector-monservice\nyarn # or npm install  note: the Cozy Team uses  yarn , but if you prefer  npm , just keep using it, everything should just work.  The connector template is ready with demo code to show you how to scrape a fictional\nwebsite:  books.toscrape.com , for which you do not need to have\ncredentials.  As indicated in the README, just run it:  yarn standalone  The first run will create a  konnector-dev-config.json  file which allows you to configure the input\nof the connector when running it in the CLI.  {\n   COZY_URL :  http://cozy.tools:8080 ,\n   fields : {}\n}  COZY_URL  is for later, but the  fields  attribute will allow you to define credentials to the\ntarget web service, like  login  and  password  as if they would come from a real  Cozy Stack .  This way to run the connector is the  standalone  mode. In this mode,  cozyClient  is stubbed and\nall data meant to be saved in a cozy is displayed in the standard output and files are directly\nsaved in the root directory of the connector. This is useful to first develop your connector\nwithout handling the state of a real  Cozy Stack .  You have more documentation about this in the  CLI section of the documentation .", 
            "title": "cozy-konnector-template and standalone mode"
        }, 
        {
            "location": "/dev/konnector/#connector-structure", 
            "text": "Basically, a connector is just a function passed to the BaseKonnector constructor, and which\neventually returns a promise:  To create the connector, just create a new instance of BaseKonnector with the function as argument  const {BaseKonnector} = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(fields =  {\n  // use fields to get user credentials and choices\n  console.log(fields, 'fields')\n})", 
            "title": "Connector structure"
        }, 
        {
            "location": "/dev/konnector/#fetch-operations", 
            "text": "Every time the connector is run, it will call the function and wait for the resolution of the\nreturned promise. This function can then log into the remote site, fetch data and save it in the\nform of an array of objects with specific attributes expected by the different saving functions\n( saveFiles ,  addData ,  filterData ,  saveBills ).  A basic connector workflow involves:   getting data and storing them into a variable. You can get the data by calling an API, scraping the remote website\u2026  filtering data to remove the ones already present inside the database using  filterData  save the filtered data into the database ( addData )  save the related files using ( saveFiles )", 
            "title": "Fetch operations"
        }, 
        {
            "location": "/dev/konnector/#error-handling", 
            "text": "If your connector hits an issue fetching or saving the data, it can return an error code by throwing it as an error. The error codes are defined inside the  Cozy Collect  application and will display an explicit error to the user:   LOGIN_FAILED : the konnector could not login  NOT_EXISTING_DIRECTORY : the folder specified as folder_to_save does not exist (checked automatically by the BaseKonnector)  UNKNOWN_ERROR : there was an unexpected error, please take a look at the logs to know what appened  VENDOR_DOWN : the target web site is down now  USER_ACTION_NEEDED : The user needs to login to the service to do manual actions (could be Terms Of Service to validate)   You can get the list of error codes in  require('cozy-konnector-libs').errors  const {BaseKonnector, errors} = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(fields =  {\n    // Here, the following message will be displayed in cozy-collect :  Bad credentials. Check the konnector fields and run the connection again. \n    throw new Error(errors.LOGIN_FAILED)\n})", 
            "title": "Error handling"
        }, 
        {
            "location": "/dev/konnector/#cozy-konnector-libs", 
            "text": "The Cozy Konnector Libs provide several useful methods for common tasks:   BaseKonnector : creates the connector and fetches data  cozyClient  gives an instance of  cozy-client-js  already initialized according to  COZY_URL , and  COZY_CREDENTIALS  requestFactory  a function which returns an instance of request-promise initialized with defaults often used in connector development.  log  allows to log messages with different levels  filterData  to filter data  addData  to add Data to the cozy  linkBankOperations  to link a bill to a bank operation  saveBills  which uses filterData, addData, saveFiles and linkBankOperations and which is specific to bills  updateOrCreate  create or update documents inside database", 
            "title": "cozy-konnector-libs"
        }, 
        {
            "location": "/dev/konnector/#linking-with-a-cozy-and-dev-mode", 
            "text": "Once your connector is able to gather data from the targeted web service in standalone mode. Now is\nthe time to put this data in a real cozy. Here comes the dev mode.  But before doing that, your connector needs more setup : a  manifest.konnector  file and konnector-dev-config.json s  COZY_URL  section.", 
            "title": "Linking with a cozy and dev mode"
        }, 
        {
            "location": "/dev/konnector/#the-manifest", 
            "text": "Each connector is described by a manifest. This is a JSON file named  manifest.konnector  at the root of your code folder. It should include the following minimal information:  {\n   name :  konnector name ,\n   type :  node ,\n   slug :  konnectorslug ,\n   description :  description ,\n   source :  git://github.com/cozy/cozy-konnector-thename.git ,\n   permissions : {\n     accounts : {\n       description :  Required to get the account's data ,\n       type :  io.cozy.accounts ,\n       verbs : [ GET ]\n    }\n  }\n}  cozy-konnector-template  already has a manifest which you can customize.  You may add some permissions for your own doctype.  Here  is the detailed list of fields for a\nconnector manifest file.  You can also get more information on permissions in the official  cozy-stack documentation", 
            "title": "The manifest"
        }, 
        {
            "location": "/dev/konnector/#konnector-dev-configjson", 
            "text": "If you want to put data from your connector to a real cozy, your must define where to find this\ncozy, and this must be a cozy for which you have the credentials.  Here comes the  COZY_URL  in konnector-dev-config.json which defines just that.  Then you just have to run:  yarn dev  And for the first run, the CLI will open a tab in your browser asking you to give permissions to the\nconnector and the connector will save data directly in your cozy. This will validate that your\nmanifest has the needed permissions on the data you want to save.  this is the  dev  mode", 
            "title": "konnector-dev-config.json"
        }, 
        {
            "location": "/dev/konnector/#integration-in-cozy-collect-for-all-the-users", 
            "text": "To run a connector, we do not want the cozy to install all dependencies of the connector each time\nit installs it.  To avoid this, the connectors need to be compiled into one file in a dedicated branch of the\nrepository and the repository needs to be a public git repository. The  package.json  file\nfrom  cozy-konnector-template  gives you the commands to do this :  yarn build  and  yarn deploy  \nbut the last one needs to be configured in  package.json  Once your public git repository is configured, you only have to declare it.  Cozy will soon have a store for connectors and you will be able to publish connectors yourself. But\nat the moment, you need to declare your new connector on the  cozy forum .\nThe Cozy team will review your code and add your connector to the  Cozy Collect  application.", 
            "title": "Integration in cozy-collect for all the users"
        }, 
        {
            "location": "/dev/konnector/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/dev/konnector/#how-do-i-scrap-a-website", 
            "text": "Use the request function from  cozy-konnector-libs  with the proper options  Here\u2019s a sample code that will fetch the login page to get the value of the anti-CSRF token, submit the login form, browse to the bills page and fetch a bill:  const {BaseKonnector, requestFactory} = require('cozy-konnector-libs')\nconst rq = requestFactory({\n  jar: true, // handle the cookies like a browser\n  json: false, // do not try to parse the result as a json document\n  cheerio: true // automatically parse the result with [cheerio](https://github.com/cheeriojs/cheerio)\n})\nconst moment = require('moment')\n\nmodule.exports = new BaseKonnector(function fetch (fields) {\n  return rq( https://login.remote.web )\n  .then($ =  { // the result is automatically wrapped with cheerio and you can use it like jQuery\n    const form = {\n      form: {\n        login: fields.login,\n        password: fields.password,\n        csrf_token: $('[name= csrf_token ]').val(),\n      }\n    }\n    return rq({\n      method: 'POST',\n      form\n    })\n  })\n  .then($ =  rq( https://admin.remote.web/bills ))\n  .then($ =  {\n    return [{date: moment($( #bill_date )), value: $( #bill_value )}]\n  })\n  .then(entries =  addData(entries, 'io.cozy.bills'))\n})", 
            "title": "How do I scrap a website"
        }, 
        {
            "location": "/dev/cordova/", 
            "text": "How to create a mobile Cozy application\n\n\nThe simplest way to create a mobile Cozy application is to use JavaScript as there already are JavaScript libraries to connect to the Cozy server, as known as cozy-stack.\n\n\nTherefore we will use the classical stack:\n\n\n\n\na JavaScript web application\n\n\nand cordova\n\n\n\n\n\n\nAt the end of this documentation\n, you will find \nhow-tos\n to help you with \ncordova configuration\n, \nwebpack builds\n and \ncordova deployments for Android and iOS\n.\n\n\n\n\nTo create \nyour first Cozy application\n, just follow the guide.\nAs you can read there, Cozy applications are served by the Cozy server, this is the way that Cozy applications retrieve a token to query data.\n\n\nIn the case of a mobile application, you need to retrieve a token differently. Hopefully we provide everything you need to do it easily.\n\n\nYou\nll need two libraries:\n\n\n\n\ncozy-client (\nsource\n)\n\n\ncozy-bar (\nsource\n)\n\n\n\n\n\n\nIn the case of Cozy web applications served by the Cozy server, these two libraries are injected in the html file with variables \n{{.CozyClientJS}}\n and \n{{.CozyBar}}\n.\n\n\n\n\nSetup index.html\n\n\nFirst thing first, add JavaScript libraries files into your \nindex.html\n:\n\n\n!DOCTYPE html\n\n\nhtml lang=\nen\n\n  \nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nmobile Cozy application with Cordova\n/title\n\n    \nscript src=\ncozy-client.js\n/script\n\n    \nscript src=\ncozy-bar.js\n/script\n\n  \n/head\n\n  \nbody\n\n    \n!-- page content --\n\n  \n/body\n\n\n/html\n\n\n\n\nConnect to Cozy server\n\n\nWhen an user will start your mobile Cozy application, she/he will need to point to her/his server url to ask for permissions for her/his device.\n\n\nThis is done by our library \ncozy-client\n, you just need to add a HTML form:\n\n\nform id=\nform\n\n  \nlabel\nWhat is your cozy server url?\n    \ninput name=\nurl\n id=\nurl\n type=\ntext\n /\n\n  \n/label\n\n  \nbutton type=\nsubmit\nSubmit\n/button\n\n\n/form\n\n\n\n\nconst urlInput = document.getElementById(\nurl\n);\nconst form = document.getElementById(\nform\n);\nform.addEventListener(\nsubmit\n, registerClient);\nfunction registerClient (event) {\n  event.preventDefault();\n  const url = urlInput.value;\n  const { client, token } = await cozyClient.register(url);\n  // do whatever you need with client and token like persist\n}\n\n\n\n\nJS Bin on jsbin.com\n\n\nWhen \ncozyClient.register(url)\n is called, \nthe cordova inapp browser plugin\n is used to display a password request and a permission acceptation page to let the end-user to register her/his device.\n\n\nThat\ns all!\n\n\nThen you can use the cozy-client library as \nyou would within a classic Cozy application\n.\n\n\nInitialize the Cozy bar\n\n\nThe Cozy bar needs some information to be initialized and its initialization must be done in your front-end code:\n\n\ncozy.bar.init({\n  appName: \nApp Name\n,\n  appEditor: \nEditor Name\n,\n  iconPath: require(\n./assets/app-icon.svg\n),\n  lang: \nen-US\n,\n  replaceTitleOnMobile: true\n})\n\n\n\n\nUse Cordova\n\n\nInstall and setup cordova\n\n\nCordova is a tool\n to build Android and iOS applications from a web app.\n\n\nIt works with a CLI that needs \nnode\n.\nLook at the \ncordova documentation to install everything needed\n.\n\n\nOnce cordova is installed, just run \ncordova create cozy-app com.example.cozyapp CozyApp\n and you get the following structure: \n\n\n./\n\u251c\u2500\u2500 config.xml\n\u251c\u2500\u2500 hooks\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 platforms\n\u251c\u2500\u2500 plugins\n\u2514\u2500\u2500 www\n    \u251c\u2500\u2500 css\n    \u2502   \u2514\u2500\u2500 index.css\n    \u251c\u2500\u2500 img\n    \u2502   \u2514\u2500\u2500 logo.png\n    \u251c\u2500\u2500 index.html\n    \u2514\u2500\u2500 js\n        \u2514\u2500\u2500 index.js\n\n7 directories, 6 files\n\n\n\n\nNote:\n everything you put in \nwww/\n will be served as your application content.\n\n\nConfigure your build tool\n\n\nIf you use a build tool to transpile your JavaScript code, you need to configure your tool to output the build into \nwww/\n.\n\n\nwebpack configuration\n\n\nAs \nWebpack is the most used build tool\n we will show you how to configure it with cordova:\n\n\nCreate a \nwebpack.config.js\n on the root folder of your project with:\n\n\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    filename: 'bundle.js',\n    path.resolve(__dirname, 'www')\n  }\n}\n\n\n\n\nAnd add the output bundle in the \nwww/index.html\n file:\n\n\nhtml\n\n  \nhead\n\n    ...\n  \n/head\n\n  \nbody\n\n    ...\n    \nscript src=\nbundle.js\n/script\n\n  \n/body\n\n\n/html\n\n\n\n\nSee \nthe official webpack documentation\n for more details.\n\n\nCordova\n\n\nAndroid Platform\n\n\nUse \ncordova platform add android\n and check your environment with \ncordova requirements\n:\n\n\nA bad requirements check:\n\n\nRequirements check results for android:\nJava JDK: installed .\nAndroid SDK: installed\nAndroid target: not installed\nAndroid SDK not found. Make sure that it is installed. If it is not at the default location, set the ANDROID_HOME environment variable.\nGradle: installed\nError: Some of requirements check failed\n\n\n\n\nA good requirements check:\n\n\nRequirements check results for android:\nJava JDK: installed .\nAndroid SDK: installed\nAndroid target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23\nGradle: installed\n\n\n\n\nSee cordova, android and ios documentation to customize your development environment for your special needs.\n\n\nOnce everything is right, you could run \ncordova build\n and \ncordova run android\n to create an APK and push the APK on a device.\n\n\nNote:\n The device should be connected with usb.\nSee \nofficial android documentation for more details\n.\n\n\niOS development\n\n\nFor building an iOS app, you need \nxcode\n.\n\n\n[[more to come]]\n\n\nSee further details on \nthe cordova official documentation about iOS\n.", 
            "title": "Create a mobile app with cordova"
        }, 
        {
            "location": "/dev/cordova/#how-to-create-a-mobile-cozy-application", 
            "text": "The simplest way to create a mobile Cozy application is to use JavaScript as there already are JavaScript libraries to connect to the Cozy server, as known as cozy-stack.  Therefore we will use the classical stack:   a JavaScript web application  and cordova    At the end of this documentation , you will find  how-tos  to help you with  cordova configuration ,  webpack builds  and  cordova deployments for Android and iOS .   To create  your first Cozy application , just follow the guide.\nAs you can read there, Cozy applications are served by the Cozy server, this is the way that Cozy applications retrieve a token to query data.  In the case of a mobile application, you need to retrieve a token differently. Hopefully we provide everything you need to do it easily.  You ll need two libraries:   cozy-client ( source )  cozy-bar ( source )    In the case of Cozy web applications served by the Cozy server, these two libraries are injected in the html file with variables  {{.CozyClientJS}}  and  {{.CozyBar}} .", 
            "title": "How to create a mobile Cozy application"
        }, 
        {
            "location": "/dev/cordova/#setup-indexhtml", 
            "text": "First thing first, add JavaScript libraries files into your  index.html :  !DOCTYPE html  html lang= en \n   head \n     meta charset= utf-8 \n     title mobile Cozy application with Cordova /title \n     script src= cozy-client.js /script \n     script src= cozy-bar.js /script \n   /head \n   body \n     !-- page content -- \n   /body  /html", 
            "title": "Setup index.html"
        }, 
        {
            "location": "/dev/cordova/#connect-to-cozy-server", 
            "text": "When an user will start your mobile Cozy application, she/he will need to point to her/his server url to ask for permissions for her/his device.  This is done by our library  cozy-client , you just need to add a HTML form:  form id= form \n   label What is your cozy server url?\n     input name= url  id= url  type= text  / \n   /label \n   button type= submit Submit /button  /form  const urlInput = document.getElementById( url );\nconst form = document.getElementById( form );\nform.addEventListener( submit , registerClient);\nfunction registerClient (event) {\n  event.preventDefault();\n  const url = urlInput.value;\n  const { client, token } = await cozyClient.register(url);\n  // do whatever you need with client and token like persist\n}  JS Bin on jsbin.com  When  cozyClient.register(url)  is called,  the cordova inapp browser plugin  is used to display a password request and a permission acceptation page to let the end-user to register her/his device.  That s all!  Then you can use the cozy-client library as  you would within a classic Cozy application .", 
            "title": "Connect to Cozy server"
        }, 
        {
            "location": "/dev/cordova/#initialize-the-cozy-bar", 
            "text": "The Cozy bar needs some information to be initialized and its initialization must be done in your front-end code:  cozy.bar.init({\n  appName:  App Name ,\n  appEditor:  Editor Name ,\n  iconPath: require( ./assets/app-icon.svg ),\n  lang:  en-US ,\n  replaceTitleOnMobile: true\n})", 
            "title": "Initialize the Cozy bar"
        }, 
        {
            "location": "/dev/cordova/#use-cordova", 
            "text": "", 
            "title": "Use Cordova"
        }, 
        {
            "location": "/dev/cordova/#install-and-setup-cordova", 
            "text": "Cordova is a tool  to build Android and iOS applications from a web app.  It works with a CLI that needs  node .\nLook at the  cordova documentation to install everything needed .  Once cordova is installed, just run  cordova create cozy-app com.example.cozyapp CozyApp  and you get the following structure:   ./\n\u251c\u2500\u2500 config.xml\n\u251c\u2500\u2500 hooks\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 platforms\n\u251c\u2500\u2500 plugins\n\u2514\u2500\u2500 www\n    \u251c\u2500\u2500 css\n    \u2502   \u2514\u2500\u2500 index.css\n    \u251c\u2500\u2500 img\n    \u2502   \u2514\u2500\u2500 logo.png\n    \u251c\u2500\u2500 index.html\n    \u2514\u2500\u2500 js\n        \u2514\u2500\u2500 index.js\n\n7 directories, 6 files  Note:  everything you put in  www/  will be served as your application content.", 
            "title": "Install and setup cordova"
        }, 
        {
            "location": "/dev/cordova/#configure-your-build-tool", 
            "text": "If you use a build tool to transpile your JavaScript code, you need to configure your tool to output the build into  www/ .", 
            "title": "Configure your build tool"
        }, 
        {
            "location": "/dev/cordova/#webpack-configuration", 
            "text": "As  Webpack is the most used build tool  we will show you how to configure it with cordova:  Create a  webpack.config.js  on the root folder of your project with:  const path = require('path');\n\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    filename: 'bundle.js',\n    path.resolve(__dirname, 'www')\n  }\n}  And add the output bundle in the  www/index.html  file:  html \n   head \n    ...\n   /head \n   body \n    ...\n     script src= bundle.js /script \n   /body  /html  See  the official webpack documentation  for more details.", 
            "title": "webpack configuration"
        }, 
        {
            "location": "/dev/cordova/#cordova", 
            "text": "", 
            "title": "Cordova"
        }, 
        {
            "location": "/dev/cordova/#android-platform", 
            "text": "Use  cordova platform add android  and check your environment with  cordova requirements :  A bad requirements check:  Requirements check results for android:\nJava JDK: installed .\nAndroid SDK: installed\nAndroid target: not installed\nAndroid SDK not found. Make sure that it is installed. If it is not at the default location, set the ANDROID_HOME environment variable.\nGradle: installed\nError: Some of requirements check failed  A good requirements check:  Requirements check results for android:\nJava JDK: installed .\nAndroid SDK: installed\nAndroid target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23\nGradle: installed  See cordova, android and ios documentation to customize your development environment for your special needs.  Once everything is right, you could run  cordova build  and  cordova run android  to create an APK and push the APK on a device.  Note:  The device should be connected with usb.\nSee  official android documentation for more details .", 
            "title": "Android Platform"
        }, 
        {
            "location": "/dev/cordova/#ios-development", 
            "text": "For building an iOS app, you need  xcode .  [[more to come]]  See further details on  the cordova official documentation about iOS .", 
            "title": "iOS development"
        }, 
        {
            "location": "/dev/sendmail/", 
            "text": "Share and send mail in development\n\n\nCozy apps let users \nshare documents from cozy to cozy\n.\n\n\nMeet Alice and Bob.\nAlice wants to share a folder with Bob.\nAlice clicks on the share button and fills in the email input with Bob\ns email address.\nBob receives an email with a \n\u00ab Accept the sharing \u00bb\n button.\nBob clicks on that button and is redirected to Alice\ns cozy to enter his own cozy url to link both cozys.\nBob sees Alice\ns shared folder in his own cozy.\n\n\n\ud83e\udd14 But how could we do this scenario on development environment?\n\n\nWith the docker image\n\n\nIf you develop with the \ncozy-app-dev docker image\n, \nMailHog\n is running inside it to catch emails.\n\n\nIf cozy-stack has to send an email, MailHog catches it and exposes it on its web interface on http://cozy.tools:8025/.\n\n\nWith the binary cozy-stack\n\n\nIf you develop with the \ncozy-stack CLI\n, you have to run \nMailHog\n on your computer and tell \ncozy-stack serve\n where to find the mail server with some \noptions\n:\n\n\n./cozy-stack serve --appdir drive:../cozy-drive/build,settings:../cozy-settings/build --mail-disable-tls --mail-port 1025\n\n\n\n\nThis commands assumes you \ngit clone\n \ncozy-drive\n and \ncozy-settings\n in the same folder than you \ngit clone\n \ncozy-stack\n.\n\n\nThen simply run \nMailHog\n and open http://cozy.tools:8025/.\n\n\nRetrieve sent emails\n\n\nWith MailHog, \nevery email\n sent by cozy-stack is caught. That means the email address \ndoes not have to be a real one\n, ie. \nbob@cozy\n, \nbob@cozy.tools\n are perfectly fine. It \ncould be a real one\n, but the email will not reach the real recipient\ns inbox, say \ncontact@cozycloud.cc\n.", 
            "title": "How to send mail in development"
        }, 
        {
            "location": "/dev/sendmail/#share-and-send-mail-in-development", 
            "text": "Cozy apps let users  share documents from cozy to cozy .  Meet Alice and Bob.\nAlice wants to share a folder with Bob.\nAlice clicks on the share button and fills in the email input with Bob s email address.\nBob receives an email with a  \u00ab Accept the sharing \u00bb  button.\nBob clicks on that button and is redirected to Alice s cozy to enter his own cozy url to link both cozys.\nBob sees Alice s shared folder in his own cozy.  \ud83e\udd14 But how could we do this scenario on development environment?", 
            "title": "Share and send mail in development"
        }, 
        {
            "location": "/dev/sendmail/#with-the-docker-image", 
            "text": "If you develop with the  cozy-app-dev docker image ,  MailHog  is running inside it to catch emails.  If cozy-stack has to send an email, MailHog catches it and exposes it on its web interface on http://cozy.tools:8025/.", 
            "title": "With the docker image"
        }, 
        {
            "location": "/dev/sendmail/#with-the-binary-cozy-stack", 
            "text": "If you develop with the  cozy-stack CLI , you have to run  MailHog  on your computer and tell  cozy-stack serve  where to find the mail server with some  options :  ./cozy-stack serve --appdir drive:../cozy-drive/build,settings:../cozy-settings/build --mail-disable-tls --mail-port 1025  This commands assumes you  git clone   cozy-drive  and  cozy-settings  in the same folder than you  git clone   cozy-stack .  Then simply run  MailHog  and open http://cozy.tools:8025/.", 
            "title": "With the binary cozy-stack"
        }, 
        {
            "location": "/dev/sendmail/#retrieve-sent-emails", 
            "text": "With MailHog,  every email  sent by cozy-stack is caught. That means the email address  does not have to be a real one , ie.  bob@cozy ,  bob@cozy.tools  are perfectly fine. It  could be a real one , but the email will not reach the real recipient s inbox, say  contact@cozycloud.cc .", 
            "title": "Retrieve sent emails"
        }, 
        {
            "location": "/cozy-konnector-libs/api/", 
            "text": "API\n\n\nModules\n\n\n\n\naddData\n\n\nThis function saves the data into the cozy blindly without check\nYou need at least the \nPOST\n permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\ndocuments\n: an array of objects corresponding to the data you want to save in the cozy\n\n\ndoctype\n (string): the doctype where you want to save data (ex: \nio.cozy.bills\n)\n\n\n\n\nconst documents = [\n  {\n    name: \ntoto\n,\n    height: 1.8\n  },\n  {\n    name: \ntiti\n,\n    height: 1.7\n  }\n]\n\nreturn addData(documents, \nio.cozy.height\n)\n\n\n\n\n\ncozyClient\n\n\nThis is a \ncozy-client-js\n instance already initialized and ready to use\n\n\nIf you want to access cozy-client-js directly, this method gives you directly an instance of it,\ninitialized according to \nCOZY_URL\n and \nCOZY_CREDENTIALS\n environment variable given by cozy-stack\nYou can refer to the \ncozy-client-js documentation\n for more information.\n\n\nExample :\n\n\nconst {cozyClient} = require(\ncozy-konnector-libs\n)\n\ncozyClient.data.defineIndex(\nmy.doctype\n, [\n_id\n])\n\n\n\n\n\nfilterData\n\n\nThis function filters the passed array from data already present in the cozy so that there is\nnot duplicated data in the cozy.\nYou need at least the \nGET\n permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\ndocuments\n: an array of objects corresponding to the data you want to save in the cozy\n\n\ndoctype\n (string): the doctype where you want to save data (ex: \nio.cozy.bills\n)\n\n\noptions\n :\n\n\nkeys\n (array) : List of keys used to check that two items are the same. By default it is set to `[\nid\n]\n.\n\n\nindex\n (optionnal) : Return value returned by \ncozy.data.defineIndex\n, the default will correspond to all documents of the selected doctype.\n\n\nselector\n (optionnal object) : Mango request to get records. Default is built from the keys \n{selector: {_id: {\n$gt\n: null}}}\n to get all the records.\n\n\n\n\n\n\n\n\nconst documents = [\n  {\n    name: \ntoto\n,\n    height: 1.8\n  },\n  {\n    name: \ntiti\n,\n    height: 1.7\n  }\n]\n\nreturn filterData(documents, \nio.cozy.height\n, {\n  keys: [\nname\n]\n}).then(filteredDocuments =\n addData(filteredDocuments, \nio.cozy.height\n))\n\n\n\n\n\n\nlinkBankOperations\n\n\nlinkBankOperations ( entries, doctype, fields, options = {} )\n\n\nThis function will soon move to a dedicated service. You should not use it.\nThe goal of this function is to find links between bills and bank operations.\n\n\n\n\nrequestFactory\n\n\nThis is a function which returns an instance of\n\nrequest-promise\n initialized with\ndefaults often used in connector development.\n\n\n// Showing defaults\nreq = requestFactory({\n  cheerio: false,\n  jar: true,\n  json: true\n})\n\n\n\nOptions :\n\n\n\n\ncheerio\n:  will parse automatically the \nresponse.body\n in a cheerio instance\n\n\n\n\nreq = requestFactory({ cheerio: true })\nreq(\nhttp://github.com\n, $ =\n {\n  const repos = $(\n#repo_listing .repo\n)\n})\n\n\n\n\n\njar\n: is passed to \nrequest\n options. Remembers cookies for future use.\n\n\njson\n: will parse the \nresponse.body\n as JSON\n\n\njson\n: will parse the \nresponse.body\n as JSON\n\n\nresolveWithFullResponse\n: The full response will be return in the promise. It is compatible\nwith cheerio and json options.\n\n\n\n\nreq = requestFactory({\n   resolveWithFullResponse: true,\n   cheerio: true\n})\nreq(\nhttp://github.com\n, response =\n {\n  console.log(response.statusCode)\n  const $ = response.body\n  const repos = $(\n#repo_listing .repo\n)\n})\n\n\n\nYou can find the full list of available options in \nrequest-promise\n and \nrequest\n documentations.\n\n\n\n\nsaveBills\n\n\nCombines the features of \nsaveFiles\n, \nfilterData\n, \naddData\n and \nlinkBankOperations\n for a\ncommon case: bills.\nWill create \nio.cozy.bills\n objects. The default deduplication keys are \n[\ndate\n, \namount\n, \nvendor\n]\n.\nYou need the full permission on \nio.cozy.bills\n, full permission on \nio.cozy.files\n and also\nfull permission on \nio.cozy.bank.operations\n in your manifest, to be able to * use this function.\n\n\nParameters:\n\n\n\n\ndocuments\n is an array of objects with any attributes :\n\n\nfields\n (object) this is the first parameter given to BaseKonnector\ns constructor\n\n\noptions\n is passed directly to \nsaveFiles\n, \nhydrateAndFilter\n, \naddData\n and \nlinkBankOperations\n.\n\n\n\n\nconst { BaseKonnector, saveBills } = require(\ncozy-konnector-libs\n)\n\nmodule.exports = new BaseKonnector(function fetch (fields) {\n  const documents = []\n  // some code which fills documents\n  return saveBills(documents, fields, {\n    identifiers: [\nvendorj\n]\n  })\n})\n\n\n\n\n\nsaveFiles\n\n\nThe goal of this function is to save the given files in the given folder via the Cozy API.\nYou need the full permission on \nio.cozy.files\n in your manifest to use this function.\n\n\n\n\nfiles\n is an array of \n{ fileurl, filename }\n :\n\n\n\n\nfileurl: The url of the file. This attribute is mandatory or\nthis item will be ignored\n\n\nfilename : The file name of the item written on disk. This attribute is optional and as default value, the\nfile name will be \nsmartly\n guessed by the function. Use this attribute if the guess is not smart\nenough for you.\n\n\n\n\n\n\nfolderPath\n (string) is relative to the main path given by the \ncozy-collect\n application to the connector. If the connector is run\nin standalone mode, the main path is the path of the connector.\n\n\n\n\noptions\n (object) is optional. Possible options :\n\n\n\n\ntimeout\n (timestamp) can be used if your connector needs to fetch a lot of files and if the\nstack does not give enough time to your connector to fetch it all. It could happen that the\nconnector is stopped right in the middle of the download of the file and the file will be\nbroken. With the \ntimeout\n option, the \nsaveFiles\n function will check if the timeout has\npassed right after downloading each file and then will be sure to be stopped cleanly if the\ntimeout is not too long. And since it is really fast to check that a file has already been\ndownloaded, on the next run of the connector, it will be able to download some more\nfiles, and so on. If you want the timeout to be in 10s, do \nDate.now() + 10*1000\n.\nYou can try it in the previous code.\n\n\n\n\n\n\n\n\n\n\nupdateOrCreate\n\n\nThe goal of this function is create or update the given entries according to if they already\nexist in the cozy or not\nYou need the full permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\nentries\n is an array of objects with any attributes :\n\n\ndoctype\n (string) is the cozy doctype where the entries should be saved\n\n\nmatchingAttributes\n (array of strings) is the list of attributes in each entry should be used to check if an entry\nis already saved in the cozy\n\n\n\n\n\n\n\n\n\nClasses\n\n\n\n\nBaseKonnector\n\n\nThe class from which all the connectors must inherit.\nIt takes a fetch function in parameter that must return a \nPromise\n.\nYou need at least the \nGET\n permission on \nio.cozy.accounts\n in your manifest to allow it to\nfetch account information for your connector.\n\n\n\n\nDocument\n\n\nSimple Model for Documents. Allows to specify\n\nshouldSave\n, \nshouldUpdate\n as methods.\n\n\nHas useful \nisEqual\n method\n\n\n\n\n\n\n\nConstants\n\n\n\n\nLOGIN_FAILED\n : \nString\n\n\nThe konnector could not login\n\n\n\n\nNOT_EXISTING_DIRECTORY\n : \nString\n\n\nThe folder specified as folder_to_save does not exist (checked by BaseKonnector)\n\n\n\n\nVENDOR_DOWN\n : \nString\n\n\nThe vendor\ns website is down\n\n\n\n\nUSER_ACTION_NEEDED\n : \nString\n\n\nThere was an unexpected error, please take a look at the logs to know what happened\n\n\n\n\nFILE_DOWNLOAD_FAILED\n : \nString\n\n\nThere was a problem while downloading a file\n\n\n\n\nSAVE_FILE_FAILED\n : \nString\n\n\nThere was a problem while saving a file\n\n\n\n\n\n\n\nFunctions\n\n\n\n\nmkSpec()\n\n\nDeclarative scraping.\n\n\nDescribe your items attributes and where to find/parse them\ninstead of imperatively building them.\n\n\nHeavily inspired by \nartoo\n scraping method.\n\n\n\n\nscrape($, spec(s), [childSelector])\n \u21d2 \nobject\n | \narray\n\n\nScrape a cheerio object for properties\n\n\n\n\n\n\n\n\n\naddData\n\n\nThis function saves the data into the cozy blindly without check\nYou need at least the \nPOST\n permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\ndocuments\n: an array of objects corresponding to the data you want to save in the cozy\n\n\ndoctype\n (string): the doctype where you want to save data (ex: \nio.cozy.bills\n)\n\n\n\n\nconst documents = [\n  {\n    name: 'toto',\n    height: 1.8\n  },\n  {\n    name: 'titi',\n    height: 1.7\n  }\n]\n\nreturn addData(documents, 'io.cozy.height')\n\n\n\n\n\n\ncozyClient\n\n\nThis is a \ncozy-client-js\n instance already initialized and ready to use\n\n\nIf you want to access cozy-client-js directly, this method gives you directly an instance of it,\ninitialized according to \nCOZY_URL\n and \nCOZY_CREDENTIALS\n environment variable given by cozy-stack\nYou can refer to the \ncozy-client-js documentation\n for more information.\n\n\nExample :\n\n\nconst {cozyClient} = require('cozy-konnector-libs')\n\ncozyClient.data.defineIndex('my.doctype', ['_id'])\n\n\n\n\n\n\nfilterData\n\n\nThis function filters the passed array from data already present in the cozy so that there is\nnot duplicated data in the cozy.\nYou need at least the \nGET\n permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\ndocuments\n: an array of objects corresponding to the data you want to save in the cozy\n\n\ndoctype\n (string): the doctype where you want to save data (ex: \nio.cozy.bills\n)\n\n\noptions\n :\n\n\nkeys\n (array) : List of keys used to check that two items are the same. By default it is set to `[\nid\n]\n.\n\n\nindex\n (optionnal) : Return value returned by \ncozy.data.defineIndex\n, the default will correspond to all documents of the selected doctype.\n\n\nselector\n (optionnal object) : Mango request to get records. Default is built from the keys \n{selector: {_id: {\"$gt\": null}}}\n to get all the records.\n\n\n\n\nconst documents = [\n  {\n    name: 'toto',\n    height: 1.8\n  },\n  {\n    name: 'titi',\n    height: 1.7\n  }\n]\n\nreturn filterData(documents, 'io.cozy.height', {\n  keys: ['name']\n}).then(filteredDocuments =\n addData(filteredDocuments, 'io.cozy.height'))\n\n\n\n\n\n\nfilterData~suitableCall()\n\n\nSince we can use methods or basic functions for\n\nshouldSave\n and \nshouldUpdate\n we pass the\nappropriate \nthis\n and \narguments\n.\n\n\nIf \nfuncOrMethod\n is a method, it will be called\nwith args[0] as \nthis\n and the rest as \narguments\n\nOtherwise, \nthis\n will be null and \nargs\n will be passed\nas \narguments\n.\n\n\nKind\n: inner method of \nfilterData\n\n\n\n\nlinkBankOperations\n\n\nlinkBankOperations ( entries, doctype, fields, options = {} )\n\n\nThis function will soon move to a dedicated service. You should not use it.\nThe goal of this function is to find links between bills and bank operations.\n\n\n\n\nrequestFactory\n\n\nThis is a function which returns an instance of\n\nrequest-promise\n initialized with\ndefaults often used in connector development.\n\n\n// Showing defaults\nreq = requestFactory({\n  cheerio: false,\n  jar: true,\n  json: true\n})\n\n\n\n\nOptions :\n\n\n\n\ncheerio\n:  will parse automatically the \nresponse.body\n in a cheerio instance\n\n\n\n\nreq = requestFactory({ cheerio: true })\nreq('http://github.com', $ =\n {\n  const repos = $('#repo_listing .repo')\n})\n\n\n\n\n\n\njar\n: is passed to \nrequest\n options. Remembers cookies for future use.\n\n\njson\n: will parse the \nresponse.body\n as JSON\n\n\njson\n: will parse the \nresponse.body\n as JSON\n\n\nresolveWithFullResponse\n: The full response will be return in the promise. It is compatible\n  with cheerio and json options.\n\n\n\n\nreq = requestFactory({\n   resolveWithFullResponse: true,\n   cheerio: true\n})\nreq('http://github.com', response =\n {\n  console.log(response.statusCode)\n  const $ = response.body\n  const repos = $('#repo_listing .repo')\n})\n\n\n\n\nYou can find the full list of available options in \nrequest-promise\n and \nrequest\n documentations.\n\n\n\n\nsaveBills\n\n\nCombines the features of \nsaveFiles\n, \nfilterData\n, \naddData\n and \nlinkBankOperations\n for a\ncommon case: bills.\nWill create \nio.cozy.bills\n objects. The default deduplication keys are \n['date', 'amount', 'vendor']\n.\nYou need the full permission on \nio.cozy.bills\n, full permission on \nio.cozy.files\n and also\nfull permission on \nio.cozy.bank.operations\n in your manifest, to be able to * use this function.\n\n\nParameters:\n\n\n\n\ndocuments\n is an array of objects with any attributes :\n\n\nfields\n (object) this is the first parameter given to BaseKonnector\ns constructor\n\n\noptions\n is passed directly to \nsaveFiles\n, \nhydrateAndFilter\n, \naddData\n and \nlinkBankOperations\n.\n\n\n\n\nconst { BaseKonnector, saveBills } = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(function fetch (fields) {\n  const documents = []\n  // some code which fills documents\n  return saveBills(documents, fields, {\n    identifiers: ['vendorj']\n  })\n})\n\n\n\n\n\n\nsaveFiles\n\n\nThe goal of this function is to save the given files in the given folder via the Cozy API.\nYou need the full permission on \nio.cozy.files\n in your manifest to use this function.\n\n\n\n\n\n\nfiles\n is an array of \n{ fileurl, filename }\n :\n\n\n\n\n\n\nfileurl: The url of the file. This attribute is mandatory or\n    this item will be ignored\n\n\n\n\n\n\nfilename : The file name of the item written on disk. This attribute is optional and as default value, the\n    file name will be \nsmartly\n guessed by the function. Use this attribute if the guess is not smart\n  enough for you.\n\n\n\n\n\n\nfolderPath\n (string) is relative to the main path given by the \ncozy-collect\n application to the connector. If the connector is run\nin standalone mode, the main path is the path of the connector.\n\n\n\n\n\n\noptions\n (object) is optional. Possible options :\n\n\n\n\n\n\ntimeout\n (timestamp) can be used if your connector needs to fetch a lot of files and if the\n  stack does not give enough time to your connector to fetch it all. It could happen that the\n  connector is stopped right in the middle of the download of the file and the file will be\n  broken. With the \ntimeout\n option, the \nsaveFiles\n function will check if the timeout has\n  passed right after downloading each file and then will be sure to be stopped cleanly if the\n  timeout is not too long. And since it is really fast to check that a file has already been\n  downloaded, on the next run of the connector, it will be able to download some more\n  files, and so on. If you want the timeout to be in 10s, do \nDate.now() + 10*1000\n.\n  You can try it in the previous code.\n\n\n\n\n\n\n\n\nupdateOrCreate\n\n\nThe goal of this function is create or update the given entries according to if they already\nexist in the cozy or not\nYou need the full permission for the given doctype in your manifest, to be able to\nuse this function.\n\n\nParameters:\n\n\n\n\nentries\n is an array of objects with any attributes :\n\n\ndoctype\n (string) is the cozy doctype where the entries should be saved\n\n\nmatchingAttributes\n (array of strings) is the list of attributes in each entry should be used to check if an entry\n  is already saved in the cozy\n\n\n\n\n\n\nBaseKonnector\n\n\nThe class from which all the connectors must inherit.\nIt takes a fetch function in parameter that must return a \nPromise\n.\nYou need at least the \nGET\n permission on \nio.cozy.accounts\n in your manifest to allow it to\nfetch account information for your connector.\n\n\nKind\n: global class  \n\n\n\n\nBaseKonnector\n\n\nnew BaseKonnector(fetch)\n\n\n.end()\n\n\n.fail()\n\n\n.init()\n \u21d2 \nPromise\n\n\n.saveAccountData(data, options)\n \u21d2 \nPromise\n\n\n.terminate(message)\n\n\n\n\n\n\n\n\n\n\nnew BaseKonnector(fetch)\n\n\nIts role is twofold :\n\n\n\n\nMake the link between account data and konnector\n\n\nHandle errors\n\n\n\n\n\u26a0\ufe0f  A promise should be returned from the \nfetch\n function otherwise\nthe konnector cannot know that asynchronous code has been called.\n\n\nthis.terminate('LOGIN_FAILED')\n\n\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfetch\n\n\nfunction\n\n\nFunction to be run automatically after account data is fetched. This function will be binded to the current connector. If not fetch function is given. The connector will have to handle itself it\ns own exection and error handling\n\n\n\n\n\n\n\n\nExample\n  \n\n\nconst { BaseKonnector } = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(function fetch () {\n // use this to access the instance of the konnector to\n // store any information that needs to be passed to\n // different stages of the konnector\n return request('http://ameli.fr')\n   .then(computeReimbursements)\n   .then(saveBills)\n})\n\n\n\n\n\n\nbaseKonnector.end()\n\n\nHook called when the connector is ended\n\n\nKind\n: instance method of \nBaseKonnector\n\n\n\n\nbaseKonnector.fail()\n\n\nHook called when the connector fails\n\n\nKind\n: instance method of \nBaseKonnector\n\n\n\n\nbaseKonnector.init() \u21d2 \nPromise\n\n\nInitializes the current connector with data comming from the associated account\n\n\nKind\n: instance method of \nBaseKonnector\n\n\nReturns\n: \nPromise\n - with the fields as an object\n\n\n\n\nbaseKonnector.saveAccountData(data, options) \u21d2 \nPromise\n\n\nSaves data to the account that is passed to the konnector.\nUse it to persist data that needs to be passed to each\nkonnector run.\n\n\nBy default, the data is merged to the remote data, use\n\noptions.merge = false\n to overwrite the data.\n\n\nThe data is saved under the \n.data\n attribute of the cozy\naccount.\n\n\nKind\n: instance method of \nBaseKonnector\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nobject\n\n\nAttributes to be merged\n\n\n\n\n\n\noptions\n\n\nobject\n\n\n{ merge: true\n\n\n\n\n\n\n\n\n\n\nbaseKonnector.terminate(message)\n\n\nSend a special error code which is interpreted by the cozy stack to terminate the execution of the\nconnector now\n\n\nKind\n: instance method of \nBaseKonnector\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nThe error code to be saved as connector result see [docs/ERROR_CODES.md]\n\n\n\n\n\n\n\n\n\n\nDocument\n\n\nSimple Model for Documents. Allows to specify\n\nshouldSave\n, \nshouldUpdate\n as methods.\n\n\nHas useful \nisEqual\n method\n\n\nKind\n: global class\n\n\n\n\ndocument.isEqual()\n\n\nCompares to another document deeply.\n\n\n_id\n and \n_rev\n are by default ignored in the comparison.\n\n\nBy default, will compare dates loosely since you often\ncompare existing documents (dates in ISO string) with documents\nthat just have been scraped where dates are \nDate\ns.\n\n\nKind\n: instance method of \nDocument\n\n\n\n\nLOGIN_FAILED : \nString\n\n\nThe konnector could not login\n\n\nKind\n: global constant\n\n\n\n\nNOT_EXISTING_DIRECTORY : \nString\n\n\nThe folder specified as folder_to_save does not exist (checked by BaseKonnector)\n\n\nKind\n: global constant\n\n\n\n\nVENDOR_DOWN : \nString\n\n\nThe vendor\ns website is down\n\n\nKind\n: global constant\n\n\n\n\nUSER_ACTION_NEEDED : \nString\n\n\nThere was an unexpected error, please take a look at the logs to know what happened\n\n\nKind\n: global constant\n\n\n\n\nFILE_DOWNLOAD_FAILED : \nString\n\n\nThere was a problem while downloading a file\n\n\nKind\n: global constant\n\n\n\n\nSAVE_FILE_FAILED : \nString\n\n\nThere was a problem while saving a file\n\n\nKind\n: global constant\n\n\n\n\nmkSpec()\n\n\nDeclarative scraping.\n\n\nDescribe your items attributes and where to find/parse them\ninstead of imperatively building them.\n\n\nHeavily inspired by \nartoo\n scraping method.\n\n\nKind\n: global function\n\n\n\n\nscrape($, spec(s), [childSelector]) \u21d2 \nobject\n | \narray\n\n\nScrape a cheerio object for properties\n\n\nKind\n: global function\n\n\nReturns\n: \nobject\n | \narray\n - - Item(s) scraped  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$\n\n\ncheerio\n\n\nCheerio node which will be scraped\n\n\n\n\n\n\nspec(s)\n\n\nobject\n | \nstring\n\n\nOptions object describing what you want to scrape\n\n\n\n\n\n\n[childSelector]\n\n\nstring\n\n\nIf passed, scrape will return an array of items\n\n\n\n\n\n\n\n\n\u26a0 Permissions\n\n\nPlease note that some classes require some permissions:\n\n\n\n\nio.cozy.accounts\n for the \nBaseKonnector\n class (\nGET\n only)\n\n\nio.cozy.files\n to save files\n\n\nio.cozy.bills\n to save bills\n\n\nio.cozy.bank.operations\n for \nlinkBankOperations", 
            "title": "API"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#modules", 
            "text": "addData  This function saves the data into the cozy blindly without check\nYou need at least the  POST  permission for the given doctype in your manifest, to be able to\nuse this function.  Parameters:   documents : an array of objects corresponding to the data you want to save in the cozy  doctype  (string): the doctype where you want to save data (ex:  io.cozy.bills )   const documents = [\n  {\n    name:  toto ,\n    height: 1.8\n  },\n  {\n    name:  titi ,\n    height: 1.7\n  }\n]\n\nreturn addData(documents,  io.cozy.height )   cozyClient  This is a  cozy-client-js  instance already initialized and ready to use  If you want to access cozy-client-js directly, this method gives you directly an instance of it,\ninitialized according to  COZY_URL  and  COZY_CREDENTIALS  environment variable given by cozy-stack\nYou can refer to the  cozy-client-js documentation  for more information.  Example :  const {cozyClient} = require( cozy-konnector-libs )\n\ncozyClient.data.defineIndex( my.doctype , [ _id ])   filterData  This function filters the passed array from data already present in the cozy so that there is\nnot duplicated data in the cozy.\nYou need at least the  GET  permission for the given doctype in your manifest, to be able to\nuse this function.  Parameters:   documents : an array of objects corresponding to the data you want to save in the cozy  doctype  (string): the doctype where you want to save data (ex:  io.cozy.bills )  options  :  keys  (array) : List of keys used to check that two items are the same. By default it is set to `[ id ] .  index  (optionnal) : Return value returned by  cozy.data.defineIndex , the default will correspond to all documents of the selected doctype.  selector  (optionnal object) : Mango request to get records. Default is built from the keys  {selector: {_id: { $gt : null}}}  to get all the records.     const documents = [\n  {\n    name:  toto ,\n    height: 1.8\n  },\n  {\n    name:  titi ,\n    height: 1.7\n  }\n]\n\nreturn filterData(documents,  io.cozy.height , {\n  keys: [ name ]\n}).then(filteredDocuments =  addData(filteredDocuments,  io.cozy.height ))   linkBankOperations", 
            "title": "Modules"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#classes", 
            "text": "BaseKonnector  The class from which all the connectors must inherit.\nIt takes a fetch function in parameter that must return a  Promise .\nYou need at least the  GET  permission on  io.cozy.accounts  in your manifest to allow it to\nfetch account information for your connector.   Document  Simple Model for Documents. Allows to specify shouldSave ,  shouldUpdate  as methods.  Has useful  isEqual  method", 
            "title": "Classes"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#constants", 
            "text": "LOGIN_FAILED  :  String  The konnector could not login   NOT_EXISTING_DIRECTORY  :  String  The folder specified as folder_to_save does not exist (checked by BaseKonnector)   VENDOR_DOWN  :  String  The vendor s website is down   USER_ACTION_NEEDED  :  String  There was an unexpected error, please take a look at the logs to know what happened   FILE_DOWNLOAD_FAILED  :  String  There was a problem while downloading a file   SAVE_FILE_FAILED  :  String  There was a problem while saving a file", 
            "title": "Constants"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#functions", 
            "text": "mkSpec()  Declarative scraping.  Describe your items attributes and where to find/parse them\ninstead of imperatively building them.  Heavily inspired by  artoo  scraping method.   scrape($, spec(s), [childSelector])  \u21d2  object  |  array  Scrape a cheerio object for properties", 
            "title": "Functions"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#adddata", 
            "text": "This function saves the data into the cozy blindly without check\nYou need at least the  POST  permission for the given doctype in your manifest, to be able to\nuse this function.  Parameters:   documents : an array of objects corresponding to the data you want to save in the cozy  doctype  (string): the doctype where you want to save data (ex:  io.cozy.bills )   const documents = [\n  {\n    name: 'toto',\n    height: 1.8\n  },\n  {\n    name: 'titi',\n    height: 1.7\n  }\n]\n\nreturn addData(documents, 'io.cozy.height')", 
            "title": "addData"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#cozyclient", 
            "text": "This is a  cozy-client-js  instance already initialized and ready to use  If you want to access cozy-client-js directly, this method gives you directly an instance of it,\ninitialized according to  COZY_URL  and  COZY_CREDENTIALS  environment variable given by cozy-stack\nYou can refer to the  cozy-client-js documentation  for more information.  Example :  const {cozyClient} = require('cozy-konnector-libs')\n\ncozyClient.data.defineIndex('my.doctype', ['_id'])", 
            "title": "cozyClient"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#filterdata", 
            "text": "This function filters the passed array from data already present in the cozy so that there is\nnot duplicated data in the cozy.\nYou need at least the  GET  permission for the given doctype in your manifest, to be able to\nuse this function.  Parameters:   documents : an array of objects corresponding to the data you want to save in the cozy  doctype  (string): the doctype where you want to save data (ex:  io.cozy.bills )  options  :  keys  (array) : List of keys used to check that two items are the same. By default it is set to `[ id ] .  index  (optionnal) : Return value returned by  cozy.data.defineIndex , the default will correspond to all documents of the selected doctype.  selector  (optionnal object) : Mango request to get records. Default is built from the keys  {selector: {_id: {\"$gt\": null}}}  to get all the records.   const documents = [\n  {\n    name: 'toto',\n    height: 1.8\n  },\n  {\n    name: 'titi',\n    height: 1.7\n  }\n]\n\nreturn filterData(documents, 'io.cozy.height', {\n  keys: ['name']\n}).then(filteredDocuments =  addData(filteredDocuments, 'io.cozy.height'))", 
            "title": "filterData"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#filterdatasuitablecall", 
            "text": "Since we can use methods or basic functions for shouldSave  and  shouldUpdate  we pass the\nappropriate  this  and  arguments .  If  funcOrMethod  is a method, it will be called\nwith args[0] as  this  and the rest as  arguments \nOtherwise,  this  will be null and  args  will be passed\nas  arguments .  Kind : inner method of  filterData", 
            "title": "filterData~suitableCall()"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#linkbankoperations", 
            "text": "", 
            "title": "linkBankOperations"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#linkbankoperations-entries-doctype-fields-options", 
            "text": "This function will soon move to a dedicated service. You should not use it.\nThe goal of this function is to find links between bills and bank operations.", 
            "title": "linkBankOperations ( entries, doctype, fields, options = {} )"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#requestfactory", 
            "text": "This is a function which returns an instance of request-promise  initialized with\ndefaults often used in connector development.  // Showing defaults\nreq = requestFactory({\n  cheerio: false,\n  jar: true,\n  json: true\n})  Options :   cheerio :  will parse automatically the  response.body  in a cheerio instance   req = requestFactory({ cheerio: true })\nreq('http://github.com', $ =  {\n  const repos = $('#repo_listing .repo')\n})   jar : is passed to  request  options. Remembers cookies for future use.  json : will parse the  response.body  as JSON  json : will parse the  response.body  as JSON  resolveWithFullResponse : The full response will be return in the promise. It is compatible\n  with cheerio and json options.   req = requestFactory({\n   resolveWithFullResponse: true,\n   cheerio: true\n})\nreq('http://github.com', response =  {\n  console.log(response.statusCode)\n  const $ = response.body\n  const repos = $('#repo_listing .repo')\n})  You can find the full list of available options in  request-promise  and  request  documentations.", 
            "title": "requestFactory"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#savebills", 
            "text": "Combines the features of  saveFiles ,  filterData ,  addData  and  linkBankOperations  for a\ncommon case: bills.\nWill create  io.cozy.bills  objects. The default deduplication keys are  ['date', 'amount', 'vendor'] .\nYou need the full permission on  io.cozy.bills , full permission on  io.cozy.files  and also\nfull permission on  io.cozy.bank.operations  in your manifest, to be able to * use this function.  Parameters:   documents  is an array of objects with any attributes :  fields  (object) this is the first parameter given to BaseKonnector s constructor  options  is passed directly to  saveFiles ,  hydrateAndFilter ,  addData  and  linkBankOperations .   const { BaseKonnector, saveBills } = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(function fetch (fields) {\n  const documents = []\n  // some code which fills documents\n  return saveBills(documents, fields, {\n    identifiers: ['vendorj']\n  })\n})", 
            "title": "saveBills"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#savefiles", 
            "text": "The goal of this function is to save the given files in the given folder via the Cozy API.\nYou need the full permission on  io.cozy.files  in your manifest to use this function.    files  is an array of  { fileurl, filename }  :    fileurl: The url of the file. This attribute is mandatory or\n    this item will be ignored    filename : The file name of the item written on disk. This attribute is optional and as default value, the\n    file name will be  smartly  guessed by the function. Use this attribute if the guess is not smart\n  enough for you.    folderPath  (string) is relative to the main path given by the  cozy-collect  application to the connector. If the connector is run\nin standalone mode, the main path is the path of the connector.    options  (object) is optional. Possible options :    timeout  (timestamp) can be used if your connector needs to fetch a lot of files and if the\n  stack does not give enough time to your connector to fetch it all. It could happen that the\n  connector is stopped right in the middle of the download of the file and the file will be\n  broken. With the  timeout  option, the  saveFiles  function will check if the timeout has\n  passed right after downloading each file and then will be sure to be stopped cleanly if the\n  timeout is not too long. And since it is really fast to check that a file has already been\n  downloaded, on the next run of the connector, it will be able to download some more\n  files, and so on. If you want the timeout to be in 10s, do  Date.now() + 10*1000 .\n  You can try it in the previous code.", 
            "title": "saveFiles"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#updateorcreate", 
            "text": "The goal of this function is create or update the given entries according to if they already\nexist in the cozy or not\nYou need the full permission for the given doctype in your manifest, to be able to\nuse this function.  Parameters:   entries  is an array of objects with any attributes :  doctype  (string) is the cozy doctype where the entries should be saved  matchingAttributes  (array of strings) is the list of attributes in each entry should be used to check if an entry\n  is already saved in the cozy", 
            "title": "updateOrCreate"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnector", 
            "text": "The class from which all the connectors must inherit.\nIt takes a fetch function in parameter that must return a  Promise .\nYou need at least the  GET  permission on  io.cozy.accounts  in your manifest to allow it to\nfetch account information for your connector.  Kind : global class     BaseKonnector  new BaseKonnector(fetch)  .end()  .fail()  .init()  \u21d2  Promise  .saveAccountData(data, options)  \u21d2  Promise  .terminate(message)", 
            "title": "BaseKonnector"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#new-basekonnectorfetch", 
            "text": "Its role is twofold :   Make the link between account data and konnector  Handle errors   \u26a0\ufe0f  A promise should be returned from the  fetch  function otherwise\nthe konnector cannot know that asynchronous code has been called.  this.terminate('LOGIN_FAILED')     Param  Type  Description      fetch  function  Function to be run automatically after account data is fetched. This function will be binded to the current connector. If not fetch function is given. The connector will have to handle itself it s own exection and error handling     Example     const { BaseKonnector } = require('cozy-konnector-libs')\n\nmodule.exports = new BaseKonnector(function fetch () {\n // use this to access the instance of the konnector to\n // store any information that needs to be passed to\n // different stages of the konnector\n return request('http://ameli.fr')\n   .then(computeReimbursements)\n   .then(saveBills)\n})", 
            "title": "new BaseKonnector(fetch)"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnectorend", 
            "text": "Hook called when the connector is ended  Kind : instance method of  BaseKonnector", 
            "title": "baseKonnector.end()"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnectorfail", 
            "text": "Hook called when the connector fails  Kind : instance method of  BaseKonnector", 
            "title": "baseKonnector.fail()"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnectorinit-promise", 
            "text": "Initializes the current connector with data comming from the associated account  Kind : instance method of  BaseKonnector  Returns :  Promise  - with the fields as an object", 
            "title": "baseKonnector.init() \u21d2 Promise"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnectorsaveaccountdatadata-options-promise", 
            "text": "Saves data to the account that is passed to the konnector.\nUse it to persist data that needs to be passed to each\nkonnector run.  By default, the data is merged to the remote data, use options.merge = false  to overwrite the data.  The data is saved under the  .data  attribute of the cozy\naccount.  Kind : instance method of  BaseKonnector        Param  Type  Description      data  object  Attributes to be merged    options  object  { merge: true", 
            "title": "baseKonnector.saveAccountData(data, options) \u21d2 Promise"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#basekonnectorterminatemessage", 
            "text": "Send a special error code which is interpreted by the cozy stack to terminate the execution of the\nconnector now  Kind : instance method of  BaseKonnector        Param  Type  Description      message  string  The error code to be saved as connector result see [docs/ERROR_CODES.md]", 
            "title": "baseKonnector.terminate(message)"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#document", 
            "text": "Simple Model for Documents. Allows to specify shouldSave ,  shouldUpdate  as methods.  Has useful  isEqual  method  Kind : global class", 
            "title": "Document"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#documentisequal", 
            "text": "Compares to another document deeply.  _id  and  _rev  are by default ignored in the comparison.  By default, will compare dates loosely since you often\ncompare existing documents (dates in ISO string) with documents\nthat just have been scraped where dates are  Date s.  Kind : instance method of  Document", 
            "title": "document.isEqual()"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#login_failed-string", 
            "text": "The konnector could not login  Kind : global constant", 
            "title": "LOGIN_FAILED : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#not_existing_directory-string", 
            "text": "The folder specified as folder_to_save does not exist (checked by BaseKonnector)  Kind : global constant", 
            "title": "NOT_EXISTING_DIRECTORY : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#vendor_down-string", 
            "text": "The vendor s website is down  Kind : global constant", 
            "title": "VENDOR_DOWN : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#user_action_needed-string", 
            "text": "There was an unexpected error, please take a look at the logs to know what happened  Kind : global constant", 
            "title": "USER_ACTION_NEEDED : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#file_download_failed-string", 
            "text": "There was a problem while downloading a file  Kind : global constant", 
            "title": "FILE_DOWNLOAD_FAILED : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#save_file_failed-string", 
            "text": "There was a problem while saving a file  Kind : global constant", 
            "title": "SAVE_FILE_FAILED : String"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#mkspec", 
            "text": "Declarative scraping.  Describe your items attributes and where to find/parse them\ninstead of imperatively building them.  Heavily inspired by  artoo  scraping method.  Kind : global function", 
            "title": "mkSpec()"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#scrape-specs-childselector-object-124-array", 
            "text": "Scrape a cheerio object for properties  Kind : global function  Returns :  object  |  array  - - Item(s) scraped       Param  Type  Description      $  cheerio  Cheerio node which will be scraped    spec(s)  object  |  string  Options object describing what you want to scrape    [childSelector]  string  If passed, scrape will return an array of items", 
            "title": "scrape($, spec(s), [childSelector]) \u21d2 object | array"
        }, 
        {
            "location": "/cozy-konnector-libs/api/#permissions", 
            "text": "Please note that some classes require some permissions:   io.cozy.accounts  for the  BaseKonnector  class ( GET  only)  io.cozy.files  to save files  io.cozy.bills  to save bills  io.cozy.bank.operations  for  linkBankOperations", 
            "title": "\u26a0 Permissions"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/", 
            "text": "CLI\n\n\ncozy-konnector-libs\n also comes with some cli tools which allow to run your connector in standalone\nor development mode\n\n\ncozy-konnector-standalone\n\n\nIf you just want to test your connector without any cozy available. Just add the following code in\nthe \nscripts\n section of your package.json file\n\n\n  scripts: {\n    standalone: \ncozy-konnector-standalone\n\n  }\n\n\n\n\nand run:\n\n\nyarn standalone\n\n\n\n\nThe requests to the cozy-stack will be stubbed using the [./fixture.json] file as source of data\nand when cozy-client-js is asked to create or update data, the data will be output to the console.\nThe bills (or any file) will be saved in the . directory.\n\n\nIt is possible to add an argument to this command which tells which file to run. Default is\ndefined in \npackage.json\n \nmain\n section or ./index.js\n\n\nIt is possible to record and replay the requests done by the standalone command using the\n\nreplay\n module.\n\n\nArguments\n\n\nUsage: cozy-konnector-standalone [options] \nfile\n\n\n\nOptions:\n\n  --record  Record all the requests in the ./fixtures directory using the replay module\n  --replay  Replay all the recorded requests\n  -h, --help  output usage information\n\n\n\n\ncozy-konnector-dev\n\n\nIf you want to run your connector linked to a cozy-stack, even remotely. Just add the follwing code\nin the \nscripts\n section of your package.json file:\n\n\n  scripts: {\n    dev: \ncozy-konnector-dev\n\n  }\n\n\n\n\nand run:\n\n\nyarn dev\n\n\n\n\nThis command will register your konnector as an OAuth application to the cozy-stack and then set the \nCOZY_CREDENTIALS\n and \nCOZY_FIELDS\n environment variable. By default,\nthe cozy-stack is supposed to be located in http://cozy.tools:8080. If this is not your case, just\nupdate the COZY_URL field in [./konnector-dev-config.json].\n\n\nAfter that, your konnector is running but should not work since you did not specify any credentials to\nthe target service. You can do this also in [./konnector-dev-config.json] in the \nfields\n section.\n\n\nThe files are saved in the root directory of your cozy by default.\n\n\nIt is also possible to add an argument to this command which tells which file to run. Default is\ndefined in \npackage.json\n \nmain\n section or ./index.js\n\n\nArguments\n\n\n$ cozy-konnector-dev \nfile\n [-t token.json] [-m manifest.webapp]\n\n\n\n\nAs for the \nstandalone\n command, you can specify which file to run. Default is \n./index.js\n.\n\n\n\n\n-t\n, \n--token\n : Specify where the token should be saved\n\n\n-m\n, \n--manifest\n : Specify the manifest.path that should be used for the permissions", 
            "title": "CLI"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/#cli", 
            "text": "cozy-konnector-libs  also comes with some cli tools which allow to run your connector in standalone\nor development mode", 
            "title": "CLI"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/#cozy-konnector-standalone", 
            "text": "If you just want to test your connector without any cozy available. Just add the following code in\nthe  scripts  section of your package.json file    scripts: {\n    standalone:  cozy-konnector-standalone \n  }  and run:  yarn standalone  The requests to the cozy-stack will be stubbed using the [./fixture.json] file as source of data\nand when cozy-client-js is asked to create or update data, the data will be output to the console.\nThe bills (or any file) will be saved in the . directory.  It is possible to add an argument to this command which tells which file to run. Default is\ndefined in  package.json   main  section or ./index.js  It is possible to record and replay the requests done by the standalone command using the replay  module.", 
            "title": "cozy-konnector-standalone"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/#arguments", 
            "text": "Usage: cozy-konnector-standalone [options]  file \n\n\nOptions:\n\n  --record  Record all the requests in the ./fixtures directory using the replay module\n  --replay  Replay all the recorded requests\n  -h, --help  output usage information", 
            "title": "Arguments"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/#cozy-konnector-dev", 
            "text": "If you want to run your connector linked to a cozy-stack, even remotely. Just add the follwing code\nin the  scripts  section of your package.json file:    scripts: {\n    dev:  cozy-konnector-dev \n  }  and run:  yarn dev  This command will register your konnector as an OAuth application to the cozy-stack and then set the  COZY_CREDENTIALS  and  COZY_FIELDS  environment variable. By default,\nthe cozy-stack is supposed to be located in http://cozy.tools:8080. If this is not your case, just\nupdate the COZY_URL field in [./konnector-dev-config.json].  After that, your konnector is running but should not work since you did not specify any credentials to\nthe target service. You can do this also in [./konnector-dev-config.json] in the  fields  section.  The files are saved in the root directory of your cozy by default.  It is also possible to add an argument to this command which tells which file to run. Default is\ndefined in  package.json   main  section or ./index.js", 
            "title": "cozy-konnector-dev"
        }, 
        {
            "location": "/cozy-konnector-libs/cli/#arguments_1", 
            "text": "$ cozy-konnector-dev  file  [-t token.json] [-m manifest.webapp]  As for the  standalone  command, you can specify which file to run. Default is  ./index.js .   -t ,  --token  : Specify where the token should be saved  -m ,  --manifest  : Specify the manifest.path that should be used for the permissions", 
            "title": "Arguments"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/", 
            "text": "Developing a konnector\n\n\nWithout an accessible cozy-stack\n\n\nIf you just want to test this connector without any cozy available.\n\n\nYou first need an installed [nodejs] (LTS version is fine).\n\n\nAnd the last version of yarn :\n\n\nnpm install --global yarn\n\n\n\n\nThen just run :\n\n\nyarn\nyarn standalone\n\n\n\n\nThe requests to the cozy-stack will be stubbed using the [./fixture.json] file as source of data\nand when cozy-client is asked to create or update data, the data will be output to the console.\nThe bills (or any file) will be saved in the . directory.\n\n\nWith the cozy-stack\n\n\nIf you do not want to have to install the konnector on a cozy v3 to test it, you can register the\nkonnector as an OAuth application with the following commands :\n\n\nyarn\nyarn dev\n\n\n\n\nThis command will register your konnector as an OAuth application to the cozy-stack. By default,\nthe cozy-stack is supposed to be located in http://cozy.tools:8080. If this is not your case, just\nupdate the COZY_URL field in [./konnector-dev-config.json].\n\n\nAfter that, your konnector is running but should not work since you did not specify any credentials to\nthe target service. You can do this also in [./konnector-dev-config.json] in the \nfields\n\nattribute.\n\n\nNow run \nyarn dev\n one more time, it should be ok.\n\n\nThe files are saved in the root directory of your cozy by default.\n\n\nHow does the cozy-stack run the connector ?\n\n\nThe cozy-stack runs the connector in a nsjail container to be sure it does not affect the environment.\n\n\nThe connector is run by calling yarn start with the following envrionment variables :\n\n\n\n\nCOZY_CREDENTIALS needs to be the result of \ncozy-stack instances token-cli \ninstance name\n \nscope\n\n\nCOZY_URL is the full http or https url to your cozy\n\n\nCOZY_FIELDS is something like :\n\n\n\n\n{\n  \ndata\n:{\n    \nattributes\n:{\n      \narguments\n:{\n        \naccount\n:\ncf31eaef5d899404a7e8c3737c1c2d1f\n,\n        \nfolder_to_save\n:\nfolderPathId\n,\n        \nslug\n:\nmykonnector\n\n      }\n    }\n  }\n}\n\n\n\n\nThe \naccount\n field is the id of the record with doctype \nio.cozy.accounts\n which will be used as\nparameters for your konnector.\n\n\nBuild (without Travis)\n\n\nTo be able to run the connector, the cozy stack needs a connector which is built into only one\nfile, without needing to install its dependencies, this will be a lot faster to install.\n\n\nThere is a command in package.json to help you to do that : \nyarn build\n\n\nThis command uses [webpack] to bundle all the code needed by your connector into one file.\n\n\nThis will generate an index.js file in the build directory and add all files the connector will need.\n\n\nYou can deploy this build by using the specific script : \nyarn deploy\n\n\nThis command will commit and push your build in the branch \nbuild\n fo your project.\n\n\nAnd your konnector can now be installed using the following url :\n\n\ngit://github.com/konnectors/cozy-konnector-\n.git#build\n\n\nBuild using Travis CI\n\n\nThis project contains a \n.travis.yml\n config file which allows you to build your connector\nautomatically using [Travis-CI][travis].\n\n\nYou can follow these steps to enable building using Travis:\n\n\n\n\nOn your [travis-ci.org][travis] account, find your project name (should be the same than your Github repository) and enable Travis by using the related checkbox.\n\n\nOnce enabled, go to this project on Travis by clicking on it and go to the \nSettings\n menu by using the \nMore options\n menu at the top right.\n\n\nEnable these three options:\n\n\nBuild only if .travis.yml is present\n\n\nBuild branch updates\n (run Travis after each branch update)\n\n\nBuild pull request updates\n (run Travis after each Pull Request update)\n\n\n\n\n\n\nThen, you have to generate a Github token in \nyour Github account settings\n. Here is the \nGithub blog post about API token\n. Don\nt forget to authorize the access to the repo scope like following: \n\n\nThen, add an environment variable (still in your Travis project settings) named \nGITHUB_TOKEN\n and use your previous generated Github token as value (We highly recommand you to \nkeep the checkbox \nDisplay value in build log\n to OFF value\n in order to keep your token value hidden in the Travis logs.)\n\n\n\n\nNow Travis is ready to build your project, it should build it each time your push a commit in your repository or create a pull request.\n\n\n\n\nNote:\n Travis will push your build to your \nbuild\n branch ONLY for commits made on your master branch (included PR merge commits). You can see the related Travis statement \nhere\n.\n\n\n\n\nAdd your new connector to \nCozy Collect\n\n\nThe Cozy Collect application will soon use an application store as source of connectors. But for\nnow, if you want to add your new connector to Cozy Collect, you can submit a message in the forum\nin the \ncollect section\n, and we will handle this for\nyou.", 
            "title": "Develop"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#developing-a-konnector", 
            "text": "", 
            "title": "Developing a konnector"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#without-an-accessible-cozy-stack", 
            "text": "If you just want to test this connector without any cozy available.  You first need an installed [nodejs] (LTS version is fine).  And the last version of yarn :  npm install --global yarn  Then just run :  yarn\nyarn standalone  The requests to the cozy-stack will be stubbed using the [./fixture.json] file as source of data\nand when cozy-client is asked to create or update data, the data will be output to the console.\nThe bills (or any file) will be saved in the . directory.", 
            "title": "Without an accessible cozy-stack"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#with-the-cozy-stack", 
            "text": "If you do not want to have to install the konnector on a cozy v3 to test it, you can register the\nkonnector as an OAuth application with the following commands :  yarn\nyarn dev  This command will register your konnector as an OAuth application to the cozy-stack. By default,\nthe cozy-stack is supposed to be located in http://cozy.tools:8080. If this is not your case, just\nupdate the COZY_URL field in [./konnector-dev-config.json].  After that, your konnector is running but should not work since you did not specify any credentials to\nthe target service. You can do this also in [./konnector-dev-config.json] in the  fields \nattribute.  Now run  yarn dev  one more time, it should be ok.  The files are saved in the root directory of your cozy by default.", 
            "title": "With the cozy-stack"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#how-does-the-cozy-stack-run-the-connector", 
            "text": "The cozy-stack runs the connector in a nsjail container to be sure it does not affect the environment.  The connector is run by calling yarn start with the following envrionment variables :   COZY_CREDENTIALS needs to be the result of  cozy-stack instances token-cli  instance name   scope  COZY_URL is the full http or https url to your cozy  COZY_FIELDS is something like :   {\n   data :{\n     attributes :{\n       arguments :{\n         account : cf31eaef5d899404a7e8c3737c1c2d1f ,\n         folder_to_save : folderPathId ,\n         slug : mykonnector \n      }\n    }\n  }\n}  The  account  field is the id of the record with doctype  io.cozy.accounts  which will be used as\nparameters for your konnector.", 
            "title": "How does the cozy-stack run the connector ?"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#build-without-travis", 
            "text": "To be able to run the connector, the cozy stack needs a connector which is built into only one\nfile, without needing to install its dependencies, this will be a lot faster to install.  There is a command in package.json to help you to do that :  yarn build  This command uses [webpack] to bundle all the code needed by your connector into one file.  This will generate an index.js file in the build directory and add all files the connector will need.  You can deploy this build by using the specific script :  yarn deploy  This command will commit and push your build in the branch  build  fo your project.  And your konnector can now be installed using the following url :  git://github.com/konnectors/cozy-konnector- .git#build", 
            "title": "Build (without Travis)"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#build-using-travis-ci", 
            "text": "This project contains a  .travis.yml  config file which allows you to build your connector\nautomatically using [Travis-CI][travis].  You can follow these steps to enable building using Travis:   On your [travis-ci.org][travis] account, find your project name (should be the same than your Github repository) and enable Travis by using the related checkbox.  Once enabled, go to this project on Travis by clicking on it and go to the  Settings  menu by using the  More options  menu at the top right.  Enable these three options:  Build only if .travis.yml is present  Build branch updates  (run Travis after each branch update)  Build pull request updates  (run Travis after each Pull Request update)    Then, you have to generate a Github token in  your Github account settings . Here is the  Github blog post about API token . Don t forget to authorize the access to the repo scope like following:   Then, add an environment variable (still in your Travis project settings) named  GITHUB_TOKEN  and use your previous generated Github token as value (We highly recommand you to  keep the checkbox  Display value in build log  to OFF value  in order to keep your token value hidden in the Travis logs.)   Now Travis is ready to build your project, it should build it each time your push a commit in your repository or create a pull request.   Note:  Travis will push your build to your  build  branch ONLY for commits made on your master branch (included PR merge commits). You can see the related Travis statement  here .", 
            "title": "Build using Travis CI"
        }, 
        {
            "location": "/cozy-konnector-libs/dev/#add-your-new-connector-to-cozy-collect", 
            "text": "The Cozy Collect application will soon use an application store as source of connectors. But for\nnow, if you want to add your new connector to Cozy Collect, you can submit a message in the forum\nin the  collect section , and we will handle this for\nyou.", 
            "title": "Add your new connector to Cozy Collect"
        }, 
        {
            "location": "/cozy-konnector-libs/errors/", 
            "text": "Communication with the outside\n\n\nKonnectors communicate with the stack via its stdout. Each line is parsed by the stack as JSON.\n\n\nWhen an error is thrown by the konnector, it is catched and translated to JSON.\n\n\nMessage types\n\n\nThis is the list of error codes that your konnector can \nthrow\n and which will be translated by the \ncollect\n application.\n\n\nExample :\n\n\nconst login = function () {\n  throw new Error('LOGIN_FAILED')\n}\n\n\n\n\nCollect\n will then signal to the user that the credentials used are not correct.\n\n\n\n\n\n\n\n\nError code\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nLOGIN_OK\n\n\nThe konnector has logged in\n\n\n\n\n\n\nLOGIN_FAILED\n\n\nThe konnector could not login\n\n\n\n\n\n\nNOT_EXISTING_DIRECTORY\n\n\nThe folder specified as folder_to_save does not exist (checked by BaseKonnector)\n\n\n\n\n\n\nVENDOR_DOWN\n\n\nThe vendor\ns website is down\n\n\n\n\n\n\nUSER_ACTION_NEEDED\n\n\nThe user needs to go to the vendor\ns website to fix something\n\n\n\n\n\n\nUNKNOWN_ERROR\n\n\nThere was an unexpected error, please take a look at the logs to know what happened\n\n\n\n\n\n\n\n\nSentry\n\n\nIf \nprocess.env.SENTRY_DSN\n is set :\n\n\n\n\nRaven will be configured to send exception to this address\n\n\nthe BaseKonnector will have its \nrun\n method wrapped into a \nRaven.context\n so that when it fails, it sends the exception to Raven before exiting.\n\n\n\n\nThe idea being that the \nprocess.env.SENTRY_DSN\n is only set up for people having opted in for exception handling. Self-hosted instances of the cozy-stack will be free to use or not our SENTRY_DSN.", 
            "title": "Errors"
        }, 
        {
            "location": "/cozy-konnector-libs/errors/#communication-with-the-outside", 
            "text": "Konnectors communicate with the stack via its stdout. Each line is parsed by the stack as JSON.  When an error is thrown by the konnector, it is catched and translated to JSON.", 
            "title": "Communication with the outside"
        }, 
        {
            "location": "/cozy-konnector-libs/errors/#message-types", 
            "text": "This is the list of error codes that your konnector can  throw  and which will be translated by the  collect  application.  Example :  const login = function () {\n  throw new Error('LOGIN_FAILED')\n}  Collect  will then signal to the user that the credentials used are not correct.     Error code  Meaning      LOGIN_OK  The konnector has logged in    LOGIN_FAILED  The konnector could not login    NOT_EXISTING_DIRECTORY  The folder specified as folder_to_save does not exist (checked by BaseKonnector)    VENDOR_DOWN  The vendor s website is down    USER_ACTION_NEEDED  The user needs to go to the vendor s website to fix something    UNKNOWN_ERROR  There was an unexpected error, please take a look at the logs to know what happened", 
            "title": "Message types"
        }, 
        {
            "location": "/cozy-konnector-libs/errors/#sentry", 
            "text": "If  process.env.SENTRY_DSN  is set :   Raven will be configured to send exception to this address  the BaseKonnector will have its  run  method wrapped into a  Raven.context  so that when it fails, it sends the exception to Raven before exiting.   The idea being that the  process.env.SENTRY_DSN  is only set up for people having opted in for exception handling. Self-hosted instances of the cozy-stack will be free to use or not our SENTRY_DSN.", 
            "title": "Sentry"
        }, 
        {
            "location": "/cozy-konnector-libs/operation-linking/", 
            "text": "Linking bank operations\n\n\nWhen bills are saved via saveBills, we try to find a bank operation\nthat matches it.\n\n\nCriterias for matching :\n\n\n\n\nLabel : the label of the operation must match an identifier provided in the\nkonnector\n\n\n\n\nFor example, for SFR mobile, the identifiers that we try to find in the label is\n\nsfr mobile\n. For SFR box, we try to find \nsfr fixe\n and \nsfr adsl\n. We try to\nfind without the case.\n\n\n\n\n\n\nDate : the date of the banking operation must be +- 15 days of the bill\n\n\n\n\n\n\nAmount : the amount of the banking operation must be +-0.001 of the original\nbill amount\n\n\n\n\n\n\nThose criterias can be changed by the konnector themselves.", 
            "title": "Operation linking"
        }, 
        {
            "location": "/cozy-konnector-libs/operation-linking/#linking-bank-operations", 
            "text": "When bills are saved via saveBills, we try to find a bank operation\nthat matches it.  Criterias for matching :   Label : the label of the operation must match an identifier provided in the\nkonnector   For example, for SFR mobile, the identifiers that we try to find in the label is sfr mobile . For SFR box, we try to find  sfr fixe  and  sfr adsl . We try to\nfind without the case.    Date : the date of the banking operation must be +- 15 days of the bill    Amount : the amount of the banking operation must be +-0.001 of the original\nbill amount    Those criterias can be changed by the konnector themselves.", 
            "title": "Linking bank operations"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/", 
            "text": "Table of contents\n\n\n\n\nKonnector synchronisation data and options\n\n\nProblems\n\n\nCurrent usage\n\n\nObjectives of this document\n\n\nStoring synchronization data in documents\n\n\nSimple case, by id\n\n\nBy multiple attributes\n\n\nBy custom method\n\n\n\n\n\n\nSaving document based on synchronization strategy\n\n\nAdding synchronization data\n\n\nFiltering entries\n\n\n\n\n\n\nSynchronization strategy\n\n\nfindLegacyDocument\n\n\ngetSyncData\n\n\nArray\n\n\nExample\n\n\n\n\n\n\nfunction\n\n\nExample\n\n\n\n\n\n\nkonnector\n\n\nshouldSave\n\n\nshouldUpdate\n\n\n\n\n\n\nWhole example\n\n\n\n\nKonnector synchronisation data and options\n\n\nProblems\n\n\nExcept bank konnectors which are already solving the addressed problem, all konnectors are currently processing data they are collecting in the same way:\n\n\n\n\nGet all data to synchronize\n\n\nStore it in CouchDB, even if it means overriding previously synchronized data.\n\n\n\n\nThis process has at least two major flows :\n\n We are always synchronizing \nall\n the data provided by the external service.\n\n When something is modified (for example, the name of the stored file, it\ns almost sure that the previous one will be kept and that we\nll have a duplicate)\n\n\nAnother side effect could be that in a very large set of documents to synchronize, the whole process may take more than 3 minutes and never synchronize documents at the end of the list.\n\n\nCurrent usage\n\n\nWhen saving bills, \ncozy-konnector-libs\n provides a filtering and hydratation mechanism, to avoid overriding existing bills. It is done in function \nhydrateAndFilters\n.\n\n\nThis method performs two actions :\n\n hydrate entries retrieved from service with usable data from couchDB (like existing bill id)\n\n filter entries retrieved from service and return only entries that need to be saved/synchronized.\n\n\nObjectives of this document\n\n\nThe goals of this document are:\n\n\n\n\nDefine a common way to store synchronization data for all konnector\n\n\nPropose a naive implementation for an abstract synchronisation data storing mechanism, provided by \ncozy-konnector-libs\n\n\nPropose a solution to synchronize every type of data or file, not only bills\n\n\nTaking the \nhydrateAndFilter\n function as basis, split it in three functions performing the following tasks : actual filtering, synchronization data hydratation and saving/updating current database document with correspondig external entries (the part done by the actual \nhydratation\n)\n\n\n\n\nStoring synchronization data in documents\n\n\nBefore saving any data or file, we will add in the relying document every synchronization data we will need. The added data will depend on how the service the konnector connects to retrieve entries and which information they gave us.\n\n\nSimple case, by id\n\n\nWe suppose that in the most cases, we will face to entries provinding their own \nid\n attribute. The idea is to store it as synchronization data to be able to easily retrieve them later.\nTo store synchronization data, we are using a \nsync\n attribute in document \nmetadata\n attribute. Example:\n\n\n{\n  \nmetadata\n: {\n    \nsync\n: {\n      \nid\n: \n7ee401e841c94159addb47f190903139\n,\n      \nkonnector\n: \ntrainline\n,\n      \nlast_sync\n: \nMon, 12 Feb 2018 16:25:34 GMT\n\n    }\n  }\n}\n\n\n\n\nThe expected information to be save is:\n\n\n\n\n\n\n\n\nfield\n\n\nrole\n\n\n\n\n\n\n\n\n\n\nid\n\n\nThe id of the document, but given by the external service. If the external service does not provide any id or uuid, it could be interesting to generate one, with an hash of the file for example.\n\n\n\n\n\n\nkonnector\n\n\nThe slug of the konnector (Example: \ntrainline\n, \nfreemobile\n, \ncic\n). This could be very useful to retrieve data synchronized with this konnector.\n\n\n\n\n\n\nlast_sync\n\n\nDate of last synchronization, set to \nnow()\n when storage is made.\n\n\n\n\n\n\n\n\nBy multiple attributes\n\n\nIf the external service does not provide any \nid\n attribute, we may need to use instead a list of attributes, for example \nfirstname\n, \nlastname\n, \ndateofbirth\n.\n\n\n{\n  \nmetadata\n: {\n    \nsync\n: {\n      \nfirstname\n: \nClaude\n,\n      \nlastname\n: \nCausi\n,\n      \ndateofbirth\n: \n06/12/1980\n\n    }\n  }\n}\n\n\n\n\nAs we cannot be sure that we will have different data, it could be better to use a custom way of providing an unique identifier.\n\n\nBy custom method\n\n\nWhen the external service does not provide any identifier, we have to use a custom method to generate one.\nIt could be for example the filename or a hash generated with the document content.\n\n\n{\n  \nmetadata\n: {\n    \nsync\n: {\n      \nid:\n: \ncustomhash34FED5465645ABF54656FCB\n\n    }\n  }\n}\n\n\n\n\nSaving document based on synchronization strategy\n\n\nTo solve the synchronization process weed need to:\n\n be able to add synchronization data on any type of document\n\n be able to compare external entries to current database state\n* provide a default implementation while letting the contributors to define their own ones\n\n\nAdding synchronization data\n\n\nWe should provide an \naddSyncData\n function could, which look like this (naive implementation, this piece of code needs to be improved to handle cases where \nsynchronizationStrategy.idAttribute\n is an array or a function):\n\n\nconst addSyncData = (document, entry, synchronizationStrategy) =\n {\n  return {\n    ...document,\n    metadata: {\n      ...document.metadata,\n      id: entry[synchronizationStrategy.idAttribute]\n    }\n}\n````\n\nWhere `document` is the future document to save, `entry` the corresponding external entry, and `synchronizationStrategy` and object defining the synchronization properties and methods (see below).\n\n### Filtering entries\n\nNow we have saved our documents in database with consistent synchronization metadata, we need to provide a way to filter external entries.\n\nWe should provide a `filterEntriesToSynchronize` which returns a list of entries with new data or data to update.\n\nAs `addSyncData`, this method will receive a `synchronizationStrategy`. The filtering algorithm should be based on the returned value of `synchronizationStrategy.shouldSave` and `synchronizationStrategy.shouldUpdate`.\n\n\n \u26a0\ufe0f As the `synchronizationStrategy.shouldSave` and `synchronizationStrategy.shouldUpdate` will be asynchronous methods, `filterEntriesToSynchronize` should also be asynchronous.\n\nA naive example of `filterEntriesToSynchronize` implementation should be:\n\n```js\nconst filterEntriesToSynchronize = async (cozy, entries, synchronizationStrategy) = {\n  const filtered = []\n\n  // getExistingSynchronizedDocument needs to be implemented, it should retrieve\n  // existing document from database, based on synchronization data.\n  const existingDocument = cozy.getExistingSynchronizedDocument(entry, synchronizationStrategy)\n\n  entries.forEach(entry =\n {\n    const toSave = await synchronizationStrategy.shouldSave(entry, existingDocument)\n    const toUpdate = await synchronizationStrategy.shouldUpdate(entry, existingDocument)\n\n    if (toSave || toUpdate) filtered.push(entry)\n  })\n\n  return filtered\n}\n\n\n\n\nSynchronization strategy\n\n\nFor our functions or methods dealing with synchronization, we pass a \nsynchronizationStrategy\n object. Internally, we will use a default one but let the ability to contributors to pass their own ones.\n\n\nIt is a simple object containing the following properties:\n\n\n\n\n\n\n\n\nOption\n\n\nRole\n\n\n\n\n\n\n\n\n\n\ndisableSyncData\n\n\n(boolean) Disable storage of  synchronization data. Default: \nfalse\n\n\n\n\n\n\nfindLegacyDocument\n\n\n(function) Custom function which a konnector may use to look for a legacy document. Default is \nnull\n. See below for more details.\n\n\n\n\n\n\ngetSyncData\n\n\n(function) A mapping method returning additional synchronization data which have to be added to the document.\n\n\n\n\n\n\nidAttribute\n\n\n(string\nArray\nfunction) How the identifier attribute is named in the entry. Default value: \nid\n. See below for additional customization\n\n\n\n\n\n\nkonnector\n\n\nMandatory\n (string) The slug (or better, an uuid) of the current konnector.\n\n\n\n\n\n\nshouldSave\n\n\n(function) A method taking current entry and matching document in database to evaluate if an entry has to be saved in database. See below default method and customization.\n\n\n\n\n\n\nshouldUpdate\n\n\n(function) A method taking current entry and matching document in database to evaluate if a document must be updated with current entry. See below for default method and customization.\n\n\n\n\n\n\n\n\nfindLegacyDocument\n\n\nIf a document has not been saved yet with actual synchronization data, we will have no way to retrieve it, except by providing a \nfindLegacyDocument\n function to \nsaveEntry\n options. This signature of a \nfindLegacyDocument\n function is:\n\n\nasync function (entry, cozy) =\n { /* look for your document */ }\n````\n\nThe `cozy` parameter is an instance of Cozy-Client.\n\nThe idea is for example to retrive a document by its file path or any other accurate information.\n\n### getSyncData\nThis method returns any addtional synchronization data the konnector should need. Default method should be something returning an empty object or `null`.\n\n```js\n(entry) =\n ({})\n\n\n\n\nA konnector should provide its own method:\n\n\n{\n  getSyncData: (entry) =\n ({\n    filename: entry.name\n  })\n}```\n\n### idAttribute\n#### String\nName of the id attribute in entry. Default is `id`. If we want to use another name, we may use:\n```js\nsaveFiles(files, {idAttribute: 'uuid'})\n\n\n\n\nArray\n\n\nThis attribute may also be an array of string, defining each entry attribute which must be used for identifier.\n\n\nExample\n\n\nsaveFiles(files, {idAttribute: ['name', 'author', 'date']})\n\n\n\n\nIn this case, all fields are used in synchronization data.\n\n\nfunction\n\n\nWhen an entry does not provide an unique identifer, it is possible to use a function as \nidAttribute\n to customize the way the unique identifer is generated.\n\n\nExample\n\n\naddData(file, {idAttribute: (entry) =\n hash(entry)})\n// hash() is a custom method  hashing the current file.\n\n\n\n\nkonnector\n\n\nThe konnector attribute is used as a key reference to retrieve all document synchronized by this konnector.\n\n\nFor now, the \nkonnector\n option will be needed for every call. But it could be interesting to initialize some kind of runner with it, which may encapsulate all the \ncozy-konnector-libs\n functions.\n\n\nshouldSave\n\n\nThe shouldSave function returns a boolean which indicate if the entry should be saved. The default method should be:\n\n\nasync function shouldSave (entry, existingDocument, cozy) =\n {\n  return Promise.resolve(!existingDocument)\n}\n\n\n\n\nWhen calling this function, it is assumed that \ncozy-konnector-libs\n first queries the database for an exisring document, based on synchronization data and pass the document resulting the query to the \nshouldSave\n function, event if this document is \nnull\n. We pass the whole document, and not only synchronization data, to let the contributors free on their way they are determining it a document should be saved.\n\n\nAs a third parameter, a cozyClient instance is passed, it may be used by a konnector to perform another query.\n\n\nBecause of this third parameter, the whole \nshouldSave\n method is asynchronous.\n\n\nshouldUpdate\n\n\nThe \nshouldUpdate\n function acts exactly like \nshouldSave\n, except that it is used to determine if a document should be updated. By default, we make the choice to never update a document (except if it does not have synchronization data, see \nfindLegacyDocument\n above). But some konnectors like \nLinxo\n related ones need to update existing documents.\n\n\nThe default method is:\n\n\nasync function shouldUpdate (entry, existingDocument, cozy) {\n  // Update an existing document only if it does not have synchronization data\n  const hasSyncData = !!existingDocument \n !!existingDocument.metadata \n !! existingDocument.metadata.sync\n  return Promise.resolve(!hasSyncData)\n}\n````\n\n## Whole example\n\nAs the way data are saved from `cozy-konnector-libs` differs based on data type, we let the saving mechanism to others functions or methods. For example, in existing codebase, bills are saved in a specific way, resulting in two documents in database. However, we could provide top-level functions or methods, like `synchronizeBills` or a more generic `synchronizeData`.\n\nHere is a whole and naive example of how `synchronizeBills` could be implemebted:\n\n```js\nconst synchronizeBills = async (cozy, entries, synchronizationStrategy) =\n {\n  return await filteredEntries = await filterEntriesToSynchronize(cozy, entries, synchronizationStrategy)\n    .then(filteredEntries =\n filteredEntries.map(entry =\n addSyncData(entry, synchronizationStrategy)))\n    // existing saveBills method (with maybe some little changes)\n    .saveBills(synchronizedDocuments)\n}\n\n\n\n\nUsage could be:\n\n\nsynchronizeBills(cozy, entries, {\n  findLegacyDocument: (entry, cozy) =\n {\n    return cozy.files.statByPath(getEntryPath(entry))\n  },\n  getSyncData: (file) =\n ({\n    fileName: file.name\n  }),\n  idAttribute: 'uuid',\n  konnector: 'myservice',\n  shouldSave: (file) =\n {\n    // For whatever reason we only save files created after 2010\n    return Promise.resolve(moment(file.creationDate).year().isAfter(2010))\n  },\n  shouldUpdate: (file, existingDocument) =\n {\n    const hasBeenModified = moment(file.modificationDate).isAfter(existingDocument.metadata.sync.last_sync)\n    return Promise.resolve(hasBeenModified)\n  }\n})\n\n\n\n\nEvery synchronized document will contain:\n\n\n{\n  \nmetadata\n: {\n    \nsync\n: {\n      \nkonnector\n: \nmyservice\n,\n      \nid\n: \nentry_id\n,\n      \nlast_sync\n: \nnow\n,\n      \nfileName\n: \nfileName\n\n    }\n  }\n}", 
            "title": "Synchronization"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#table-of-contents", 
            "text": "Konnector synchronisation data and options  Problems  Current usage  Objectives of this document  Storing synchronization data in documents  Simple case, by id  By multiple attributes  By custom method    Saving document based on synchronization strategy  Adding synchronization data  Filtering entries    Synchronization strategy  findLegacyDocument  getSyncData  Array  Example    function  Example    konnector  shouldSave  shouldUpdate    Whole example", 
            "title": "Table of contents"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#konnector-synchronisation-data-and-options", 
            "text": "", 
            "title": "Konnector synchronisation data and options"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#problems", 
            "text": "Except bank konnectors which are already solving the addressed problem, all konnectors are currently processing data they are collecting in the same way:   Get all data to synchronize  Store it in CouchDB, even if it means overriding previously synchronized data.   This process has at least two major flows :  We are always synchronizing  all  the data provided by the external service.  When something is modified (for example, the name of the stored file, it s almost sure that the previous one will be kept and that we ll have a duplicate)  Another side effect could be that in a very large set of documents to synchronize, the whole process may take more than 3 minutes and never synchronize documents at the end of the list.", 
            "title": "Problems"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#current-usage", 
            "text": "When saving bills,  cozy-konnector-libs  provides a filtering and hydratation mechanism, to avoid overriding existing bills. It is done in function  hydrateAndFilters .  This method performs two actions :  hydrate entries retrieved from service with usable data from couchDB (like existing bill id)  filter entries retrieved from service and return only entries that need to be saved/synchronized.", 
            "title": "Current usage"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#objectives-of-this-document", 
            "text": "The goals of this document are:   Define a common way to store synchronization data for all konnector  Propose a naive implementation for an abstract synchronisation data storing mechanism, provided by  cozy-konnector-libs  Propose a solution to synchronize every type of data or file, not only bills  Taking the  hydrateAndFilter  function as basis, split it in three functions performing the following tasks : actual filtering, synchronization data hydratation and saving/updating current database document with correspondig external entries (the part done by the actual  hydratation )", 
            "title": "Objectives of this document"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#storing-synchronization-data-in-documents", 
            "text": "Before saving any data or file, we will add in the relying document every synchronization data we will need. The added data will depend on how the service the konnector connects to retrieve entries and which information they gave us.", 
            "title": "Storing synchronization data in documents"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#simple-case-by-id", 
            "text": "We suppose that in the most cases, we will face to entries provinding their own  id  attribute. The idea is to store it as synchronization data to be able to easily retrieve them later.\nTo store synchronization data, we are using a  sync  attribute in document  metadata  attribute. Example:  {\n   metadata : {\n     sync : {\n       id :  7ee401e841c94159addb47f190903139 ,\n       konnector :  trainline ,\n       last_sync :  Mon, 12 Feb 2018 16:25:34 GMT \n    }\n  }\n}  The expected information to be save is:     field  role      id  The id of the document, but given by the external service. If the external service does not provide any id or uuid, it could be interesting to generate one, with an hash of the file for example.    konnector  The slug of the konnector (Example:  trainline ,  freemobile ,  cic ). This could be very useful to retrieve data synchronized with this konnector.    last_sync  Date of last synchronization, set to  now()  when storage is made.", 
            "title": "Simple case, by id"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#by-multiple-attributes", 
            "text": "If the external service does not provide any  id  attribute, we may need to use instead a list of attributes, for example  firstname ,  lastname ,  dateofbirth .  {\n   metadata : {\n     sync : {\n       firstname :  Claude ,\n       lastname :  Causi ,\n       dateofbirth :  06/12/1980 \n    }\n  }\n}  As we cannot be sure that we will have different data, it could be better to use a custom way of providing an unique identifier.", 
            "title": "By multiple attributes"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#by-custom-method", 
            "text": "When the external service does not provide any identifier, we have to use a custom method to generate one.\nIt could be for example the filename or a hash generated with the document content.  {\n   metadata : {\n     sync : {\n       id: :  customhash34FED5465645ABF54656FCB \n    }\n  }\n}", 
            "title": "By custom method"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#saving-document-based-on-synchronization-strategy", 
            "text": "To solve the synchronization process weed need to:  be able to add synchronization data on any type of document  be able to compare external entries to current database state\n* provide a default implementation while letting the contributors to define their own ones", 
            "title": "Saving document based on synchronization strategy"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#adding-synchronization-data", 
            "text": "We should provide an  addSyncData  function could, which look like this (naive implementation, this piece of code needs to be improved to handle cases where  synchronizationStrategy.idAttribute  is an array or a function):  const addSyncData = (document, entry, synchronizationStrategy) =  {\n  return {\n    ...document,\n    metadata: {\n      ...document.metadata,\n      id: entry[synchronizationStrategy.idAttribute]\n    }\n}\n````\n\nWhere `document` is the future document to save, `entry` the corresponding external entry, and `synchronizationStrategy` and object defining the synchronization properties and methods (see below).\n\n### Filtering entries\n\nNow we have saved our documents in database with consistent synchronization metadata, we need to provide a way to filter external entries.\n\nWe should provide a `filterEntriesToSynchronize` which returns a list of entries with new data or data to update.\n\nAs `addSyncData`, this method will receive a `synchronizationStrategy`. The filtering algorithm should be based on the returned value of `synchronizationStrategy.shouldSave` and `synchronizationStrategy.shouldUpdate`.  \u26a0\ufe0f As the `synchronizationStrategy.shouldSave` and `synchronizationStrategy.shouldUpdate` will be asynchronous methods, `filterEntriesToSynchronize` should also be asynchronous.\n\nA naive example of `filterEntriesToSynchronize` implementation should be:\n\n```js\nconst filterEntriesToSynchronize = async (cozy, entries, synchronizationStrategy) = {\n  const filtered = []\n\n  // getExistingSynchronizedDocument needs to be implemented, it should retrieve\n  // existing document from database, based on synchronization data.\n  const existingDocument = cozy.getExistingSynchronizedDocument(entry, synchronizationStrategy)\n\n  entries.forEach(entry =  {\n    const toSave = await synchronizationStrategy.shouldSave(entry, existingDocument)\n    const toUpdate = await synchronizationStrategy.shouldUpdate(entry, existingDocument)\n\n    if (toSave || toUpdate) filtered.push(entry)\n  })\n\n  return filtered\n}", 
            "title": "Adding synchronization data"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#synchronization-strategy", 
            "text": "For our functions or methods dealing with synchronization, we pass a  synchronizationStrategy  object. Internally, we will use a default one but let the ability to contributors to pass their own ones.  It is a simple object containing the following properties:     Option  Role      disableSyncData  (boolean) Disable storage of  synchronization data. Default:  false    findLegacyDocument  (function) Custom function which a konnector may use to look for a legacy document. Default is  null . See below for more details.    getSyncData  (function) A mapping method returning additional synchronization data which have to be added to the document.    idAttribute  (string Array function) How the identifier attribute is named in the entry. Default value:  id . See below for additional customization    konnector  Mandatory  (string) The slug (or better, an uuid) of the current konnector.    shouldSave  (function) A method taking current entry and matching document in database to evaluate if an entry has to be saved in database. See below default method and customization.    shouldUpdate  (function) A method taking current entry and matching document in database to evaluate if a document must be updated with current entry. See below for default method and customization.", 
            "title": "Synchronization strategy"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#findlegacydocument", 
            "text": "If a document has not been saved yet with actual synchronization data, we will have no way to retrieve it, except by providing a  findLegacyDocument  function to  saveEntry  options. This signature of a  findLegacyDocument  function is:  async function (entry, cozy) =  { /* look for your document */ }\n````\n\nThe `cozy` parameter is an instance of Cozy-Client.\n\nThe idea is for example to retrive a document by its file path or any other accurate information.\n\n### getSyncData\nThis method returns any addtional synchronization data the konnector should need. Default method should be something returning an empty object or `null`.\n\n```js\n(entry) =  ({})  A konnector should provide its own method:  {\n  getSyncData: (entry) =  ({\n    filename: entry.name\n  })\n}```\n\n### idAttribute\n#### String\nName of the id attribute in entry. Default is `id`. If we want to use another name, we may use:\n```js\nsaveFiles(files, {idAttribute: 'uuid'})", 
            "title": "findLegacyDocument"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#array", 
            "text": "This attribute may also be an array of string, defining each entry attribute which must be used for identifier.", 
            "title": "Array"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#example", 
            "text": "saveFiles(files, {idAttribute: ['name', 'author', 'date']})  In this case, all fields are used in synchronization data.", 
            "title": "Example"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#function", 
            "text": "When an entry does not provide an unique identifer, it is possible to use a function as  idAttribute  to customize the way the unique identifer is generated.", 
            "title": "function"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#example_1", 
            "text": "addData(file, {idAttribute: (entry) =  hash(entry)})\n// hash() is a custom method  hashing the current file.", 
            "title": "Example"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#konnector", 
            "text": "The konnector attribute is used as a key reference to retrieve all document synchronized by this konnector.  For now, the  konnector  option will be needed for every call. But it could be interesting to initialize some kind of runner with it, which may encapsulate all the  cozy-konnector-libs  functions.", 
            "title": "konnector"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#shouldsave", 
            "text": "The shouldSave function returns a boolean which indicate if the entry should be saved. The default method should be:  async function shouldSave (entry, existingDocument, cozy) =  {\n  return Promise.resolve(!existingDocument)\n}  When calling this function, it is assumed that  cozy-konnector-libs  first queries the database for an exisring document, based on synchronization data and pass the document resulting the query to the  shouldSave  function, event if this document is  null . We pass the whole document, and not only synchronization data, to let the contributors free on their way they are determining it a document should be saved.  As a third parameter, a cozyClient instance is passed, it may be used by a konnector to perform another query.  Because of this third parameter, the whole  shouldSave  method is asynchronous.", 
            "title": "shouldSave"
        }, 
        {
            "location": "/cozy-konnector-libs/synchronization/#shouldupdate", 
            "text": "The  shouldUpdate  function acts exactly like  shouldSave , except that it is used to determine if a document should be updated. By default, we make the choice to never update a document (except if it does not have synchronization data, see  findLegacyDocument  above). But some konnectors like  Linxo  related ones need to update existing documents.  The default method is:  async function shouldUpdate (entry, existingDocument, cozy) {\n  // Update an existing document only if it does not have synchronization data\n  const hasSyncData = !!existingDocument   !!existingDocument.metadata   !! existingDocument.metadata.sync\n  return Promise.resolve(!hasSyncData)\n}\n````\n\n## Whole example\n\nAs the way data are saved from `cozy-konnector-libs` differs based on data type, we let the saving mechanism to others functions or methods. For example, in existing codebase, bills are saved in a specific way, resulting in two documents in database. However, we could provide top-level functions or methods, like `synchronizeBills` or a more generic `synchronizeData`.\n\nHere is a whole and naive example of how `synchronizeBills` could be implemebted:\n\n```js\nconst synchronizeBills = async (cozy, entries, synchronizationStrategy) =  {\n  return await filteredEntries = await filterEntriesToSynchronize(cozy, entries, synchronizationStrategy)\n    .then(filteredEntries =  filteredEntries.map(entry =  addSyncData(entry, synchronizationStrategy)))\n    // existing saveBills method (with maybe some little changes)\n    .saveBills(synchronizedDocuments)\n}  Usage could be:  synchronizeBills(cozy, entries, {\n  findLegacyDocument: (entry, cozy) =  {\n    return cozy.files.statByPath(getEntryPath(entry))\n  },\n  getSyncData: (file) =  ({\n    fileName: file.name\n  }),\n  idAttribute: 'uuid',\n  konnector: 'myservice',\n  shouldSave: (file) =  {\n    // For whatever reason we only save files created after 2010\n    return Promise.resolve(moment(file.creationDate).year().isAfter(2010))\n  },\n  shouldUpdate: (file, existingDocument) =  {\n    const hasBeenModified = moment(file.modificationDate).isAfter(existingDocument.metadata.sync.last_sync)\n    return Promise.resolve(hasBeenModified)\n  }\n})  Every synchronized document will contain:  {\n   metadata : {\n     sync : {\n       konnector :  myservice ,\n       id :  entry_id ,\n       last_sync :  now ,\n       fileName :  fileName \n    }\n  }\n}", 
            "title": "shouldUpdate"
        }, 
        {
            "location": "/cozy-client-js/intro/", 
            "text": "{% raw %}\n\n\nIntroduction to cozy-client-js\n\n\nReminder about cozy architectures\n\n\nThere is two actives cozy architectures:\n\n\n\n\nThe first, thereafter named \nv2\n is the existing cozy structure. It\ns based on 1 container / user with many node.js processes in each container (cozy-data-system, cozy-proxy, cozy-home, 1 process per app).\n\n\nThe second, thereafter named \nv3\n is the new cozy-stack (\nrepository\n). It\ns based on go and aim to support multiple user on a single process.\n\n\n\n\nv2\n supported both \nserver-side\n applications with their own node.js process and \nclient-side\n applications which run in the user browser.\n\n\nv3\n will not support \nserver-side\n applications. We will support server side modules managed by server administrator, but the applications themselves will all be \nclient-side\n application.\n\n\nThis repository provides a library which allows you to build a \nclient-side\n application compatible with both version.\n\n\nThe former javascript library for making client-side application was \ncozy-browser-sdk\n. We aim to deprecate it once \ncozy-client-js\n reaches feature-parity.\n\n\nIf you already have an application using \ncozy-browser-sdk\n, you can see what will change in the \ntransition document\n. If you have any doubt, please open an issue!\n\n\nInclude the library in your application\n\n\nYou can \nimport\n/\nrequire\n cozy-client-js using npm \n webpack.\n\n\nYou can also copy-paste the \ndist/cozy-client.js\n bundle file into your application, and include it in your application \nindex.html\n with \nscript src=\"./cozy-client.js\"\n.\n\n\nIf you are developing a client-side app for Cozy V3, you can import the lib directly from the stack, by using \n{{.CozyClientJS}}\n.\n\n\nIf you are developing a nodejs app, you will need some polyfills. You can add them to your project with this command:\n\n\n$ yarn add isomorphic-fetch core-js regenerator-runtime btoa\n\n\n\n\nDoctypes \n Permissions\n\n\nA doctype is a simple javascript string identifying a type of document.\nSome basic doctypes are provided by cozy, but you can pick your own.\n\n\nCozy \nv3\n expects doctypes to be qualified to ensure uniqueness.\n\n\nAll doctypes designed by the cozy\ns team will be prefixed with \nio.cozy.\n, or \nio.cozy.labs.\n\n\nAny doctype you introduce is expected to be prefixed with the reverse notation of a domain you own (JLS#7.7). If you do not own a domain, you can also use a reverse notation of your email address.\n\n\nYou are free to reuse another applications documents by using their doctypes but you \nSHOULD\n discuss with the domain owner if you want to add fields or format them differently.\n\n\nTo ensure retrocompatibility, when used on stack v2, all known doctypes will be auto-prefixed, but a warning will be written to the console. Unknown doctype will cause a fatal error. DO NOT rely on this behaviour in new applications, use qualified doctypes.\n\n\n// contacts is a doctype defined by cozy\ncozyContactsDoctype = \nio.cozy.contacts\n\n// your application handle books, let's create a doctype\nmyBooksDoctype = \ncom.mydomain.book\n\n\n\n\nWhen you use a doctype, even one created by your application, you need to ask for its permission in your manifest. How to do it depends on which stack you are developping for.\n\n\nTODO\n Have some docs about \nv2\n package.json vs \nv3\n manifest.webapp\n\n\nPromises \n Callbacks\n\n\nAll cozy-client-js functions support callback or promise.\n\n\nIf no callback is provided, a promise is returned.\n\n\ncozy.client.data.create(myBooksDoctype, doc)\n    .then(function(result){ console.log('done', result); });\n    .catch(function(err){ console.log('fail', err); });\n\n\n\n\nIf your build pipeline supports it, use async/await for sweet sweet async\n\n\ntry {\n  result = await cozy.client.data.create(myBooksDoctype, doc)\n  console.log('done', result)\n} catch(err) {\n  console.log('fail', err)\n}\n\n\n\n\nIf for some reason you do not want to use promises, you can pass the \ndisablePromises\n flag to the init function. This way, you will be able to use the functions with a classic callback.\n\n\ncozy.client.init({ disablePromises: true })\ncozy.client.data.create(myBooksDoctype, doc, function(err, result) {\n    if (err) {\n      console.log('fail', err);\n    } else {\n      console.log('done', result);\n    }\n});\n\n undefined\n\n\n\n\nConstructor\n\n\nnew cozy.Client(options)\n\n\nnew cozy.Client(options)\n returns a new cozy client.\n\n\nIt does return a Cozy instance.\n\n\nIt takes the same options object as the \ncozy.client.init(options)\n function.\n\n\ncozy.client.init(options)\n\n\ncozy.client.init(options)\n setups initialize the global cozy instance.\n\n\nIt does not return a value.\n\n\n\n\noptions\n is an object with the following fields:\n\n\ncozyURL\n: absolute url of the cozy stack\n\n\ndisablePromises\n: boolean to make function that returns promise used with a classical \ncallback as last argument\n (default value is \nfalse\n)\n\n\noauth\n: an object with the OAuth parameters, see \nOAuth\n for details\n\n\nversion\n: the version of Cozy (2 or 3), it\ns optional, by default with a request to the server it can deduce automatically the version. (Must be specified for an offline mode)\n\n\n\n\ncozy.client.init({\n  cozyURL: 'http://cozy.tools:8080',\n  disablePromises: false,\n  version: 3,\n  oauth: {\n    clientParams: {/*...*/},\n    scopes: [\nio.cozy.files:GET\n],\n    onRegistered: (client, url) =\n { /* */ },\n    storage: new cozy.auth.LocalStorage(window.localStorage)\n  }\n})\n\n\n\n\nFuture APIs\n\n\nThis is the end of what we already have implemented, if you want to do something else (manipulating binary file, sharing, \n), you will have to wait a bit :smile:.\n\n\nFeel free to open an issue if you see something missing, or if you disagree with the API design !\n\n\n{% endraw %}", 
            "title": "Introduction"
        }, 
        {
            "location": "/cozy-client-js/intro/#introduction-to-cozy-client-js", 
            "text": "", 
            "title": "Introduction to cozy-client-js"
        }, 
        {
            "location": "/cozy-client-js/intro/#reminder-about-cozy-architectures", 
            "text": "There is two actives cozy architectures:   The first, thereafter named  v2  is the existing cozy structure. It s based on 1 container / user with many node.js processes in each container (cozy-data-system, cozy-proxy, cozy-home, 1 process per app).  The second, thereafter named  v3  is the new cozy-stack ( repository ). It s based on go and aim to support multiple user on a single process.   v2  supported both  server-side  applications with their own node.js process and  client-side  applications which run in the user browser.  v3  will not support  server-side  applications. We will support server side modules managed by server administrator, but the applications themselves will all be  client-side  application.  This repository provides a library which allows you to build a  client-side  application compatible with both version.  The former javascript library for making client-side application was  cozy-browser-sdk . We aim to deprecate it once  cozy-client-js  reaches feature-parity.  If you already have an application using  cozy-browser-sdk , you can see what will change in the  transition document . If you have any doubt, please open an issue!", 
            "title": "Reminder about cozy architectures"
        }, 
        {
            "location": "/cozy-client-js/intro/#include-the-library-in-your-application", 
            "text": "You can  import / require  cozy-client-js using npm   webpack.  You can also copy-paste the  dist/cozy-client.js  bundle file into your application, and include it in your application  index.html  with  script src=\"./cozy-client.js\" .  If you are developing a client-side app for Cozy V3, you can import the lib directly from the stack, by using  {{.CozyClientJS}} .  If you are developing a nodejs app, you will need some polyfills. You can add them to your project with this command:  $ yarn add isomorphic-fetch core-js regenerator-runtime btoa", 
            "title": "Include the library in your application"
        }, 
        {
            "location": "/cozy-client-js/intro/#doctypes-permissions", 
            "text": "A doctype is a simple javascript string identifying a type of document.\nSome basic doctypes are provided by cozy, but you can pick your own.  Cozy  v3  expects doctypes to be qualified to ensure uniqueness.  All doctypes designed by the cozy s team will be prefixed with  io.cozy. , or  io.cozy.labs.  Any doctype you introduce is expected to be prefixed with the reverse notation of a domain you own (JLS#7.7). If you do not own a domain, you can also use a reverse notation of your email address.  You are free to reuse another applications documents by using their doctypes but you  SHOULD  discuss with the domain owner if you want to add fields or format them differently.  To ensure retrocompatibility, when used on stack v2, all known doctypes will be auto-prefixed, but a warning will be written to the console. Unknown doctype will cause a fatal error. DO NOT rely on this behaviour in new applications, use qualified doctypes.  // contacts is a doctype defined by cozy\ncozyContactsDoctype =  io.cozy.contacts \n// your application handle books, let's create a doctype\nmyBooksDoctype =  com.mydomain.book  When you use a doctype, even one created by your application, you need to ask for its permission in your manifest. How to do it depends on which stack you are developping for.  TODO  Have some docs about  v2  package.json vs  v3  manifest.webapp", 
            "title": "Doctypes &amp; Permissions"
        }, 
        {
            "location": "/cozy-client-js/intro/#promises-callbacks", 
            "text": "All cozy-client-js functions support callback or promise.  If no callback is provided, a promise is returned.  cozy.client.data.create(myBooksDoctype, doc)\n    .then(function(result){ console.log('done', result); });\n    .catch(function(err){ console.log('fail', err); });  If your build pipeline supports it, use async/await for sweet sweet async  try {\n  result = await cozy.client.data.create(myBooksDoctype, doc)\n  console.log('done', result)\n} catch(err) {\n  console.log('fail', err)\n}  If for some reason you do not want to use promises, you can pass the  disablePromises  flag to the init function. This way, you will be able to use the functions with a classic callback.  cozy.client.init({ disablePromises: true })\ncozy.client.data.create(myBooksDoctype, doc, function(err, result) {\n    if (err) {\n      console.log('fail', err);\n    } else {\n      console.log('done', result);\n    }\n});  undefined", 
            "title": "Promises &amp; Callbacks"
        }, 
        {
            "location": "/cozy-client-js/intro/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/cozy-client-js/intro/#new-cozyclientoptions", 
            "text": "new cozy.Client(options)  returns a new cozy client.  It does return a Cozy instance.  It takes the same options object as the  cozy.client.init(options)  function.", 
            "title": "new cozy.Client(options)"
        }, 
        {
            "location": "/cozy-client-js/intro/#cozyclientinitoptions", 
            "text": "cozy.client.init(options)  setups initialize the global cozy instance.  It does not return a value.   options  is an object with the following fields:  cozyURL : absolute url of the cozy stack  disablePromises : boolean to make function that returns promise used with a classical  callback as last argument  (default value is  false )  oauth : an object with the OAuth parameters, see  OAuth  for details  version : the version of Cozy (2 or 3), it s optional, by default with a request to the server it can deduce automatically the version. (Must be specified for an offline mode)   cozy.client.init({\n  cozyURL: 'http://cozy.tools:8080',\n  disablePromises: false,\n  version: 3,\n  oauth: {\n    clientParams: {/*...*/},\n    scopes: [ io.cozy.files:GET ],\n    onRegistered: (client, url) =  { /* */ },\n    storage: new cozy.auth.LocalStorage(window.localStorage)\n  }\n})", 
            "title": "cozy.client.init(options)"
        }, 
        {
            "location": "/cozy-client-js/intro/#future-apis", 
            "text": "This is the end of what we already have implemented, if you want to do something else (manipulating binary file, sharing,  ), you will have to wait a bit :smile:.  Feel free to open an issue if you see something missing, or if you disagree with the API design !  {% endraw %}", 
            "title": "Future APIs"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/", 
            "text": "How to transition your app from cozy-browser-sdk to cozy-client-js\n\n\nFull doctype qualification\n\n\nCozy \nv3\n expects \ndoctypes\n to be qualified to ensure uniqueness.\n\n\nAll doctypes designed by the cozy\ns team will be prefixed with \nio.cozy.\n\n\nAny doctype you introduce is expected to be prefixed with the reverse notation of a domain you own (JLS#7.7).\n\n\nYou are free to reuse another applications documents by using their doctypes but you SHOULD discuss with the domain owner if you want to add fields or format them differently.\n\n\nTo ensure retrocompatibility, when used on stack v2, all known doctypes will be auto-prefixed by \nio.cozy.\n or \nio.cozy.labs.\n, but a warning will be written to the console. Unknown doctype will cause a fatal error. DO NOT rely on this behaviour in new applications, use qualified doctypes.\n\n\n// old version, using cozy-browser-sdk\ncozysdk.create(\nContact\n, {})\ncozysdk.create(\nBook\n, {})\n// new version, with cozy-client-js\ncozy.data.create(\nio.cozy.contacts\n, {})\ncozy.data.create(\ncom.mydomain.book\n, {})\n\n\n\n\nMapReduce Views vs Mango queries\n\n\nCozy \nv3\n recommends using Couchdb 2 indexes \n mango queries instead of Couchdb 1.X map-reduce views. We feel they are \nsimpler to understand and explain\n and avoid useless overindexing.\n\n\nWhen used on a \nv2\n cozy, the \ndefineIndex\n and \nquery\n calls will be translated to MapReduce views.\n\n\nIf you need the full power of MapReduce, please open a issue on cozy-stack with your usecase.\n\n\n// cozy-browser-sdk\ncozysdk.defineMapReduceView('Event', 'all', function(doc) { emit(doc.year); })\ncozysdk.queryView('Event', 'all', {key: 2016, limit: 10})\n// cozy-client-js\nindex = cozy.data.defineIndex('Event', ['year'])\ncozy.data.query(index, {selector: {year: 2016}, limit: 10})\n\n\n\n\nBinaries\n\n\nWe do not yet have a plan for binaries attachments to documents.\nThey will be probably placed in the VFS under a special path.\n\n\nCrud is fully compatible\n\n\nThe following functions have the same signature than the cozy-browser-sdk\n\n\ncreated = await cozy.data.create(myType, book)\ndoc = await cozy.data.find(myType, id)\ndoc2 = await cozy.data.updateAttributes(myType, id, {year: 1851})\nawait cozy.data.destroy(\nmy.domain.book\n, id)", 
            "title": "Transition from cozy-browser-sdk"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/#how-to-transition-your-app-from-cozy-browser-sdk-to-cozy-client-js", 
            "text": "", 
            "title": "How to transition your app from cozy-browser-sdk to cozy-client-js"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/#full-doctype-qualification", 
            "text": "Cozy  v3  expects  doctypes  to be qualified to ensure uniqueness.  All doctypes designed by the cozy s team will be prefixed with  io.cozy.  Any doctype you introduce is expected to be prefixed with the reverse notation of a domain you own (JLS#7.7).  You are free to reuse another applications documents by using their doctypes but you SHOULD discuss with the domain owner if you want to add fields or format them differently.  To ensure retrocompatibility, when used on stack v2, all known doctypes will be auto-prefixed by  io.cozy.  or  io.cozy.labs. , but a warning will be written to the console. Unknown doctype will cause a fatal error. DO NOT rely on this behaviour in new applications, use qualified doctypes.  // old version, using cozy-browser-sdk\ncozysdk.create( Contact , {})\ncozysdk.create( Book , {})\n// new version, with cozy-client-js\ncozy.data.create( io.cozy.contacts , {})\ncozy.data.create( com.mydomain.book , {})", 
            "title": "Full doctype qualification"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/#mapreduce-views-vs-mango-queries", 
            "text": "Cozy  v3  recommends using Couchdb 2 indexes   mango queries instead of Couchdb 1.X map-reduce views. We feel they are  simpler to understand and explain  and avoid useless overindexing.  When used on a  v2  cozy, the  defineIndex  and  query  calls will be translated to MapReduce views.  If you need the full power of MapReduce, please open a issue on cozy-stack with your usecase.  // cozy-browser-sdk\ncozysdk.defineMapReduceView('Event', 'all', function(doc) { emit(doc.year); })\ncozysdk.queryView('Event', 'all', {key: 2016, limit: 10})\n// cozy-client-js\nindex = cozy.data.defineIndex('Event', ['year'])\ncozy.data.query(index, {selector: {year: 2016}, limit: 10})", 
            "title": "MapReduce Views vs Mango queries"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/#binaries", 
            "text": "We do not yet have a plan for binaries attachments to documents.\nThey will be probably placed in the VFS under a special path.", 
            "title": "Binaries"
        }, 
        {
            "location": "/cozy-client-js/browser-sdk-transition/#crud-is-fully-compatible", 
            "text": "The following functions have the same signature than the cozy-browser-sdk  created = await cozy.data.create(myType, book)\ndoc = await cozy.data.find(myType, id)\ndoc2 = await cozy.data.updateAttributes(myType, id, {year: 1851})\nawait cozy.data.destroy( my.domain.book , id)", 
            "title": "Crud is fully compatible"
        }, 
        {
            "location": "/cozy-client-js/offline/", 
            "text": "Offline support\n\n\nThis document describes in more details how to use this library in offline mode.\n\n\nAll applications do not require offline mode, and offline mode needs two dependencies : \npouchdb\n and \npouchdb-find\n.\nAs both are very large, we decide not to provide them by default, since v0.2.0.\n\n\nSo if your app needs to use offline mode, you have to add those dependencies by yourself. It means you just need to do:\n\n\n$/your-app\n yarn add pouchdb\n$/your-app\n yarn add pouchdb-find\n\n\n\n\nThen they will have to import \npouchdb\n and \npouchdbfind\n globally, as they are not imported in codebase anymore. This means adding the following configuration in all concerned webpack target files (for example \nwebpack.target.mobile.js\n) :\n\n\nmodule.exports = {\n  ...\n  plugins: [\n    new webpack.ProvidePlugin({\n      'PouchDB': 'pouchdb',\n      'pouchdbFind': 'pouchdb-find'\n    })\n  ]\n}\n\n\n\n\nThis same configuration has to be added in file \nwepback.config.prod.js\n, to make the build possible.\n\n\nIn prod, since \ncozy-client-js\n is injected by the stack, it has not been processed by \nwepback\n and the \nProvidePlugin\n. Thus you need to bind \nPouchDB\n to \nwindow\n.\n\n\n/* global PouchDB, pouchdbFind */\n// Bind PouchDB to window for cozy-client-js to find it\n// PouchDB is provided by webpack through ProvidedPlugin\nwindow.PouchDB = PouchDB\nwindow.pouchdbFind = pouchdbFind", 
            "title": "How to support offline"
        }, 
        {
            "location": "/cozy-client-js/offline/#offline-support", 
            "text": "This document describes in more details how to use this library in offline mode.  All applications do not require offline mode, and offline mode needs two dependencies :  pouchdb  and  pouchdb-find .\nAs both are very large, we decide not to provide them by default, since v0.2.0.  So if your app needs to use offline mode, you have to add those dependencies by yourself. It means you just need to do:  $/your-app  yarn add pouchdb\n$/your-app  yarn add pouchdb-find  Then they will have to import  pouchdb  and  pouchdbfind  globally, as they are not imported in codebase anymore. This means adding the following configuration in all concerned webpack target files (for example  webpack.target.mobile.js ) :  module.exports = {\n  ...\n  plugins: [\n    new webpack.ProvidePlugin({\n      'PouchDB': 'pouchdb',\n      'pouchdbFind': 'pouchdb-find'\n    })\n  ]\n}  This same configuration has to be added in file  wepback.config.prod.js , to make the build possible.  In prod, since  cozy-client-js  is injected by the stack, it has not been processed by  wepback  and the  ProvidePlugin . Thus you need to bind  PouchDB  to  window .  /* global PouchDB, pouchdbFind */\n// Bind PouchDB to window for cozy-client-js to find it\n// PouchDB is provided by webpack through ProvidedPlugin\nwindow.PouchDB = PouchDB\nwindow.pouchdbFind = pouchdbFind", 
            "title": "Offline support"
        }, 
        {
            "location": "/cozy-client-js/oauth/", 
            "text": "This document describes in more details how to use this library along with OAuth.\n\n\nBefore reading this document, to better understand how authentication and OAuth work on the cozy-stack, you should read \nthis document\n.\n\n\nThe library exposes internal methods to access the OAuth endpoints of the cozy-stack. See \ncozy.auth.* methods\n. However, the library also provides a more automated way to perform de OAuth flow by implementing many details of the OAuth registration and authorization flow for you.\n\n\nHere we describe the automated and stateful method.\n\n\nStorage\n\n\nTo handle the workflow automatically, the user of the library shoud pass a storage object that will be used to store the OAuth client and tokens informations.\n\n\nThis storage should implement the following \ninterface\n:\n\n\ninterface Storage {\n  load(key: string) : Promise\nany\n\n  save(key: string, value: any) : Promise\nany\n\n  delete(key: string) : Promise\nboolean\n\n  clear() : Promise\n\n}\n\n\n\n\nThe library provides two implementation of such storage:\n  - \ncozy.auth.MemoryStorage\n storing data in-memory\n  - \ncozy.auth.LocalStorage\n storage data in a html5 \nlocalStorage\n\n\nThe library constructor (on \ninit\n method) should be passed the storage in the \nstorage\n field of the \noauth\n options.\n\n\nRegistration parameters\n\n\nIn order to handle the registration of the client, two callbacks should be provided to the cozy-client-js instance.\n\n\n\n\nclientParams\n an object with the following parameters:\n\n\nredirectURI\n: the URI on which the user is redirected after accepting the client (mandatory)\n\n\nsoftwareID\n: identifier of the software (by default \ngithub.com/cozy/cozy-client-js\n)\n\n\nsoftwareVersion\n: version of the software (optional)\n\n\nclientName\n: string (optional)\n\n\nclientKind\n: string (optional)\n\n\nclientURI\n: string (optional)\n\n\nlogoURI\n: string (optional)\n\n\npolicyURI\n: string (optional)\n\n\nscopes\n: array of \nkey:value\n elements representing the permission scopes required by the application that the user should accept (mandatory)\n\n\n\n\n\n\nonRegistered(client, url)\n which should provide the wanted \nside effect\n after the client registration and return a promise containing the request URL provided by the user containing the access code and state.\n\n\n\n\nThe \nonRegistered\n callback is called with the registered client and the URL on which the user should go to give access to the application.\n\n\nComplete example for Node.JS\n\n\nHere is a complete example running on Node.JS with a local http server receiving as redirect URI receiving the call of the user to complete the authorization of the client.\n\n\nconst http = require('http');\nconst {Cozy,MemoryStorage} = require('./dist/cozy-client.node.js')\n\nfunction onRegistered(client, url) {\n  let server\n  return new Promise((resolve) =\n {\n    server = http.createServer((request, response) =\n {\n      if (request.url.indexOf('/do_access') === 0) {\n        console.log('Received access from user with url', request.url)\n        resolve(request.url)\n        response.end()\n      }\n    })\n    server.listen(3333, () =\n {\n      console.log('Please visit the following url to authorize the application: ', url)\n    })\n  })\n    .then(\n      (url) =\n { server.close(); return url; },\n      (err) =\n { server.close(); throw err; }\n    )\n}\n\nconst cozy = new Cozy({\n  cozyURL: 'http://cozy.tools:8080',\n  oauth: {\n    storage: new MemoryStorage(),\n    clientParams: {\n      redirectURI: 'http://localhost:3333/do_access',\n      softwareID: 'foobar',\n      clientName: 'client',\n      scopes: ['files/images:read']\n    },\n    onRegistered: onRegistered,\n  }\n})\n\ncozy.authorize().then((creds) =\n console.log(creds))", 
            "title": "OAuth guide"
        }, 
        {
            "location": "/cozy-client-js/oauth/#storage", 
            "text": "To handle the workflow automatically, the user of the library shoud pass a storage object that will be used to store the OAuth client and tokens informations.  This storage should implement the following  interface :  interface Storage {\n  load(key: string) : Promise any \n  save(key: string, value: any) : Promise any \n  delete(key: string) : Promise boolean \n  clear() : Promise \n}  The library provides two implementation of such storage:\n  -  cozy.auth.MemoryStorage  storing data in-memory\n  -  cozy.auth.LocalStorage  storage data in a html5  localStorage  The library constructor (on  init  method) should be passed the storage in the  storage  field of the  oauth  options.", 
            "title": "Storage"
        }, 
        {
            "location": "/cozy-client-js/oauth/#registration-parameters", 
            "text": "In order to handle the registration of the client, two callbacks should be provided to the cozy-client-js instance.   clientParams  an object with the following parameters:  redirectURI : the URI on which the user is redirected after accepting the client (mandatory)  softwareID : identifier of the software (by default  github.com/cozy/cozy-client-js )  softwareVersion : version of the software (optional)  clientName : string (optional)  clientKind : string (optional)  clientURI : string (optional)  logoURI : string (optional)  policyURI : string (optional)  scopes : array of  key:value  elements representing the permission scopes required by the application that the user should accept (mandatory)    onRegistered(client, url)  which should provide the wanted  side effect  after the client registration and return a promise containing the request URL provided by the user containing the access code and state.   The  onRegistered  callback is called with the registered client and the URL on which the user should go to give access to the application.", 
            "title": "Registration parameters"
        }, 
        {
            "location": "/cozy-client-js/oauth/#complete-example-for-nodejs", 
            "text": "Here is a complete example running on Node.JS with a local http server receiving as redirect URI receiving the call of the user to complete the authorization of the client.  const http = require('http');\nconst {Cozy,MemoryStorage} = require('./dist/cozy-client.node.js')\n\nfunction onRegistered(client, url) {\n  let server\n  return new Promise((resolve) =  {\n    server = http.createServer((request, response) =  {\n      if (request.url.indexOf('/do_access') === 0) {\n        console.log('Received access from user with url', request.url)\n        resolve(request.url)\n        response.end()\n      }\n    })\n    server.listen(3333, () =  {\n      console.log('Please visit the following url to authorize the application: ', url)\n    })\n  })\n    .then(\n      (url) =  { server.close(); return url; },\n      (err) =  { server.close(); throw err; }\n    )\n}\n\nconst cozy = new Cozy({\n  cozyURL: 'http://cozy.tools:8080',\n  oauth: {\n    storage: new MemoryStorage(),\n    clientParams: {\n      redirectURI: 'http://localhost:3333/do_access',\n      softwareID: 'foobar',\n      clientName: 'client',\n      scopes: ['files/images:read']\n    },\n    onRegistered: onRegistered,\n  }\n})\n\ncozy.authorize().then((creds) =  console.log(creds))", 
            "title": "Complete example for Node.JS"
        }, 
        {
            "location": "/cozy-client-js/auth-api/", 
            "text": "Authentication and OAuth (internal)\n\n\ncozy.client.auth.registerClient(clientParams)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.registerClient\n is used to register a new client with the specified informations.\n\n\nIt returns a promise of the newly registered Client, along with a client secret and identifier.\n\n\n\n\nclientParams\n are client parameters: a non registered instance of \ncozy.client.auth.Client\n\n\n\n\nconst clientParams = new cozy.client.auth.Client({\n  redirectURI: 'http://localhost:3000/',\n  softwareID: 'mysoftware',\n  clientName: 'Great mobile App'\n})\nconst client = await cozy.client.auth.registerClient(clientParams)\nconst clientID = client.clientID\nconst clientSecret = client.clientSecret\n\n\n\n\ncozy.client.auth.updateClient(client, resetSecret = false)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.updateClient\n is used to update informations about the oauth client.\n\n\nIt returns a promise for the updated Client.\n\n\n\n\nclient\n a registered instance of \ncozy.client.auth.Client\n\n\nresetSecret\n by setting \nresetSecret\n to \ntrue\n, a new Secret is generated.\n\n\n\n\nconst client = await cozy.client.auth.registerClient(clientParams)\n\n// change the client's version\nclient.softwareVersion = \nv1.2.3\n\nconst client = await cozy.client.auth.updateClient(client)\n\n\n// change the client secret\nconst client = await cozy.client.auth.updateClient(client, true)\n\n\n\n\ncozy.client.auth.unregisterClient(client)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.unregisterClient\n is used to unregister a client.\n\n\nIt returns a promise for completion\n\n\n\n\nclient\n a registered instance of \ncozy.client.auth.Client\n\n\n\n\nconst client = await cozy.client.auth.registerClient(clientParams)\nawait cozy.auth.client.unregisterClient(client)\n\n\n\n\ncozy.auth.client.getClient(client)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.getClient\n is used to fetch a registered client with the specified clientID and token.\n\n\nIt returns a promise of the client returned by the server.\n\n\n\n\nclient\n is a registered \ncozy.client.auth.Client\n\n\n\n\nconst client = await cozy.client.auth.getClient(new cozy.client.auth.Client({\n  clientID: '1235'\n}))\n\n\n\n\ncozy.client.auth.getAuthCodeURL(client, scopes)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.getAuthCodeURL\n is used to generate the URL on which the user should go to give access to the application with the specified scopes.\n\n\nIt returns an object with the url and a generated random state that should be stored to be matched again for the token exchange phase.\n\n\n\n\nclient\n is a registered \ncozy.client.auth.Client\n\n\nscopes\n is an array of permission strings formatted as \nkey:access\n (like \nfiles/images:read\n)\n\n\n\n\nconst {url, state} = cozy.client.auth.getAuthCodeURL(client, ['files/images:read'])\n\n// save state and redirect to url\nlocalStorage.setItem(\noauthstate\n, state)\nwindow.location.replace(url)\n\n\n\n\ncozy.client.auth.getAccessToken(client, state, pageURL)\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.getAccessToken\n is used from the page on which the user should have redirected after authorizing the application.\n\n\nIt returns a promise of an \ncozy.client.auth.AccessToken\n. The method verifies that the specified state and the extracted one match. It then ask the server for a new access token and returns it.\n\n\n\n\nclient\n is a registered \ncozy.client.auth.Client\n\n\nstate\n is the previously stored state that is matched against to prevent CSRF attacks\n\n\npageURL\n is the url of the current page from the which a code and state will be extracted. If empty, \nwindow.location.href\n is used\n\n\n\n\nconst client = cozy.client.auth.getClient(/* ... */)\nconst state = localStorage.getItem(\noauthstate\n)\nconst pageURL = window.location.href\nconst token = cozy.client.auth.getAccessToken(client, state, pageURL)\n\n\n\n\ncozy.client.auth.refreshToken\n\n\nThis method is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.refreshToken\n is used to refresh a token that is expired or no more valid.\n\n\n\n\nclient\n is a registered \ncozy.client.auth.Client\n\n\ntoken\n is a valid \ncozy.client.auth.AccessToken\n\n\n\n\nconst newtoken = cozy.client.auth.refreshToken(client, oldtoken)\n\n\n\n\ncozy.client.auth.Client\n\n\nThis class is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.Client\n is a class representing an OAuth client. It can be registered, in which case it is known by the server and has a \nclientID\n and \nclientSecret\n.\n\n\ntype Client {\n  clientID: string;                // informed by server\n  clientSecret: string;            // informed by server\n  registrationAccessToken: string; // informed by server\n  redirectURI: string; // mandatory\n  softwareID: string;  // mandatory\n  softwareVersion: string;\n  clientName: string;  // mandatory\n  clientKind: string;\n  clientURI: string;\n  logoURI: string;\n  policyURI: string;\n  notificationPlatform: string;\n  notificationDeviceToken: string;\n}\n\n\n\n\nThe constructor type is as follow:\n\n\n\n\nurl\n is a string of the url of the cozy\n\n\noptions\n is an object with the same fields as a client object, or is an instance of client\n\n\n\n\nnew Client(url, options)\n\n\n\n\ncozy.client.auth.AccessToken\n\n\nThis class is for internal or advanced usages. Please see \nOAuth document\n to see how to use OAuth with this library\n\n\ncozy.client.auth.AccessToken\n is a class representing an OAuth access token.\n\n\ntype Token {\n  tokenType: string;\n  accessToken: string;\n  refreshToken: string;\n  scope: string\n}\n\n\n\n\nThe constructor takes an object with the same fields as a Token object.", 
            "title": "Authentication API"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#authentication-and-oauth-internal", 
            "text": "", 
            "title": "Authentication and OAuth (internal)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthregisterclientclientparams", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.registerClient  is used to register a new client with the specified informations.  It returns a promise of the newly registered Client, along with a client secret and identifier.   clientParams  are client parameters: a non registered instance of  cozy.client.auth.Client   const clientParams = new cozy.client.auth.Client({\n  redirectURI: 'http://localhost:3000/',\n  softwareID: 'mysoftware',\n  clientName: 'Great mobile App'\n})\nconst client = await cozy.client.auth.registerClient(clientParams)\nconst clientID = client.clientID\nconst clientSecret = client.clientSecret", 
            "title": "cozy.client.auth.registerClient(clientParams)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthupdateclientclient-resetsecret-false", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.updateClient  is used to update informations about the oauth client.  It returns a promise for the updated Client.   client  a registered instance of  cozy.client.auth.Client  resetSecret  by setting  resetSecret  to  true , a new Secret is generated.   const client = await cozy.client.auth.registerClient(clientParams)\n\n// change the client's version\nclient.softwareVersion =  v1.2.3 \nconst client = await cozy.client.auth.updateClient(client)\n\n\n// change the client secret\nconst client = await cozy.client.auth.updateClient(client, true)", 
            "title": "cozy.client.auth.updateClient(client, resetSecret = false)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthunregisterclientclient", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.unregisterClient  is used to unregister a client.  It returns a promise for completion   client  a registered instance of  cozy.client.auth.Client   const client = await cozy.client.auth.registerClient(clientParams)\nawait cozy.auth.client.unregisterClient(client)", 
            "title": "cozy.client.auth.unregisterClient(client)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyauthclientgetclientclient", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.getClient  is used to fetch a registered client with the specified clientID and token.  It returns a promise of the client returned by the server.   client  is a registered  cozy.client.auth.Client   const client = await cozy.client.auth.getClient(new cozy.client.auth.Client({\n  clientID: '1235'\n}))", 
            "title": "cozy.auth.client.getClient(client)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthgetauthcodeurlclient-scopes", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.getAuthCodeURL  is used to generate the URL on which the user should go to give access to the application with the specified scopes.  It returns an object with the url and a generated random state that should be stored to be matched again for the token exchange phase.   client  is a registered  cozy.client.auth.Client  scopes  is an array of permission strings formatted as  key:access  (like  files/images:read )   const {url, state} = cozy.client.auth.getAuthCodeURL(client, ['files/images:read'])\n\n// save state and redirect to url\nlocalStorage.setItem( oauthstate , state)\nwindow.location.replace(url)", 
            "title": "cozy.client.auth.getAuthCodeURL(client, scopes)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthgetaccesstokenclient-state-pageurl", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.getAccessToken  is used from the page on which the user should have redirected after authorizing the application.  It returns a promise of an  cozy.client.auth.AccessToken . The method verifies that the specified state and the extracted one match. It then ask the server for a new access token and returns it.   client  is a registered  cozy.client.auth.Client  state  is the previously stored state that is matched against to prevent CSRF attacks  pageURL  is the url of the current page from the which a code and state will be extracted. If empty,  window.location.href  is used   const client = cozy.client.auth.getClient(/* ... */)\nconst state = localStorage.getItem( oauthstate )\nconst pageURL = window.location.href\nconst token = cozy.client.auth.getAccessToken(client, state, pageURL)", 
            "title": "cozy.client.auth.getAccessToken(client, state, pageURL)"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthrefreshtoken", 
            "text": "This method is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.refreshToken  is used to refresh a token that is expired or no more valid.   client  is a registered  cozy.client.auth.Client  token  is a valid  cozy.client.auth.AccessToken   const newtoken = cozy.client.auth.refreshToken(client, oldtoken)", 
            "title": "cozy.client.auth.refreshToken"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthclient", 
            "text": "This class is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.Client  is a class representing an OAuth client. It can be registered, in which case it is known by the server and has a  clientID  and  clientSecret .  type Client {\n  clientID: string;                // informed by server\n  clientSecret: string;            // informed by server\n  registrationAccessToken: string; // informed by server\n  redirectURI: string; // mandatory\n  softwareID: string;  // mandatory\n  softwareVersion: string;\n  clientName: string;  // mandatory\n  clientKind: string;\n  clientURI: string;\n  logoURI: string;\n  policyURI: string;\n  notificationPlatform: string;\n  notificationDeviceToken: string;\n}  The constructor type is as follow:   url  is a string of the url of the cozy  options  is an object with the same fields as a client object, or is an instance of client   new Client(url, options)", 
            "title": "cozy.client.auth.Client"
        }, 
        {
            "location": "/cozy-client-js/auth-api/#cozyclientauthaccesstoken", 
            "text": "This class is for internal or advanced usages. Please see  OAuth document  to see how to use OAuth with this library  cozy.client.auth.AccessToken  is a class representing an OAuth access token.  type Token {\n  tokenType: string;\n  accessToken: string;\n  refreshToken: string;\n  scope: string\n}  The constructor takes an object with the same fields as a Token object.", 
            "title": "cozy.client.auth.AccessToken"
        }, 
        {
            "location": "/cozy-client-js/data-api/", 
            "text": "Data API\n\n\ncozy.client.data.create(doctype, attributes)\n\n\ncozy.client.data.create(doctype, attributes)\n adds a document to the database.\n\n\nIt returns a promise for the created object. The created object has the same attributes than thoses passed, with an added \n_id\n. It\ns the unique identifier for the created document.\n\n\nIf you use an existing doctype, you should follow its expected format. \nv2\n does not enforce this, but we plan to on \nv3\n. Anyway, do you want to be the app that creates empty contacts in the native app ?\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\nattributes\n is an object that can be stringified using \nJSON.stringify\n: if it is a complex or cyclic object, add a \ntoJSON\n method to it (native behaviour of \nJSON.stringify\n).\n\n\n\n\nWarning\n: on \nv3\n, an extra field \n_rev\n is added, it is the unique identifier for the document revision, after creation, it will be of the shape \n1-xxxxxxxxx\n for first revision.\n\n\n// simple object\nconst book = { title: \nMoby Dick\n, author:\nHerman Melville\n, isbn: \n42\n }\nconst created = await cozy.client.data.create(myBooksDoctype, book)\n// same fields\nconsole.log(created.title, created.author, created.isbn)\n// _id, _rev are added\nconsole.log(created._id, created._rev)\n// let's keep it for later\ncreatedBookId = created._id\n\n\n\n\ncozy.client.data.find(doctype, id)\n\n\ncozy.client.data.find(doctype, id)\n returns the document associated to the given ID.\n\n\nIt returns a promise for the document. It will have the same fields than the returned value of \ncreate\n, including \n_id\n and \n_rev\n.\n\n\nIf the document does not exist, the promise will be rejected or the callback will be passed an error.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\nid\n is a string specifying the identifier of the document you look for\n\n\n\n\nconst doc = await cozy.client.data.find(myBooksDoctype, createdBookId)\nconsole.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)\n\n\n\n\ncozy.client.data.findMany(doctype, [ids])\n\n\ncozy.client.data.findMany(doctype, [ids])\n returns the documents associated to the given IDs.\n\n\nIt returns a promise for a map, with the given IDs as keys.\n\n\nWhen a document is found, the corresponding value will be an object with a\nsingle \ndoc\n key containing the document.\nDocuments will have the same fields than the returned values of \ncreate\n,\nincluding \n_id\n and \n_rev\n.\n\n\nWhen a document is missing, the corresponding value will be an object with a\nsingle \nerror\n key containing the error message.\nEven when some document is missing, the promise will still be fulfilled or the\ncallback will be passed the resulting map, so you can still access the other\ndocuments found and identify the missing ones.\n\n\n\n\ndoctype\n is a string specifying the\n  \ndoctype\n\n\nids\n is an array of strings specifying the identifiers of the documents you\n  look for\n\n\n\n\nWarning\n: Not available on \nv2\n. A fallback implementation could be\nprovided at some point.\n\n\nconst ids = [createdBookId, ...]\nconst resultsById = await cozy.client.data.findMany(myBooksDoctype, ids)\nfor (const id of ids) {\n  const {doc, error} = resultsById[id]\n  if (error) {\n    console.error(`Error while fetching book ${id}: ${error}`)\n  } else {\n    console.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)\n  }\n}\n\n\n\n\ncozy.client.data.findAll(doctype)\n\n\ncozy.client.data.findAll(doctype)\n returns the all documents associated to the given doctype.\n\n\nIt returns a promise for a map, with the given IDs as keys.\n\n\nWhen a document is found, the corresponding value will be an object with a\nsingle \ndoc\n key containing the document.\nDocuments will have the same fields than the returned values of \ncreate\n,\nincluding \n_id\n and \n_rev\n.\n\n\n\n\ndoctype\n is a string specifying the\n  \ndoctype\n\n  look for\n\n\n\n\nWarning\n: Not available on \nv2\n. A fallback implementation could be\nprovided at some point.\n\n\nconst result = await cozy.client.data.findAll(myBooksDoctype)\nif (result.error) {\n    console.error('Error while fetching books')\n}\nfor (const id of result.keys) {\n    const doc = result.docs[id]\n    console.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)\n}\n\n\n\n\ncozy.client.data.changesFeed(doctype, options)\n\n\ncozy.client.data.changesFeed(doctype, options)\n returns the last changes from CouchDB for the given doctype\n\n\nIt returns a promise for the changes.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\noptions\n is an object, only its \nsince\n parameter is supported currently\n\n\n\n\nconst changes = await.cozy.client.data.changesFeed(myBooksDoctype, { since: 0 })\nconsole.log(changes.last_seq, changes.results)\n\n\n\n\ncozy.client.data.update(doctype, doc, newdoc)\n\n\ncozy.client.data.update(doctype, doc, newdoc)\n replaces the document by a new version.\n\n\nIt returns a promise for the updated document. The updated document will have the same fields and values than provided in newdoc, the same \n_id\n than doc, and a \n_rev\n incremented from doc\ns number.\n\n\nIf the document does not exist, the promise will reject with an error.\n\n\nIf the document current \n_rev\n does not match the passed one, it means there is a conflict and the promise is rejected with an error.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\ndoc\n is an object with \nat least\n the fields \n_id\n and \n_rev\n containing the identifier and revision of the file you want to update.\n\n\nnewdoc\n is an object, specifying the new content of the document\n\n\n\n\nconst updates = { title: \nMoby Dick !\n, author:\nTHE Herman Melville\n}\nconst updated = await cozy.client.data.update(myBooksDoctype, doc, updates)\nconsole.log(updated._id === doc._id) // _id does not change\nconsole.log(updated._rev) // 2-xxxxxx\nconsole.log(updated.title, updated.year) // fields are changed\nconsole.log(updated.isbn === undefined) // update erase fields\n\n\n\n\ncozy.client.data.updateAttributes(doctype, id, changes)\n\n\ncozy.client.data.updateAttributes(doctype, id, changes)\n applies change to the document.\n\n\nIt returns a promise for the updated document. The updated document will be the result of merging changes into the document with given \n_id\n and a incremented \n_rev\n.\n\n\nIf the document does not exist, the promise will be rejected or the callback will be passed an error.\n\n\nThis function gives 3 attempts not to conflict.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\nid\n is a string specifying the identifier of the document to update\n\n\nchanges\n is an object\n\n\n\n\nconst updates = { year: 1852}\nconst updated = await cozy.client.data.updateAttributes(myBooksDoctype, id, updates)\nconsole.log(updated._id === doc._id) // _id does not change\nconsole.log(updated._rev) // 3-xxxxxx\nconsole.log(updated.year) // fields are changed\nconsole.log(updated.isbn) // updateAttributes preserve other fields\n\n\n\n\ncozy.client.data.delete(doctype, doc)\n\n\ncozy.client.data.delete(doctype, doc )\n will erase the document from the database.\n\n\nIt returns a promise which will be resolved when the document has been deleted.\n\n\nIf the document does not exist, the promise will be rejected with an error. If the document current \n_rev\n does not match the passed one, it means there is a conflict and the promise is rejected with an error.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\ndoc\n is an object with \nat least\n the fields \n_id\n and \n_rev\n containing the identifier and revision of the file you want to destroy.\n\n\n\n\nawait cozy.client.data.delete(myBooksDoctype, updated)\n\n\n\n\ncozy.client.data.defineIndex(doctype, fields)\n\n\ncozy.client.data.defineIndex(doctype, fields)\n creates an index for a document type. It is idempotent, it can be called several time with no bad effect.\n\n\nIt returns a promise for an \nindexReference\n, which can be passed to \ncozy.data.query\n.\n\n\n\n\ndoctype\n is a string specifying the \ndoctype\n\n\nfields\n is an array of the fields name to index\n\n\n\n\nWarning\n: when used on \nv2\n, a map-reduce view is created internally, when used on \nv3\n, we use couchdb built-in mango queries.\n\n\nconst booksByYearRef = await cozy.client.data.defineIndex(myType, ['year', 'rating'])\n\n\n\n\ncozy.client.data.query(indexReference, query)\n\n\ncozy.client.data.query(indexReference, query)\n find documents using an index.\n\n\nIt returns a promise with a list of documents matching the query. Results will be returned in the order defined for the index.\n\n\n\n\nquery\n is an object with the following fields:\n\n\nselector\n: a mango selector\n\n\nlimit\n: maximum number of results\n\n\nskip\n: ignore the first x results (pagination)\n\n\nwholeResponse\n: when set to true, the whole query response will be returned instead of just the docs. This is useful when paginating, because you\nll get the \nnext\n property in the response object.\n\n\n\n\nWarning\n: complex mango queries are not compatible with \nv2\n\n\nconst results = await cozy.client.data.query(booksByYearRef, {\n  \nselector\n: {year: 1851},\n  \nlimit\n: 3,\n  \nskip\n: 1\n})\n\nresults.length == 3 // we limited to 3 results\nresuts[0]._id === doc._id\nresuts[0].title === \nMoby Dick\n\nresuts[0].rating \n 2 // lowest rating first", 
            "title": "Data System API"
        }, 
        {
            "location": "/cozy-client-js/data-api/#data-api", 
            "text": "", 
            "title": "Data API"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatacreatedoctype-attributes", 
            "text": "cozy.client.data.create(doctype, attributes)  adds a document to the database.  It returns a promise for the created object. The created object has the same attributes than thoses passed, with an added  _id . It s the unique identifier for the created document.  If you use an existing doctype, you should follow its expected format.  v2  does not enforce this, but we plan to on  v3 . Anyway, do you want to be the app that creates empty contacts in the native app ?   doctype  is a string specifying the  doctype  attributes  is an object that can be stringified using  JSON.stringify : if it is a complex or cyclic object, add a  toJSON  method to it (native behaviour of  JSON.stringify ).   Warning : on  v3 , an extra field  _rev  is added, it is the unique identifier for the document revision, after creation, it will be of the shape  1-xxxxxxxxx  for first revision.  // simple object\nconst book = { title:  Moby Dick , author: Herman Melville , isbn:  42  }\nconst created = await cozy.client.data.create(myBooksDoctype, book)\n// same fields\nconsole.log(created.title, created.author, created.isbn)\n// _id, _rev are added\nconsole.log(created._id, created._rev)\n// let's keep it for later\ncreatedBookId = created._id", 
            "title": "cozy.client.data.create(doctype, attributes)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatafinddoctype-id", 
            "text": "cozy.client.data.find(doctype, id)  returns the document associated to the given ID.  It returns a promise for the document. It will have the same fields than the returned value of  create , including  _id  and  _rev .  If the document does not exist, the promise will be rejected or the callback will be passed an error.   doctype  is a string specifying the  doctype  id  is a string specifying the identifier of the document you look for   const doc = await cozy.client.data.find(myBooksDoctype, createdBookId)\nconsole.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)", 
            "title": "cozy.client.data.find(doctype, id)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatafindmanydoctype-ids", 
            "text": "cozy.client.data.findMany(doctype, [ids])  returns the documents associated to the given IDs.  It returns a promise for a map, with the given IDs as keys.  When a document is found, the corresponding value will be an object with a\nsingle  doc  key containing the document.\nDocuments will have the same fields than the returned values of  create ,\nincluding  _id  and  _rev .  When a document is missing, the corresponding value will be an object with a\nsingle  error  key containing the error message.\nEven when some document is missing, the promise will still be fulfilled or the\ncallback will be passed the resulting map, so you can still access the other\ndocuments found and identify the missing ones.   doctype  is a string specifying the\n   doctype  ids  is an array of strings specifying the identifiers of the documents you\n  look for   Warning : Not available on  v2 . A fallback implementation could be\nprovided at some point.  const ids = [createdBookId, ...]\nconst resultsById = await cozy.client.data.findMany(myBooksDoctype, ids)\nfor (const id of ids) {\n  const {doc, error} = resultsById[id]\n  if (error) {\n    console.error(`Error while fetching book ${id}: ${error}`)\n  } else {\n    console.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)\n  }\n}", 
            "title": "cozy.client.data.findMany(doctype, [ids])"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatafindalldoctype", 
            "text": "cozy.client.data.findAll(doctype)  returns the all documents associated to the given doctype.  It returns a promise for a map, with the given IDs as keys.  When a document is found, the corresponding value will be an object with a\nsingle  doc  key containing the document.\nDocuments will have the same fields than the returned values of  create ,\nincluding  _id  and  _rev .   doctype  is a string specifying the\n   doctype \n  look for   Warning : Not available on  v2 . A fallback implementation could be\nprovided at some point.  const result = await cozy.client.data.findAll(myBooksDoctype)\nif (result.error) {\n    console.error('Error while fetching books')\n}\nfor (const id of result.keys) {\n    const doc = result.docs[id]\n    console.log(doc._id, doc._rev, doc.title, doc.author, doc.isbn)\n}", 
            "title": "cozy.client.data.findAll(doctype)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatachangesfeeddoctype-options", 
            "text": "cozy.client.data.changesFeed(doctype, options)  returns the last changes from CouchDB for the given doctype  It returns a promise for the changes.   doctype  is a string specifying the  doctype  options  is an object, only its  since  parameter is supported currently   const changes = await.cozy.client.data.changesFeed(myBooksDoctype, { since: 0 })\nconsole.log(changes.last_seq, changes.results)", 
            "title": "cozy.client.data.changesFeed(doctype, options)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdataupdatedoctype-doc-newdoc", 
            "text": "cozy.client.data.update(doctype, doc, newdoc)  replaces the document by a new version.  It returns a promise for the updated document. The updated document will have the same fields and values than provided in newdoc, the same  _id  than doc, and a  _rev  incremented from doc s number.  If the document does not exist, the promise will reject with an error.  If the document current  _rev  does not match the passed one, it means there is a conflict and the promise is rejected with an error.   doctype  is a string specifying the  doctype  doc  is an object with  at least  the fields  _id  and  _rev  containing the identifier and revision of the file you want to update.  newdoc  is an object, specifying the new content of the document   const updates = { title:  Moby Dick ! , author: THE Herman Melville }\nconst updated = await cozy.client.data.update(myBooksDoctype, doc, updates)\nconsole.log(updated._id === doc._id) // _id does not change\nconsole.log(updated._rev) // 2-xxxxxx\nconsole.log(updated.title, updated.year) // fields are changed\nconsole.log(updated.isbn === undefined) // update erase fields", 
            "title": "cozy.client.data.update(doctype, doc, newdoc)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdataupdateattributesdoctype-id-changes", 
            "text": "cozy.client.data.updateAttributes(doctype, id, changes)  applies change to the document.  It returns a promise for the updated document. The updated document will be the result of merging changes into the document with given  _id  and a incremented  _rev .  If the document does not exist, the promise will be rejected or the callback will be passed an error.  This function gives 3 attempts not to conflict.   doctype  is a string specifying the  doctype  id  is a string specifying the identifier of the document to update  changes  is an object   const updates = { year: 1852}\nconst updated = await cozy.client.data.updateAttributes(myBooksDoctype, id, updates)\nconsole.log(updated._id === doc._id) // _id does not change\nconsole.log(updated._rev) // 3-xxxxxx\nconsole.log(updated.year) // fields are changed\nconsole.log(updated.isbn) // updateAttributes preserve other fields", 
            "title": "cozy.client.data.updateAttributes(doctype, id, changes)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatadeletedoctype-doc", 
            "text": "cozy.client.data.delete(doctype, doc )  will erase the document from the database.  It returns a promise which will be resolved when the document has been deleted.  If the document does not exist, the promise will be rejected with an error. If the document current  _rev  does not match the passed one, it means there is a conflict and the promise is rejected with an error.   doctype  is a string specifying the  doctype  doc  is an object with  at least  the fields  _id  and  _rev  containing the identifier and revision of the file you want to destroy.   await cozy.client.data.delete(myBooksDoctype, updated)", 
            "title": "cozy.client.data.delete(doctype, doc)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdatadefineindexdoctype-fields", 
            "text": "cozy.client.data.defineIndex(doctype, fields)  creates an index for a document type. It is idempotent, it can be called several time with no bad effect.  It returns a promise for an  indexReference , which can be passed to  cozy.data.query .   doctype  is a string specifying the  doctype  fields  is an array of the fields name to index   Warning : when used on  v2 , a map-reduce view is created internally, when used on  v3 , we use couchdb built-in mango queries.  const booksByYearRef = await cozy.client.data.defineIndex(myType, ['year', 'rating'])", 
            "title": "cozy.client.data.defineIndex(doctype, fields)"
        }, 
        {
            "location": "/cozy-client-js/data-api/#cozyclientdataqueryindexreference-query", 
            "text": "cozy.client.data.query(indexReference, query)  find documents using an index.  It returns a promise with a list of documents matching the query. Results will be returned in the order defined for the index.   query  is an object with the following fields:  selector : a mango selector  limit : maximum number of results  skip : ignore the first x results (pagination)  wholeResponse : when set to true, the whole query response will be returned instead of just the docs. This is useful when paginating, because you ll get the  next  property in the response object.   Warning : complex mango queries are not compatible with  v2  const results = await cozy.client.data.query(booksByYearRef, {\n   selector : {year: 1851},\n   limit : 3,\n   skip : 1\n})\n\nresults.length == 3 // we limited to 3 results\nresuts[0]._id === doc._id\nresuts[0].title ===  Moby Dick \nresuts[0].rating   2 // lowest rating first", 
            "title": "cozy.client.data.query(indexReference, query)"
        }, 
        {
            "location": "/cozy-client-js/files-api/", 
            "text": "Files API\n\n\ncozy.client.files.create(data, options)\n\n\ncozy.client.files.create(data, options)\n is used to upload a new file onto your cozy\n\n\nIt returns a promise for the document of the file created.\n\n\n\n\ndata\n can be of the following type: \nBlob\n, \nFile\n, \nArrayBuffer\n, \nArrayBufferView\n, \nstream.Readable\n (node) or \nstring\n.\n\n\noptions\n is an object with the following fields:\n\n\nname\n: specify the name of the file. optional for a data of type \nFile\n, type, mandatory otherwise.\n\n\ndirID\n: specify identifier of the file\ns directory. if empty, it is the root directory.\n\n\ncontentType\n: specify the content type of the uploaded data. For a \nFile\n type, it is handled automatically in browsers (default: \napplication/octet-stream\n). For nodejs, you can rely on an external module like \nmime\n\n\nchecksum\n: the base64-encoded (with padding) MD5 digest of the file (optional).\n\n\nlastModifiedDate\n: a date to specify the last modification time to use for the uploaded file. If the given \ndata\n is a \nFile\n instance, the \nlastModifiedDate\n is automatically used (not overridden).\n\n\n\n\nWarning\n: this API is not v2 compatible.\n\n\nconst created = await cozy.client.files.create(blob, {\n    name: \nfilename\n,\n    dirID: \n123456\n,\n})\nconst fileCreated = await cozy.client.files.create(fileInput.files[0], {\n  dirID: \n,\n  checksum: \nrL0Y20zC+Fzt72VPzMSk2A==\n,\n  lastModifiedDate: new Date()\n})\n\n\n\n\ncozy.client.files.createDirectory(options)\n\n\ncozy.client.files.createDirectory(options)\n is used to create a new directory.\n\n\nIt returns a promise for the document of the directory created.\n\n\n\n\noptions\n is an object with the following fields:\n\n\nname\n: specify the name of the directory\n\n\ndirID\n: specify identifier of the file\ns directory. if empty, it is the root directory.\n\n\nlastModifiedDate\n: a date to specify the last modification time to use for the directory.\n\n\n\n\nconst created = await cozy.client.files.createDirectory({\n  name: \nmydir\n,\n  dirID: \n123456\n,\n  lastModifiedDate: new Date()\n})\n\n\n\n\ncozy.client.files.createDirectoryByPath(path)\n\n\ncozy.client.files.createDirectoryByPath(path)\n is used to create one or more directories for a given path.\n\n\nIt returns a promise for the document of the last directory created.\n\n\n\n\npath\n is a string\n\n\n\n\nconst barDirectory = await cozy.client.files.createDirectoryByPath('/Foo/Bar')\n\n\n\n\ncozy.client.files.updateById(id, data, options)\n\n\ncozy.client.files.updateById(id, data, options)\n is used to update the content of an already existing file.\n\n\nIt returns a promise for the document of the file updated.\n\n\n\n\nid\n is a string specifying the identifier of the file to modify.\n\n\ndata\n can be of the following type: \nBlob\n, \nFile\n, \nArrayBuffer\n, \nArrayBufferView\n or \nstring\n.\n\n\noptions\n is an object with the following fields:\n\n\ncontentType\n: specify the content type of the uploaded data. For a \nFile\n type, it is be handled automatically. default: \napplication/octet-stream\n.\n\n\nchecksum\n: the base64-encoded (with padding) MD5 digest of the file (optional).\n\n\nlastModifiedDate\n: a date to specify the last modification time to use for the uploaded file. If the given \ndata\n is a \nFile\n instance, the \nlastModifiedDate\n is automatically used (not overridden).\n\n\nifMatch\n: the previous revision of the file (optional). The update will be rejected if the remote revision doesn\nt match the given one.\n\n\n\n\nconst updated = await cozy.client.files.updateById(\n654321\n, blob, {\n  contentType: \ntext/plain\n,\n  checksum: \nrL0Y20zC+Fzt72VPzMSk2A==\n,\n  lastModifiedDate: new Date(),\n  ifMatch: \n1-0e6d5b72\n\n})\n\n\n\n\ncozy.client.files.updateAttributesById(id, attrs, options)\n\n\ncozy.client.files.updateAttributesById(id, attrs, options)\n is used to update the attributes associated to a file or directory specified by its id.\n\n\nIt returns a promise for the document of the updated directory or file.\n\n\n\n\nid\n is a string specifying the identifier of the file or directory to update\n\n\nattrs\n is an object containing the changes\n\n\noptions\n is an object with the following fields:\n\n\nifMatch\n: the previous revision of the file (optional). The update will be rejected if the remote revision doesn\nt match the given one.\n\n\n\n\nconst updated = await cozy.client.files.updateAttributesById(\n12345\n, { tags: [\nfoo\n] }, { ifMatch: \n1-0e6d5b72\n })\n\n\n\n\ncozy.client.files.updateAttributesByPath(path, attrs, options)\n\n\ncozy.client.files.updateAttributesByPath(path, attrs, options)\n is used to update the attributes associated to a file or directory specified by the given path.\n\n\nIt returns a promise for the document of the updated directory or file.\n\n\n\n\npath\n: string specifying the path of the file or directory to update\n\n\nattrs\n is an object containing the changes\n\n\noptions\n is an object with the following fields:\n\n\nifMatch\n: the previous revision of the file (optional). The update will be rejected if the remote revision doesn\nt match the given one.\n\n\n\n\nconst updated = await cozy.client.files.updateAttributes(\n/foo/bar\n, { executable: true }, { ifMatch: \n1-0e6d5b72\n })\n\n\n\n\ncozy.client.files.statById(id, offline, options)\n\n\ncozy.client.files.statById(id, offline, options)\n is used to get the metadata of a file specified by its id.\n\n\nIt returns a promise for the information of the file or directory. In the case of a directory, it contains the list of files and sub-directories inside it. This list is limited to 30 items by default, but the \noptions\n argument allows you\nto fetch more items.\n\n\n\n\nid\n is a string specifying the file\u2019s or directory\u2019s identifier\n\n\noffline\n is a boolean (default to \ntrue\n)\n\n\noptions\n is an object with the following fields:\n\n\nskip\n: number of items to skip (optional)\n\n\nlimit\n: maximum number of items to return (optional).\n\n\n\n\nBy default, \nstatById\n will fetch the metadata from the local database, if it is available. Set the second parameter to \nfalse\n to query the server.\n\n\nReturned directory have a \nrelations()\n method that allow to access to their content:\n\n\nconst dir = await cozy.client.files.statById(\nio.cozy.files.root-dir\n);\ndir.relations('contents').forEach( (file) =\n \u2026 )\n\n\n\n\ncozy.client.files.statByPath(path)\n\n\ncozy.client.files.statByPath(path)\n is used to get the metadata of a file specified by its path.\n\n\n\n\npath\n: string specifying the path of the file or directory;\n\n\n\n\ncozy.client.files.trashById(id, options)\n\n\ncozy.client.files.trashById(id, options)\n is used to move the file or directory identified by the given id to trash.\n\n\nIt returns a promise for the document of the file or directory moved to trash.\n\n\n\n\nid\n is a string specifying the identifier of the file or directory\n\n\noptions\n is an object with the following fields:\n\n\nifMatch\n: the previous revision of the file (optional). The update will be rejected if the remote revision doesn\nt match the given one.\n\n\n\n\nconst trashed = await cozy.client.files.trashById(\n1234567\n)\n\n\n\n\ncozy.client.files.destroyById(id, options)\n\n\ncozy.client.files.destroyById(id, options)\n is used to shred (destroy definitively) a file or directory identified by the given id.\n\n\nThe file must be in the trash folder first.\n\n\nIt returns a promise for completion\n\n\n\n\nid\n is a string specifying the identifier of the file or directory\n\n\noptions\n is an object with the following fields:\n\n\nifMatch\n: the previous revision of the file (optional). The update will be rejected if the remote revision doesn\nt match the given one.\n\n\n\n\nconst trashed = await cozy.client.files.trashById(\n1234567\n)\nawait cozy.client.files.destroyById(\n1234567\n)\n\n\n\n\ncozy.client.files.restoreById(id)\n\n\ncozy.client.files.restoreById(id)\n is used to restore a file or directory identified by the given id. The file must be in the trash folder.\n\n\nIt returns a promise for the restored doc. (with updated parent)\n\n\n\n\nid\n is a string specifying the identifier of the file or directory\n\n\n\n\nconst trashed = await cozy.client.files.trashById(\n1234567\n)\nconst restored = await cozy.client.files.restoreById(\n1234567\n)\n\n\n\n\ncozy.client.files.listTrash()\n\n\ncozy.client.files.listTrash()\n returns a promise for the list of all files in the trash.\n\n\nconst trashedFilesAndFolders = await cozy.client.files.listTrash()\n\n\n\n\ncozy.client.files.clearTrash()\n\n\ncozy.client.files.clearTrash()\n destroys definitively all trash content.\n\n\nawait cozy.client.files.clearTrash()\n\n\n\n\ncozy.client.files.downloadById(id)\n\n\ncozy.client.files.downloadById(id)\n is used to download a file identified by the given id. The file is downloaded through the browser fetch method, use this if you plan to use the file in javascript after.\n\n\nIt returns a promise of a fetch \nResponse\n object. This response object can be used to extract the information in the wanted form.\n\n\n\n\nid\n is a string specifying the identifier of the file\n\n\n\n\nconst response = await cozy.client.files.downloadById(\n1234567\n)\nconst blob = await response.blob()\nconst text = await response.text()\nconst buff = await response.arrayBuffer()\nresponse.pipe(fs.createWriteStream('/some/file'))\n\n\n\n\ncozy.client.files.downloadByPath(path)\n\n\ncozy.client.files.downloadByPath(path)\n is used to download a file identified by the given path. The file is downloaded through the browser fetch method, use this if you plan to use the file in javascript after.\n\n\nIt returns a promise of a fetch \nResponse\n object. This response object can be used to extract the information in the wanted form.\n\n\n\n\npath\n is a string specifying the path of the file\n\n\n\n\nconst response = await cozy.client.files.downloadByPath(\n/foo/hello.txt\n)\nconst blob = await response.blob()\nconst text = await response.text()\nconst buff = await response.arrayBuffer()\nresponse.pipe(fs.createWriteStream('/some/file'))\n\n\n\n\ncozy.client.files.getDownloadLinkById(id)\n\n\ncozy.client.files.getDownloadLinkById(id)\n is used to get a download link for the file identified by the given id.\n\n\nIt returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download like this:\n\n\nconst href = await cozy.client.files.getDownloadLinkById(\nid424242\n)\nconst link = document.createElement('a')\nlink.href = href\nlink.download = fileName\ndocument.body.appendChild(link) \n link.click()\n\n\n\n\n\n\nid\n is a string specifying the id of the file\n\n\n\n\ncozy.client.files.getDownloadLinkByPath(path)\n\n\ncozy.client.files.getDownloadLinkByPath(path)\n is used to get a download link for the file identified by the given path.\n\n\nIt returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download like this:\n\n\nconst href = await cozy.client.files.getDownloadLinkByPath(\n/foo/hello.txt\n)\nconst link = document.createElement('a')\nlink.href = href\nlink.download = fileName\ndocument.body.appendChild(link) \n link.click()\n\n\n\n\n\n\npath\n is a string specifying the path of the file\n\n\n\n\ncozy.client.files.getArchiveLinkByPaths(paths, name)\n\n\ncozy.client.files.getArchiveLinkByPaths(paths, name)\n is used to get a download link for a zip file containing all the files identified by the given paths.\n\n\nIt returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download (see code in getDownloadLinkById)\n\n\nconst href = await cozy.client.files.getArchiveLinkByPaths([\n  \n/foo/hello.txt\n,\n  \n/bar/test.txt\n\n])\n// href === \n/files/archive/b1c127c25d99f0b37ac2c2a907f36069/files.zip\n\n\nconst href = await cozy.client.files.getArchiveLinkByPaths([\n/foo/hello.txt\n], \nsecretproject\n)\n// href === \n/files/archive/bc2a901c127c25d99f0b37a36069c27f/secretproject.zip\n\n\n\n\n\n\npaths\n is an array of paths\n\n\nname\n is the optional name for the generated archive file (default \nfiles\n).\n\n\n\n\ncozy.client.files.getArchiveLinkByIds(ids, name)\n\n\ncozy.client.files.getArchiveLinkByIds(ids, name)\n is used to get a download link for a zip file containing all the files identified by the given ids.\n\n\nIt returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download (see code in getDownloadLinkById)\n\n\nconst href = await cozy.client.files.getArchiveLinkByIds([\n  \n1234567\n,\n  \n9876543\n\n])\n// href === \n/files/archive/b1c127c25d99f0b37ac2c2a907f36069/files.zip\n\n\nconst href = await cozy.client.files.getArchiveLinkByIds([\n1592673\n], \nsecretproject\n)\n// href === \n/files/archive/bc2a901c127c25d99f0b37a36069c27f/secretproject.zip\n\n\n\n\n\n\nids\n is an array of ids\n\n\nname\n is the optional name for the generated archive file (default \nfiles\n).\n\n\n\n\ncozy.client.files.getFilePath(file, folder)\n\n\ncozy.client.files.getFilePath(file, folder)\n is a helper that generates the file path from root directory. It may be used to specify the path parameter for functions like\n\ncozy.client.files.downloadByPath\n, \ncozy.client.files.getDownloadLinkByPath\n or \ncozy.client.files.getArchiveLinkByPaths\n.\n\n\ncozy.client.data.addReferencedFiles(doc, fileIds)\n\n\ncozy.client.data.addReferencedFiles(doc, fileIds)\n binds the files to the document.\n(see cozy-stack \ndocumentation\n for more details)\n\n\ncozy.client.data.removeReferencedFiles(doc, fileIds)\n\n\ncozy.client.data.removeReferencedFiles(doc, fileIds)\n unbinds the files to the document.\n(see cozy-stack \ndocumentation\n for more details)\n\n\ncozy.client.data.listReferencedFiles(doc)\n\n\ncozy.client.data.listReferencedFiles(doc)\n list the files bound to the document.\n(see cozy-stack \ndocumentation\n for more details).\n\n\nIt returns a promise for a list of filesIds. Files must then be fetched separately.\n\n\ncozy.client.data.fetchReferencedFiles(doc)\n\n\ncozy.client.data.fetchReferencedFiles(doc)\n fetches the files bound to the document.\n(see cozy-stack \ndocumentation\n for more details).\n\n\nIt returns a promise for a list of files.\n\n\ncozy.client.files.query(indexReference, query)\n\n\ncozy.client.files.query(indexReference, query)\n find files using an index.\n\n\nIt returns a promise with a list of files matching the query. Results will be returned in the order defined for the index.\n\n\n\n\nquery\n is an object with the following fields:\n\n\nselector\n: a mango selector\n\n\nlimit\n: maximum number of results\n\n\nskip\n: ignore the first x results (pagination)\n\n\nwholeResponse\n: when set to true, the whole query response will be returned instead of just the docs. This is useful when paginating, because you\nll get the \nnext\n property in the response object.\n\n\n\n\nconst results = await cozy.client.files.query(photosByDate, {\n  \nselector\n: {\nclass\n: \nimage\n},\n  \nlimit\n: 3,\n  \nskip\n: 1\n})", 
            "title": "Files API"
        }, 
        {
            "location": "/cozy-client-js/files-api/#files-api", 
            "text": "", 
            "title": "Files API"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilescreatedata-options", 
            "text": "cozy.client.files.create(data, options)  is used to upload a new file onto your cozy  It returns a promise for the document of the file created.   data  can be of the following type:  Blob ,  File ,  ArrayBuffer ,  ArrayBufferView ,  stream.Readable  (node) or  string .  options  is an object with the following fields:  name : specify the name of the file. optional for a data of type  File , type, mandatory otherwise.  dirID : specify identifier of the file s directory. if empty, it is the root directory.  contentType : specify the content type of the uploaded data. For a  File  type, it is handled automatically in browsers (default:  application/octet-stream ). For nodejs, you can rely on an external module like  mime  checksum : the base64-encoded (with padding) MD5 digest of the file (optional).  lastModifiedDate : a date to specify the last modification time to use for the uploaded file. If the given  data  is a  File  instance, the  lastModifiedDate  is automatically used (not overridden).   Warning : this API is not v2 compatible.  const created = await cozy.client.files.create(blob, {\n    name:  filename ,\n    dirID:  123456 ,\n})\nconst fileCreated = await cozy.client.files.create(fileInput.files[0], {\n  dirID:  ,\n  checksum:  rL0Y20zC+Fzt72VPzMSk2A== ,\n  lastModifiedDate: new Date()\n})", 
            "title": "cozy.client.files.create(data, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilescreatedirectoryoptions", 
            "text": "cozy.client.files.createDirectory(options)  is used to create a new directory.  It returns a promise for the document of the directory created.   options  is an object with the following fields:  name : specify the name of the directory  dirID : specify identifier of the file s directory. if empty, it is the root directory.  lastModifiedDate : a date to specify the last modification time to use for the directory.   const created = await cozy.client.files.createDirectory({\n  name:  mydir ,\n  dirID:  123456 ,\n  lastModifiedDate: new Date()\n})", 
            "title": "cozy.client.files.createDirectory(options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilescreatedirectorybypathpath", 
            "text": "cozy.client.files.createDirectoryByPath(path)  is used to create one or more directories for a given path.  It returns a promise for the document of the last directory created.   path  is a string   const barDirectory = await cozy.client.files.createDirectoryByPath('/Foo/Bar')", 
            "title": "cozy.client.files.createDirectoryByPath(path)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesupdatebyidid-data-options", 
            "text": "cozy.client.files.updateById(id, data, options)  is used to update the content of an already existing file.  It returns a promise for the document of the file updated.   id  is a string specifying the identifier of the file to modify.  data  can be of the following type:  Blob ,  File ,  ArrayBuffer ,  ArrayBufferView  or  string .  options  is an object with the following fields:  contentType : specify the content type of the uploaded data. For a  File  type, it is be handled automatically. default:  application/octet-stream .  checksum : the base64-encoded (with padding) MD5 digest of the file (optional).  lastModifiedDate : a date to specify the last modification time to use for the uploaded file. If the given  data  is a  File  instance, the  lastModifiedDate  is automatically used (not overridden).  ifMatch : the previous revision of the file (optional). The update will be rejected if the remote revision doesn t match the given one.   const updated = await cozy.client.files.updateById( 654321 , blob, {\n  contentType:  text/plain ,\n  checksum:  rL0Y20zC+Fzt72VPzMSk2A== ,\n  lastModifiedDate: new Date(),\n  ifMatch:  1-0e6d5b72 \n})", 
            "title": "cozy.client.files.updateById(id, data, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesupdateattributesbyidid-attrs-options", 
            "text": "cozy.client.files.updateAttributesById(id, attrs, options)  is used to update the attributes associated to a file or directory specified by its id.  It returns a promise for the document of the updated directory or file.   id  is a string specifying the identifier of the file or directory to update  attrs  is an object containing the changes  options  is an object with the following fields:  ifMatch : the previous revision of the file (optional). The update will be rejected if the remote revision doesn t match the given one.   const updated = await cozy.client.files.updateAttributesById( 12345 , { tags: [ foo ] }, { ifMatch:  1-0e6d5b72  })", 
            "title": "cozy.client.files.updateAttributesById(id, attrs, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesupdateattributesbypathpath-attrs-options", 
            "text": "cozy.client.files.updateAttributesByPath(path, attrs, options)  is used to update the attributes associated to a file or directory specified by the given path.  It returns a promise for the document of the updated directory or file.   path : string specifying the path of the file or directory to update  attrs  is an object containing the changes  options  is an object with the following fields:  ifMatch : the previous revision of the file (optional). The update will be rejected if the remote revision doesn t match the given one.   const updated = await cozy.client.files.updateAttributes( /foo/bar , { executable: true }, { ifMatch:  1-0e6d5b72  })", 
            "title": "cozy.client.files.updateAttributesByPath(path, attrs, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesstatbyidid-offline-options", 
            "text": "cozy.client.files.statById(id, offline, options)  is used to get the metadata of a file specified by its id.  It returns a promise for the information of the file or directory. In the case of a directory, it contains the list of files and sub-directories inside it. This list is limited to 30 items by default, but the  options  argument allows you\nto fetch more items.   id  is a string specifying the file\u2019s or directory\u2019s identifier  offline  is a boolean (default to  true )  options  is an object with the following fields:  skip : number of items to skip (optional)  limit : maximum number of items to return (optional).   By default,  statById  will fetch the metadata from the local database, if it is available. Set the second parameter to  false  to query the server.  Returned directory have a  relations()  method that allow to access to their content:  const dir = await cozy.client.files.statById( io.cozy.files.root-dir );\ndir.relations('contents').forEach( (file) =  \u2026 )", 
            "title": "cozy.client.files.statById(id, offline, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesstatbypathpath", 
            "text": "cozy.client.files.statByPath(path)  is used to get the metadata of a file specified by its path.   path : string specifying the path of the file or directory;", 
            "title": "cozy.client.files.statByPath(path)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilestrashbyidid-options", 
            "text": "cozy.client.files.trashById(id, options)  is used to move the file or directory identified by the given id to trash.  It returns a promise for the document of the file or directory moved to trash.   id  is a string specifying the identifier of the file or directory  options  is an object with the following fields:  ifMatch : the previous revision of the file (optional). The update will be rejected if the remote revision doesn t match the given one.   const trashed = await cozy.client.files.trashById( 1234567 )", 
            "title": "cozy.client.files.trashById(id, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesdestroybyidid-options", 
            "text": "cozy.client.files.destroyById(id, options)  is used to shred (destroy definitively) a file or directory identified by the given id.  The file must be in the trash folder first.  It returns a promise for completion   id  is a string specifying the identifier of the file or directory  options  is an object with the following fields:  ifMatch : the previous revision of the file (optional). The update will be rejected if the remote revision doesn t match the given one.   const trashed = await cozy.client.files.trashById( 1234567 )\nawait cozy.client.files.destroyById( 1234567 )", 
            "title": "cozy.client.files.destroyById(id, options)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesrestorebyidid", 
            "text": "cozy.client.files.restoreById(id)  is used to restore a file or directory identified by the given id. The file must be in the trash folder.  It returns a promise for the restored doc. (with updated parent)   id  is a string specifying the identifier of the file or directory   const trashed = await cozy.client.files.trashById( 1234567 )\nconst restored = await cozy.client.files.restoreById( 1234567 )", 
            "title": "cozy.client.files.restoreById(id)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfileslisttrash", 
            "text": "cozy.client.files.listTrash()  returns a promise for the list of all files in the trash.  const trashedFilesAndFolders = await cozy.client.files.listTrash()", 
            "title": "cozy.client.files.listTrash()"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilescleartrash", 
            "text": "cozy.client.files.clearTrash()  destroys definitively all trash content.  await cozy.client.files.clearTrash()", 
            "title": "cozy.client.files.clearTrash()"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesdownloadbyidid", 
            "text": "cozy.client.files.downloadById(id)  is used to download a file identified by the given id. The file is downloaded through the browser fetch method, use this if you plan to use the file in javascript after.  It returns a promise of a fetch  Response  object. This response object can be used to extract the information in the wanted form.   id  is a string specifying the identifier of the file   const response = await cozy.client.files.downloadById( 1234567 )\nconst blob = await response.blob()\nconst text = await response.text()\nconst buff = await response.arrayBuffer()\nresponse.pipe(fs.createWriteStream('/some/file'))", 
            "title": "cozy.client.files.downloadById(id)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesdownloadbypathpath", 
            "text": "cozy.client.files.downloadByPath(path)  is used to download a file identified by the given path. The file is downloaded through the browser fetch method, use this if you plan to use the file in javascript after.  It returns a promise of a fetch  Response  object. This response object can be used to extract the information in the wanted form.   path  is a string specifying the path of the file   const response = await cozy.client.files.downloadByPath( /foo/hello.txt )\nconst blob = await response.blob()\nconst text = await response.text()\nconst buff = await response.arrayBuffer()\nresponse.pipe(fs.createWriteStream('/some/file'))", 
            "title": "cozy.client.files.downloadByPath(path)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesgetdownloadlinkbyidid", 
            "text": "cozy.client.files.getDownloadLinkById(id)  is used to get a download link for the file identified by the given id.  It returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download like this:  const href = await cozy.client.files.getDownloadLinkById( id424242 )\nconst link = document.createElement('a')\nlink.href = href\nlink.download = fileName\ndocument.body.appendChild(link)   link.click()   id  is a string specifying the id of the file", 
            "title": "cozy.client.files.getDownloadLinkById(id)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesgetdownloadlinkbypathpath", 
            "text": "cozy.client.files.getDownloadLinkByPath(path)  is used to get a download link for the file identified by the given path.  It returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download like this:  const href = await cozy.client.files.getDownloadLinkByPath( /foo/hello.txt )\nconst link = document.createElement('a')\nlink.href = href\nlink.download = fileName\ndocument.body.appendChild(link)   link.click()   path  is a string specifying the path of the file", 
            "title": "cozy.client.files.getDownloadLinkByPath(path)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesgetarchivelinkbypathspaths-name", 
            "text": "cozy.client.files.getArchiveLinkByPaths(paths, name)  is used to get a download link for a zip file containing all the files identified by the given paths.  It returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download (see code in getDownloadLinkById)  const href = await cozy.client.files.getArchiveLinkByPaths([\n   /foo/hello.txt ,\n   /bar/test.txt \n])\n// href ===  /files/archive/b1c127c25d99f0b37ac2c2a907f36069/files.zip \n\nconst href = await cozy.client.files.getArchiveLinkByPaths([ /foo/hello.txt ],  secretproject )\n// href ===  /files/archive/bc2a901c127c25d99f0b37a36069c27f/secretproject.zip   paths  is an array of paths  name  is the optional name for the generated archive file (default  files ).", 
            "title": "cozy.client.files.getArchiveLinkByPaths(paths, name)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesgetarchivelinkbyidsids-name", 
            "text": "cozy.client.files.getArchiveLinkByIds(ids, name)  is used to get a download link for a zip file containing all the files identified by the given ids.  It returns a promise for the download link.\nDownload link are only valid for a short while (default 1 hour)\nYou can use this link to start a browser download (see code in getDownloadLinkById)  const href = await cozy.client.files.getArchiveLinkByIds([\n   1234567 ,\n   9876543 \n])\n// href ===  /files/archive/b1c127c25d99f0b37ac2c2a907f36069/files.zip \n\nconst href = await cozy.client.files.getArchiveLinkByIds([ 1592673 ],  secretproject )\n// href ===  /files/archive/bc2a901c127c25d99f0b37a36069c27f/secretproject.zip   ids  is an array of ids  name  is the optional name for the generated archive file (default  files ).", 
            "title": "cozy.client.files.getArchiveLinkByIds(ids, name)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesgetfilepathfile-folder", 
            "text": "cozy.client.files.getFilePath(file, folder)  is a helper that generates the file path from root directory. It may be used to specify the path parameter for functions like cozy.client.files.downloadByPath ,  cozy.client.files.getDownloadLinkByPath  or  cozy.client.files.getArchiveLinkByPaths .", 
            "title": "cozy.client.files.getFilePath(file, folder)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientdataaddreferencedfilesdoc-fileids", 
            "text": "cozy.client.data.addReferencedFiles(doc, fileIds)  binds the files to the document.\n(see cozy-stack  documentation  for more details)", 
            "title": "cozy.client.data.addReferencedFiles(doc, fileIds)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientdataremovereferencedfilesdoc-fileids", 
            "text": "cozy.client.data.removeReferencedFiles(doc, fileIds)  unbinds the files to the document.\n(see cozy-stack  documentation  for more details)", 
            "title": "cozy.client.data.removeReferencedFiles(doc, fileIds)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientdatalistreferencedfilesdoc", 
            "text": "cozy.client.data.listReferencedFiles(doc)  list the files bound to the document.\n(see cozy-stack  documentation  for more details).  It returns a promise for a list of filesIds. Files must then be fetched separately.", 
            "title": "cozy.client.data.listReferencedFiles(doc)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientdatafetchreferencedfilesdoc", 
            "text": "cozy.client.data.fetchReferencedFiles(doc)  fetches the files bound to the document.\n(see cozy-stack  documentation  for more details).  It returns a promise for a list of files.", 
            "title": "cozy.client.data.fetchReferencedFiles(doc)"
        }, 
        {
            "location": "/cozy-client-js/files-api/#cozyclientfilesqueryindexreference-query", 
            "text": "cozy.client.files.query(indexReference, query)  find files using an index.  It returns a promise with a list of files matching the query. Results will be returned in the order defined for the index.   query  is an object with the following fields:  selector : a mango selector  limit : maximum number of results  skip : ignore the first x results (pagination)  wholeResponse : when set to true, the whole query response will be returned instead of just the docs. This is useful when paginating, because you ll get the  next  property in the response object.   const results = await cozy.client.files.query(photosByDate, {\n   selector : { class :  image },\n   limit : 3,\n   skip : 1\n})", 
            "title": "cozy.client.files.query(indexReference, query)"
        }, 
        {
            "location": "/cozy-client-js/jobs-api/", 
            "text": "Jobs\n\n\ncozy.clients.jobs.count(workerType)\n\n\ncozy.clients.jobs.count\n returns the number of jobs in the queue for \nworkerType\n.\n\n\nconst nb = cozy.client.jobs.count('sendmail')\nconsole.log(`There are ${count} mails waiting to be sent`)\n\n\n\n\ncozy.clients.jobs.create(workerType, arguments, options)\n\n\ncozy.clients.jobs.create\n enqueues a job in the queue for \nworkerType\n.\n\n\nconst job = cozy.client.jobs.create('sendmail', {\n  mode: 'from',\n  to: [\n    { name: 'Support', email: 'contact@cozycloud.cc' }\n  ],\n  subject: 'Ask support for cozy-desktop',\n  parts: [\n    { type: 'text/plain', body: 'Hello, I would like some help' }\n  ]\n})\n\n\n\n\nSee \nthe cozy-stack documentation\n for more informations", 
            "title": "Jobs API"
        }, 
        {
            "location": "/cozy-client-js/jobs-api/#jobs", 
            "text": "", 
            "title": "Jobs"
        }, 
        {
            "location": "/cozy-client-js/jobs-api/#cozyclientsjobscountworkertype", 
            "text": "cozy.clients.jobs.count  returns the number of jobs in the queue for  workerType .  const nb = cozy.client.jobs.count('sendmail')\nconsole.log(`There are ${count} mails waiting to be sent`)", 
            "title": "cozy.clients.jobs.count(workerType)"
        }, 
        {
            "location": "/cozy-client-js/jobs-api/#cozyclientsjobscreateworkertype-arguments-options", 
            "text": "cozy.clients.jobs.create  enqueues a job in the queue for  workerType .  const job = cozy.client.jobs.create('sendmail', {\n  mode: 'from',\n  to: [\n    { name: 'Support', email: 'contact@cozycloud.cc' }\n  ],\n  subject: 'Ask support for cozy-desktop',\n  parts: [\n    { type: 'text/plain', body: 'Hello, I would like some help' }\n  ]\n})  See  the cozy-stack documentation  for more informations", 
            "title": "cozy.clients.jobs.create(workerType, arguments, options)"
        }, 
        {
            "location": "/cozy-client-js/intents-api/", 
            "text": "Intents\n\n\ncozy.client.intents.create()\n\n\ncozy.client.intents.create(action, doctype [, data, permissions])\n create an intent. It returns a modified Promise for the intent document, having a custom \nstart(element)\n method. This method interacts with the DOM to append an iframe to the given HTML element. This iframe will provide an access to an app, which will serve a service page able to manage the intent action for the intent doctype. The \nstart(element)\n method returns a promise for the result document provided by intent service.\n\n\n\n\nOn Intent ready callback:\n This \nstart\n method also takes a second optional argument which is a callback function (\nstart(element, onReadyCallback)\n). When provided, this function will be run when the intent iframe will be completely loaded (using the \nonload\n iframe listener). This callback could be useful to run a client code only when the intent iframe is ready and loaded.\n\n\n\n\nAn intent has to be created everytime an app need to perform an action over a doctype for wich it does not have permission. For example, the Cozy Drive app should create an intent to \npick\n a \nio.cozy.contacts\n document. The cozy-stack will determines which app can offer a service to resolve the intent. It\ns this service\ns URL that will be passed to the iframe \nsrc\n property.\n\n\nOnce the intent process is terminated by service, the iframe is removed from DOM.\n\n\nExample\n\n\ncozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100})\n  .start(document.getElementById('intent-service-wrapper'))\n\n\n\n\nSee cozy-stack \ndocumentation\n for more details.\n\n\nYou can also use \n.then\n to run some code after the intents is terminated like following:\n\n\ncozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100})\n  .start(document.getElementById('intent-service-wrapper'))\n  .then(doc =\n { // after service.terminate(doc)\n      // code to use the doc\n  })\n\n\n\n\nExample to use \nremoveIntentFrame()\n method (by passing the flag \nexposeIntentFrameRemoval\n flag):\n\n\ncozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100, exposeIntentFrameRemoval: true})\n  .start(document.getElementById('intent-service-wrapper'))\n  .then({removeIntentFrame, doc} =\n { // after service.terminate(doc)\n      // Code to be run before removing the terminated intent iframe\n      removeIntentFrame()\n      // Other code, use doc\n  })\n\n\n\n\ncozy.client.intents.createService()\n\n\ncozy.client.intents.createService([intentId, window])\n has to be used in the intent service page. It initializes communication with the parent window (remember: the service is supposed to be in an iframe).\n\n\nIf \nintentId\n and \nwindow\n parameters are not provided the method will try to retrieve them automatically.\n\n\nIt returns a \nservice\n object, which provides the following methods :\n * \ngetData()\n: returns the data passed to the service by the client.\n * \ngetIntent()\n: returns the intent\n * \nresizeClient(doc, transitionProperty)\n: forces the size of the intent modale to a given width, maxWidth, height, maxHeight, or dimensions of a given element. The second optional argument \ntransitionProperty\n can be used to add a CSS transition property on the intent in order to \nanimate\n the resizing.\n \njs\n // resize the client ot 300 pixels max height\n service.resizeClient({\n    maxHeight: 300\n}, '.2s linear') // will be in css -\n transition: .2s linear;\n // or\n service.resizeClient({\n    element: document.querySelector('.class')\n })\n\n\n\n\nOn intent size:\n If an intent is used by multiple applications, we don\nt use resizeClient(), since each application can have his own layout. You have to define the size of the intent in your application\n\n\n\n\n\n\n\n\nterminate(doc)\n: ends the intent process by passing to the client the resulting document \ndoc\n. An intent service may only be terminated once.\n\n\n\n\nIf a boolean \nexposeIntentFrameRemoval\n is found as \ntrue\n in the data sent by the client, the \nterminate()\n method will return an object with as properties a function named \nremoveIntentFrame\n to remove the iframe DOM node (in order to be run by the client later on) and the resulting document \ndoc\n. This could be useful to animate an intent closing and remove the iframe node at the animation ending.\n\n\n\n\n\n\n\n\ncancel()\n: ends the intent process by passing a \nnull\n value to the client. This method terminate the intent service the same way that \nterminate()\n.\n\n\n\n\nthrow(error)\n: throw an error to client and causes the intent promise rejection.\n\n\n\n\nExample\n\n\ncozy.client.intents.createService('77bcc42c-0fd8-11e7-ac95-8f605f6e8338', window)\n  .then(intentService =\n {\n    const data = intentService.getData()\n\n    // [...]\n    // Do stuff with data\n    // [...]\n\n    const resultingDoc = {\n      type: 'io.cozy.photos',\n      width: 100,\n      height: 100\n    }\n\n    intentService.terminate(resultingDoc)\n  })", 
            "title": "Intents API"
        }, 
        {
            "location": "/cozy-client-js/intents-api/#intents", 
            "text": "", 
            "title": "Intents"
        }, 
        {
            "location": "/cozy-client-js/intents-api/#cozyclientintentscreate", 
            "text": "cozy.client.intents.create(action, doctype [, data, permissions])  create an intent. It returns a modified Promise for the intent document, having a custom  start(element)  method. This method interacts with the DOM to append an iframe to the given HTML element. This iframe will provide an access to an app, which will serve a service page able to manage the intent action for the intent doctype. The  start(element)  method returns a promise for the result document provided by intent service.   On Intent ready callback:  This  start  method also takes a second optional argument which is a callback function ( start(element, onReadyCallback) ). When provided, this function will be run when the intent iframe will be completely loaded (using the  onload  iframe listener). This callback could be useful to run a client code only when the intent iframe is ready and loaded.   An intent has to be created everytime an app need to perform an action over a doctype for wich it does not have permission. For example, the Cozy Drive app should create an intent to  pick  a  io.cozy.contacts  document. The cozy-stack will determines which app can offer a service to resolve the intent. It s this service s URL that will be passed to the iframe  src  property.  Once the intent process is terminated by service, the iframe is removed from DOM.", 
            "title": "cozy.client.intents.create()"
        }, 
        {
            "location": "/cozy-client-js/intents-api/#example", 
            "text": "cozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100})\n  .start(document.getElementById('intent-service-wrapper'))  See cozy-stack  documentation  for more details.  You can also use  .then  to run some code after the intents is terminated like following:  cozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100})\n  .start(document.getElementById('intent-service-wrapper'))\n  .then(doc =  { // after service.terminate(doc)\n      // code to use the doc\n  })  Example to use  removeIntentFrame()  method (by passing the flag  exposeIntentFrameRemoval  flag):  cozy.client.intents.create('EDIT', 'io.cozy.photos', {action: 'crop', width: 100, height: 100, exposeIntentFrameRemoval: true})\n  .start(document.getElementById('intent-service-wrapper'))\n  .then({removeIntentFrame, doc} =  { // after service.terminate(doc)\n      // Code to be run before removing the terminated intent iframe\n      removeIntentFrame()\n      // Other code, use doc\n  })", 
            "title": "Example"
        }, 
        {
            "location": "/cozy-client-js/intents-api/#cozyclientintentscreateservice", 
            "text": "cozy.client.intents.createService([intentId, window])  has to be used in the intent service page. It initializes communication with the parent window (remember: the service is supposed to be in an iframe).  If  intentId  and  window  parameters are not provided the method will try to retrieve them automatically.  It returns a  service  object, which provides the following methods :\n *  getData() : returns the data passed to the service by the client.\n *  getIntent() : returns the intent\n *  resizeClient(doc, transitionProperty) : forces the size of the intent modale to a given width, maxWidth, height, maxHeight, or dimensions of a given element. The second optional argument  transitionProperty  can be used to add a CSS transition property on the intent in order to  animate  the resizing.\n  js\n // resize the client ot 300 pixels max height\n service.resizeClient({\n    maxHeight: 300\n}, '.2s linear') // will be in css -  transition: .2s linear;\n // or\n service.resizeClient({\n    element: document.querySelector('.class')\n })   On intent size:  If an intent is used by multiple applications, we don t use resizeClient(), since each application can have his own layout. You have to define the size of the intent in your application     terminate(doc) : ends the intent process by passing to the client the resulting document  doc . An intent service may only be terminated once.   If a boolean  exposeIntentFrameRemoval  is found as  true  in the data sent by the client, the  terminate()  method will return an object with as properties a function named  removeIntentFrame  to remove the iframe DOM node (in order to be run by the client later on) and the resulting document  doc . This could be useful to animate an intent closing and remove the iframe node at the animation ending.     cancel() : ends the intent process by passing a  null  value to the client. This method terminate the intent service the same way that  terminate() .   throw(error) : throw an error to client and causes the intent promise rejection.", 
            "title": "cozy.client.intents.createService()"
        }, 
        {
            "location": "/cozy-client-js/intents-api/#example_1", 
            "text": "cozy.client.intents.createService('77bcc42c-0fd8-11e7-ac95-8f605f6e8338', window)\n  .then(intentService =  {\n    const data = intentService.getData()\n\n    // [...]\n    // Do stuff with data\n    // [...]\n\n    const resultingDoc = {\n      type: 'io.cozy.photos',\n      width: 100,\n      height: 100\n    }\n\n    intentService.terminate(resultingDoc)\n  })", 
            "title": "Example"
        }, 
        {
            "location": "/cozy-client-js/settings-api/", 
            "text": "Settings\n\n\ncozy.client.settings.diskUsage()\n\n\ncozy.client.settings.diskUsage\n is used to known informations about the total used space on the cozy disk.\n\n\nIt returns a promise of the document of the disk-usage of id \nio.cozy.settings.disk-usage\n, with attributes containing a \nused\n field a string of how many \nbytes\n are used on the disk.\n\n\nThe \nused\n field is a string since the underlying data is an \nint64\n which may not be properly represented in javascript.\n\n\nconst usage = await cozy.client.settings.diskUsage()\nconsole.log(usage.attributes.used)\n\n\n\n\ncozy.client.settings.changePassphrase(oldPassphrase, newPassphrase)\n\n\ncozy.client.settings.changePassphrase\n is used to change the passphrase of the current user. You must supply the currently used passphrase, as well as the new one. It simply returns a promise that will resolve if the change was successful.\n\n\ncozy.client.settings.getInstance()\n\n\ncozy.client.settings.getInstance\n returns a promise with informations about the current Cozy instance, such as the locale or the public name. See cozy-stack \ndocumentation\n for more details.\n\n\ncozy.client.settings.updateInstance(instance)\n\n\ncozy.client.settings.updateInstance\n is used to update informations about the current instance. \ninstance\n is an object that should be based on to the one you receive from \ncozy.settings.getInstance()\n. It returns a promise with the updated instance information.\n\n\ncozy.client.settings.getClients()\n\n\ncozy.client.settings.getClients\n returns a promise for an array of registered clients. See the \ncozy-stack documentation\n for more details.\n\n\ncozy.client.settings.deleteClientById('123')\n\n\ncozy.client.settings.deleteClientById\n revokes the specified client from the instance. This method returns a promise that simply resolves if the revokation was successful.", 
            "title": "Settings API"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingsdiskusage", 
            "text": "cozy.client.settings.diskUsage  is used to known informations about the total used space on the cozy disk.  It returns a promise of the document of the disk-usage of id  io.cozy.settings.disk-usage , with attributes containing a  used  field a string of how many  bytes  are used on the disk.  The  used  field is a string since the underlying data is an  int64  which may not be properly represented in javascript.  const usage = await cozy.client.settings.diskUsage()\nconsole.log(usage.attributes.used)", 
            "title": "cozy.client.settings.diskUsage()"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingschangepassphraseoldpassphrase-newpassphrase", 
            "text": "cozy.client.settings.changePassphrase  is used to change the passphrase of the current user. You must supply the currently used passphrase, as well as the new one. It simply returns a promise that will resolve if the change was successful.", 
            "title": "cozy.client.settings.changePassphrase(oldPassphrase, newPassphrase)"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingsgetinstance", 
            "text": "cozy.client.settings.getInstance  returns a promise with informations about the current Cozy instance, such as the locale or the public name. See cozy-stack  documentation  for more details.", 
            "title": "cozy.client.settings.getInstance()"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingsupdateinstanceinstance", 
            "text": "cozy.client.settings.updateInstance  is used to update informations about the current instance.  instance  is an object that should be based on to the one you receive from  cozy.settings.getInstance() . It returns a promise with the updated instance information.", 
            "title": "cozy.client.settings.updateInstance(instance)"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingsgetclients", 
            "text": "cozy.client.settings.getClients  returns a promise for an array of registered clients. See the  cozy-stack documentation  for more details.", 
            "title": "cozy.client.settings.getClients()"
        }, 
        {
            "location": "/cozy-client-js/settings-api/#cozyclientsettingsdeleteclientbyid123", 
            "text": "cozy.client.settings.deleteClientById  revokes the specified client from the instance. This method returns a promise that simply resolves if the revokation was successful.", 
            "title": "cozy.client.settings.deleteClientById('123')"
        }, 
        {
            "location": "/cozy-client-js/sharing-api/", 
            "text": "Sharing\n\n\ncozy.client.files.getCollectionShareLink(id, collectionType)\n\n\ngetCollectionShareLink\n creates codes that can be used to share a collection by links. See \nthe stack documentation\n for more informations.\n\n\nconst sharing = cozy.client.files.getCollectionShareLink(albumID, 'io.cozy.albums')\nconsole.log('Sharing id:', sharing.id)\nconsole.log('Sharing query-string with the sharecode:', sharing.sharecode)", 
            "title": "Sharing API"
        }, 
        {
            "location": "/cozy-client-js/sharing-api/#sharing", 
            "text": "", 
            "title": "Sharing"
        }, 
        {
            "location": "/cozy-client-js/sharing-api/#cozyclientfilesgetcollectionsharelinkid-collectiontype", 
            "text": "getCollectionShareLink  creates codes that can be used to share a collection by links. See  the stack documentation  for more informations.  const sharing = cozy.client.files.getCollectionShareLink(albumID, 'io.cozy.albums')\nconsole.log('Sharing id:', sharing.id)\nconsole.log('Sharing query-string with the sharecode:', sharing.sharecode)", 
            "title": "cozy.client.files.getCollectionShareLink(id, collectionType)"
        }
    ]
}